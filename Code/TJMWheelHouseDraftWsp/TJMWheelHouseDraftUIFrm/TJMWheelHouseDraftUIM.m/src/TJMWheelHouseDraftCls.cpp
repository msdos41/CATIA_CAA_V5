// COPYRIGHT Dassault Systemes 2021
//===================================================================
//
// TJMWheelHouseDraftCls.cpp
// Header definition of TJMWheelHouseDraftCls
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Feb 2021  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TJMWheelHouseDraftCls.h"
 
CATImplementClass( TJMWheelHouseDraftCls,
                   Implementation, 
                   CATBaseUnknown,
                   CATNull );
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : constructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::TJMWheelHouseDraftCls():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : destructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::~TJMWheelHouseDraftCls()
{
}
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : copy constructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::TJMWheelHouseDraftCls(TJMWheelHouseDraftCls& original):
   CATBaseUnknown(original)
{
}
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : equal operator
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls& TJMWheelHouseDraftCls::operator=(TJMWheelHouseDraftCls& original)
{
   CATBaseUnknown::operator=(original);
   return *this;
}
 
HRESULT TJMWheelHouseDraftCls::SetDatas(CATIProduct_var *iRootProduct,CATISpecObject_var *iSurface,CATBaseUnknown_var *iSketch,CATBaseUnknown_var *iToolingDir,double iDraftAngle)
{
	_spiRootProduct = *iRootProduct;

	_spiSpecSurface = *iSurface;

	_spBUSketch = *iSketch;

	_spBUToolingDir = *iToolingDir;

	_dDraftAngle = iDraftAngle;
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::ComputeResults()
{
	//获取拔模方向
	CATMathVector dirTooling;
	CATIMeasurableLine_var spiMeasurableLine = _spBUToolingDir;
	if (spiMeasurableLine==NULL_var)
	{
		return E_FAIL;
	}
	spiMeasurableLine->GetDirection(dirTooling);
	if (dirTooling.GetZ()<0)
	{
		dirTooling = -1*dirTooling;
	}
	dirTooling.Normalize();

	//获取草图平面方向
	CATISketch_var spiSketch = _spBUSketch;
	if (spiSketch==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPlane=NULL_var;
	if (FAILED(spiSketch->GetPlanarSupport(spiSpecPlane))||spiSpecPlane==NULL_var)
	{
		return E_FAIL;
	}
	CATIMeasurablePlane_var spiMeasurablePlane = spiSpecPlane;
	if (spiMeasurablePlane==NULL_var)
	{
		return E_FAIL;
	}
	CATMathPlane planeSketch;
	spiMeasurablePlane->GetPlane(planeSketch);
	CATMathVector dirSketch;
	planeSketch.GetNormal(dirSketch);
	if (dirSketch.GetZ()<0)
	{
		dirSketch = -1*dirSketch;
	}
	dirSketch.Normalize();

	//创建工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=TJMWheelHouseDraftGeneralClass::GetProductGeoFactoryAndPrtCont(_spiRootProduct,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL || ospiCont==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPart = ospiCont->GetPart();
	if (spiSpecPart==NULL_var)
	{
		return E_FAIL;
	}
	CATIGSMFactory_var spiGSMFact = ospiCont;
	CATICkeParmFactory_var spiCkeFact = ospiCont;
	CATIPrtFactory_var spiPrtFact = ospiCont;
	if (spiGSMFact==NULL_var||spiCkeFact==NULL_var||spiPrtFact==NULL_var)
	{
		return E_FAIL;
	}
	CATIAPart_var spiaPart = spiSpecPart;
	if (spiaPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAFactory *pHybridShapeFactory=NULL;
	spiaPart->get_HybridShapeFactory(pHybridShapeFactory);
	CATIAHybridShapeFactory_var spHybridShapeFactory=pHybridShapeFactory;
	if (spHybridShapeFactory==NULL_var)
	{
		cout<<"====> get CATIAHybridShapeFactory_var failed............"<<endl;
		return E_FAIL;
	}

	CATIAFactory  *pShapeFactory = NULL;
	spiaPart->get_ShapeFactory(pShapeFactory);
	CATIAShapeFactory_var spShapeFactory = pShapeFactory;
	if (spShapeFactory==NULL_var)
	{
		cout<<"====> get CATIAShapeFactory_var failed............"<<endl;
		return E_FAIL;
	}


	//判断当前曲面的方向
	CATISpecObject_var spiSpecSurfaceBase = _spiSpecSurface;
	int iSplitSide;
	if (FAILED(JudgeSurfacePositiveOrNegative(pGeoFactory,topdata,spiSpecSurfaceBase,dirTooling,iSplitSide)))
	{
		cout<<"===> JudgeSurfacePositiveOrNegative failed.........."<<endl;
		return E_FAIL;
	}
	_structFeaturesInfo.spiSpecBaseSurface = spiSpecSurfaceBase;
	_structFeaturesInfo.iSplitSideBaseSurface = iSplitSide;

	//offset当前曲面并判断方向
	//先创建几何图形集
	CATISpecObject_var spiSpecGS=NULL_var;
	CATUnicodeString strAlias = "Hole_GS";
	if (FAILED(TJMWheelHouseDraftGeneralClass::CreateNewGeoSet(_spiRootProduct,strAlias,spiSpecGS))||spiSpecGS==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecSurfaceOffset=NULL_var;
	double dOffset = 4;
	//dOffset = dOffset/1000;
	boolean bOrientation = TRUE;
	if (1==_structFeaturesInfo.iSplitSideBaseSurface)
	{
		bOrientation=FALSE;
	}
	//if (FAILED(TJMWheelHouseDraftGeneralClass::CreateGSMOffsetSurface(spiGSMFact,spiCkeFact,spiSpecSurfaceBase,spiSpecGS,dOffset,bOrientation,spiSpecSurfaceOffset))||spiSpecSurfaceOffset==NULL_var)
	//{
	//	return E_FAIL;
	//}
	if (FAILED(TJMWheelHouseDraftGeneralClass::CreateVBOffset(spiaPart,spHybridShapeFactory,spiSpecSurfaceBase,spiSpecGS,dOffset,bOrientation,spiSpecSurfaceOffset))||spiSpecSurfaceOffset==NULL_var)
	{
		cout<<"===> CreateVBOffset failed.........."<<endl;
		return E_FAIL;
	}
	if (FAILED(JudgeSurfacePositiveOrNegative(pGeoFactory,topdata,spiSpecSurfaceOffset,-1*dirTooling,iSplitSide)))
	{
		cout<<"===> JudgeSurfacePositiveOrNegative failed.........."<<endl;
		return E_FAIL;
	}
	_structFeaturesInfo.spiSpecOffsetSurface = spiSpecSurfaceOffset;
	_structFeaturesInfo.iSplitSideOffsetSurface = iSplitSide;
	
	TJMWheelHouseDraftGeneralClass::HideSpecObject(spiSpecSurfaceOffset,FALSE);

	//
	vector<CATISpecObject_var> lstSpecCurves;
	if (FAILED(GetSeperatedCurvesFromSketch(lstSpecCurves)))
	{
		cout<<"===> GetSeperatedCurvesFromSketch failed.........."<<endl;
		return E_FAIL;
	}

	//循环创建实体
	vector<CATISpecObject_var> lstSpecSolids;
	for (int i=0;i<lstSpecCurves.size();i++)
	{
		CATISpecObject_var spiSpecCurve = lstSpecCurves[i];
		if (spiSpecCurve==NULL_var)
		{
			continue;
		}
		//创建prttool
		CATUnicodeString strIndex;
		strIndex.BuildFromNum(i+1);
		CATUnicodeString strAlias = "Hole_"+strIndex;
		CATISpecObject_var spiSpecPrtTool=NULL_var;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreateNewPrtTool(_spiRootProduct,strAlias,spiSpecPrtTool))||spiSpecPrtTool==NULL_var)
		{
			cout<<"====> CreateNewPrtTool failed............"<<endl;
			return E_FAIL;
		}
		//创建pad
		CATISpecObject_var spiSpecPad = spiPrtFact->CreatePad(spiSpecCurve,200,200,dirSketch);
		if (spiSpecPad==NULL_var)
		{
			continue;
		}

		int trytimes=1;
		if (TJMWheelHouseDraftGeneralClass::IsObjectExistUpdateError(spiSpecPrtTool,trytimes)==TRUE)
		{
			cout<<"CreatePad Try Update Failed"<<endl;
			//return E_FAIL;
		}

		CATIGSMProceduralView_var spProceduralView =NULL_var;
		spProceduralView = spiSpecPad;
		if (NULL_var != spProceduralView )
		{
			spProceduralView->InsertInProceduralView(spiSpecPrtTool);
		}

		//用basesurface切割
		CATISpecObject_var spiSpecCuttingSurface = _structFeaturesInfo.spiSpecBaseSurface;
		int iSplitSide = _structFeaturesInfo.iSplitSideBaseSurface;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreatePrtSolidSplit(spiPrtFact,spiSpecPrtTool,spiSpecCuttingSurface,iSplitSide)))
		{
			cout<<"====> First CreatePrtSolidSplit failed............."<<endl;
			continue;
		}

		//用offset面切割
		spiSpecCuttingSurface = _structFeaturesInfo.spiSpecOffsetSurface;
		iSplitSide = _structFeaturesInfo.iSplitSideOffsetSurface;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreatePrtSolidSplit(spiPrtFact,spiSpecPrtTool,spiSpecCuttingSurface,iSplitSide)))
		{
			cout<<"====> Second CreatePrtSolidSplit failed............."<<endl;
			continue;
		}

		//判断需要拔模的面
		CATBody_var spBodySolid = TJMWheelHouseDraftGeneralClass::GetBodyFromFeature(spiSpecPrtTool);
		if (spBodySolid==NULL_var)
		{
			continue;
		}
		CATLISTP(CATCell) LISTCell; 
		spBodySolid->GetAllCells( LISTCell, 2 );
		CATLISTV(CATISpecObject_var) lstDraftObject;
		for (int j=1;j<LISTCell.Size();j++)
		{
			CATCell_var spCell = LISTCell[j];
			if (spCell==NULL_var)
			{
				continue;
			}
			CATMathVector dirNormal;
			if (FAILED(GetNormalOfSurface(pGeoFactory,topdata,spBodySolid,spCell,dirNormal)))
			{
				cout<<"GetNormalOfSurface failed.........."<<endl;
				continue;
			}

			//先把不垂直于草图平面的方向过滤掉
			if (abs(dirNormal.GetAngleTo(dirSketch)-CATPIBY2)>0.05)
			{
				continue;
			}

			//和拔模方向比夹角
			CATAngle angleDir = dirNormal.GetAngleTo(dirTooling);
			//double dAngleDraft = _dDraftAngle*CATPI/180;
			double dAngleDraft = _dDraftAngle;
			double dDelta = angleDir-(CATPIBY2-dAngleDraft);
			if (dDelta>0.05)		//此时该面需要拔模
			{
				CATIBRepAccess_var spBRepAccess=CATBRepDecodeCellInBody( spCell, spBodySolid);  
				if (spBRepAccess==NULL_var)
				{
					cout<<"CATBRepDecodeCellInBody Failed"<<endl;
					continue;
				}

				CATISpecObject_var spFindSpec=NULL_var;
				TJMWheelHouseDraftGeneralClass::ConvertToSupportSpec(spBRepAccess, spFindSpec);
				if (spFindSpec==NULL_var)
				{
					cout<<"ConvertToSpec Failed"<<endl;
					continue;
				}
				lstDraftObject.Append(spFindSpec);
			}
		}
		if (lstDraftObject.Size()>0)
		{
			//拔模
			CATISpecObject_var spObjDraft= spiPrtFact->CreateDraft(&lstDraftObject,0,spiSpecSurfaceBase,0,NULL_var,-1*dirTooling,NULL_var,0,_dDraftAngle*CATRadianToDegree,0);

			trytimes=1;
			if (TJMWheelHouseDraftGeneralClass::IsObjectExistUpdateError(spiSpecPrtTool,trytimes)==TRUE)
			{
				cout<<"CreateDraft Try Update Failed"<<endl;
				continue;
			}
		}

		lstSpecSolids.push_back(spiSpecPrtTool);
	}

	
	//所有能够正确update的柱子assemble起来
	//先创建最终的prttool
	CATISpecObject_var spiSpecPrtTool=NULL_var;
	strAlias = "Hole_List";
	if (FAILED(TJMWheelHouseDraftGeneralClass::CreateNewPrtTool(_spiRootProduct,strAlias,spiSpecPrtTool))||spiSpecPrtTool==NULL_var)
	{
		cout<<"====> CreateNewPrtTool ArmrestBinFixStrc_OpenArea failed............"<<endl;
		return E_FAIL;
	}

	for (int i=0;i<lstSpecSolids.size();i++)
	{
		CATISpecObject_var spiSpecSolid = lstSpecSolids[i];
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreateBodyToAssemble(spiaPart,spShapeFactory,spiSpecPrtTool,spiSpecSolid)))
		{
			cout<<"====> CreateBodyToAssemble ArmrestBinFixStrc_OpenArea failed............"<<endl;
			return E_FAIL;
		}
	}



	return S_OK;
}

//从草图中提取独立的封闭曲线用于后续拉伸成实体
HRESULT TJMWheelHouseDraftCls::GetSeperatedCurvesFromSketch(vector<CATISpecObject_var> &olstSpecCurves)
{
	//创建工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=TJMWheelHouseDraftGeneralClass::GetProductGeoFactoryAndPrtCont(_spiRootProduct,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL || ospiCont==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPart = ospiCont->GetPart();
	if (spiSpecPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAPart_var spiaPart = spiSpecPart;
	if (spiaPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAFactory *pHybridShapeFactory=NULL;
	spiaPart->get_HybridShapeFactory(pHybridShapeFactory);
	CATIAHybridShapeFactory_var spHybridShapeFactory=pHybridShapeFactory;
	if (spHybridShapeFactory==NULL_var)
	{
		cout<<"====> get CATIAHybridShapeFactory_var failed............"<<endl;
		return E_FAIL;
	}

	
	//
	CATBody_var spBodySketch = TJMWheelHouseDraftGeneralClass::GetBodyFromFeature(_spBUSketch);
	if (spBodySketch==NULL_var)
	{
		return E_FAIL;
	}
	//获取所有的domain
	//CATLISTP(CATDomain) lstDomainCurve;
	//spBodySketch->GetAllDomains(1,1,lstDomainCurve);
	//if (lstDomainCurve.Size()==0)
	//{
	//	return E_FAIL;
	//}
	
	CATLONG32 longDomainNb = spBodySketch->GetNbDomains();
	if (longDomainNb==0)
	{
		return E_FAIL;
	}


	//特征化每个domain中的任意一个cell，后续用point连续的提取即可
	for (int i=1;i<=longDomainNb;i++)
	{
		CATDomain_var spDomain = spBodySketch->GetDomain(i);
		if (spDomain==NULL_var)
		{
			continue;
		}
		CATLISTP(CATCell) lstCell;
		spDomain->GetAllCells(lstCell,1);
		if (lstCell.Size()<1)
		{
			continue;
		}
		CATCell_var spCell = lstCell[1];
		if (spCell==NULL_var)
		{
			continue;
		}
		CATIBRepAccess_var spBRepAccess=CATBRepDecodeCellInBody( spCell, spBodySketch);  
		if (spBRepAccess==NULL_var)
		{
			cout<<"CATBRepDecodeCellInBody Failed"<<endl;
			continue;
		}

		CATISpecObject_var spFindSpec=NULL_var;
		TJMWheelHouseDraftGeneralClass::ConvertToSupportSpec(spBRepAccess, spFindSpec);
		if (spFindSpec==NULL_var)
		{
			cout<<"ConvertToSpec Failed"<<endl;
			continue;
		}

		//提取，并且使用点连续
		CATISpecObject_var spiSpecExtract=NULL_var;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreateVBExtract(spiaPart,spHybridShapeFactory,spFindSpec,NULL_var,1,spiSpecExtract))||spiSpecExtract==NULL_var)
		{
			cout<<"CreateVBExtract Failed"<<endl;
			continue;
		}

		olstSpecCurves.push_back(spiSpecExtract);

	}
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::JudgeSurfacePositiveOrNegative(CATGeoFactory *ipGeoFact,
															CATTopData *ipTopData,
															CATBaseUnknown_var ispBUSurface,
															CATMathVector iDir,
															int &oiSplitSide)
{
	//
	CATBody_var spBodySurface = TJMWheelHouseDraftGeneralClass::GetBodyFromFeature(ispBUSurface);
	if (spBodySurface==NULL_var)
	{
		return E_FAIL;
	}

	//获取面上任一二维cell的估算中心点
	CATMathPoint ptCenter;
	if (FAILED(GetCenterOfSurface(spBodySurface,ptCenter)))
	{
		cout<<"GetCenterOfSurface failed......."<<endl;
		return E_FAIL;
	}

	//把该点投影到曲面上
	CATBody_var spBodyPt = CATCreateTopPointXYZ(ipGeoFact,ipTopData,ptCenter.GetX(),ptCenter.GetY(),ptCenter.GetZ());
	if (spBodyPt==NULL_var)
	{
		return E_FAIL;
	}
	CATMathVector dirProj = iDir;
	CATBody_var spBodyProj = TJMWheelHouseDraftGeneralClass::CreateTopProject(ipGeoFact,ipTopData,spBodyPt,spBodySurface,dirProj);
	if (spBodyProj==NULL_var)
	{
		spBodyProj = TJMWheelHouseDraftGeneralClass::CreateTopProject(ipGeoFact,ipTopData,spBodyPt,spBodySurface,-1*dirProj);
		if (spBodyProj==NULL_var)
		{
			return E_FAIL;
		}
	}

	CATMathPoint ptProj;
	if (FAILED(TJMWheelHouseDraftGeneralClass::GetMathPoint(spBodyProj,ptProj)))
	{
		return E_FAIL;
	}

	//
	int iStatus = TJMWheelHouseDraftGeneralClass::GetSurfacePositiveOrNegative(ipGeoFact,ipTopData,spBodySurface,ptProj,iDir,10);
	if (iStatus==-1)
	{
		return E_FAIL;
	}

	oiSplitSide = iStatus;
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::GetCenterOfSurface( CATBody_var ispBodySurface,CATMathPoint &omathOriginalPoint )
{
	CATBoolean isMathPlane = FALSE;
	CATBody_var spBody = ispBodySurface;
	double maxAreaValue=0.0;
	if(spBody != NULL_var ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 2 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;
			CATFace_var spFace = spCell;
			if(spFace == NULL_var) 
			{
				cout<<"CATFace_var is NULL_var."<<endl;
				continue;
			}

			CATSurParam oCenterParam;
			spFace->EstimateCenterParam(oCenterParam);

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) 
			{
				cout<<"CATSurface_var is NULL_var."<<endl;
				continue;
			}

			omathOriginalPoint = spSurface->EvalPoint(oCenterParam);

			return S_OK;
		}
	}
	else  
	{
		cout<<"Get Body From Feature is failed."<<endl;
		return E_FAIL;
	}

	return S_OK;
}

//获取面的法向，需要指向实体内侧
HRESULT TJMWheelHouseDraftCls::GetNormalOfSurface(CATGeoFactory *ipGeoFact,CATTopData *ipTopData,CATBody_var ispBodySolid,CATCell_var ispCellSurface,CATMathVector &oNormalDir)
{
	//先获取面上点
	CATBody_var spBodySurface = TJMWheelHouseDraftGeneralClass::CreateBodyFromCell(ipGeoFact,ispCellSurface,2);
	if (spBodySurface==NULL_var)
	{
		return E_FAIL;
	}

	//
	//获取面上任一二维cell的估算中心点
	CATMathPoint ptCenter;
	if (FAILED(GetCenterOfSurface(spBodySurface,ptCenter)))
	{
		cout<<"GetCenterOfSurface failed......."<<endl;
		return E_FAIL;
	}

	//把该点投影到曲面上
	CATBody_var spBodyPt = CATCreateTopPointXYZ(ipGeoFact,ipTopData,ptCenter.GetX(),ptCenter.GetY(),ptCenter.GetZ());
	if (spBodyPt==NULL_var)
	{
		return E_FAIL;
	}
	CATBody_var spBodyProj = TJMWheelHouseDraftGeneralClass::CreateTopProject(ipGeoFact,ipTopData,spBodyPt,spBodySurface);
	if (spBodyProj==NULL_var)
	{
		return E_FAIL;
	}

	CATMathPoint ptProj;
	if (FAILED(TJMWheelHouseDraftGeneralClass::GetMathPoint(spBodyProj,ptProj)))
	{
		return E_FAIL;
	}

	//在该点获取曲面的法向
	//过面上的点算出垂线
	CATBody_var spBodyPointProj = ::CATCreateTopPointXYZ(ipGeoFact,ipTopData,ptProj.GetX(),ptProj.GetY(),ptProj.GetZ());
	if (spBodyPointProj==NULL_var)
	{
		return E_FAIL;
	}
	CATBody_var spBodyLineNormal = ::CATCreateTopLineNormalToShell(ipGeoFact,ipTopData,spBodyPointProj,spBodySurface,1000);
	if (spBodyLineNormal==NULL_var)
	{
		return E_FAIL;
	}

	//算出该垂线和实体有多少交点，最终方向需要指向实体内侧
	CATLISTV(CATMathPoint) lstPt;
	TJMWheelHouseDraftGeneralClass::GetMathPtFromBody(spBodyLineNormal,lstPt);
	if (lstPt.Size()!=2)
	{
		return E_FAIL;
	}
	CATMathVector dirNormal;
	double distance1 = lstPt[1].DistanceTo(ptProj);
	double distance2 = lstPt[2].DistanceTo(ptProj);
	if (distance1<distance2)
	{
		dirNormal = lstPt[2]-lstPt[1];
	}
	else
	{
		dirNormal = lstPt[1]-lstPt[2];
	}
	dirNormal.Normalize();

	CATBody_var spBodyIntersect = TJMWheelHouseDraftGeneralClass::CreateTopIntersect(ipGeoFact,ipTopData,ispBodySolid,spBodyLineNormal);
	if (spBodyIntersect!=NULL_var)
	{
		CATLISTV(CATMathPoint) lstPt;
		TJMWheelHouseDraftGeneralClass::GetMathPtFromBody(spBodyIntersect,lstPt);
		if (lstPt.Size()<2)
		{
			dirNormal = -1*dirNormal;
		}
	}

	oNormalDir = dirNormal;
	
	return S_OK;
}