// COPYRIGHT Dassault Systemes 2021
//===================================================================
//
// TJMWheelHouseDraftCls.cpp
// Header definition of TJMWheelHouseDraftCls
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Feb 2021  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TJMWheelHouseDraftCls.h"
 
CATImplementClass( TJMWheelHouseDraftCls,
                   Implementation, 
                   CATBaseUnknown,
                   CATNull );
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : constructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::TJMWheelHouseDraftCls():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : destructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::~TJMWheelHouseDraftCls()
{
}
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : copy constructor
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls::TJMWheelHouseDraftCls(TJMWheelHouseDraftCls& original):
   CATBaseUnknown(original)
{
}
 
//-----------------------------------------------------------------------------
// TJMWheelHouseDraftCls : equal operator
//-----------------------------------------------------------------------------
TJMWheelHouseDraftCls& TJMWheelHouseDraftCls::operator=(TJMWheelHouseDraftCls& original)
{
   CATBaseUnknown::operator=(original);
   return *this;
}
 
HRESULT TJMWheelHouseDraftCls::SetDatas(CATIProduct_var *iRootProduct,CATISpecObject_var *iSurface,CATBaseUnknown_var *iSketch,CATBaseUnknown_var *iToolingDir)
{
	_spiRootProduct = *iRootProduct;

	_spiSpecSurface = *iSurface;

	_spBUSketch = *iSketch;

	_spBUToolingDir = *iToolingDir;
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::ComputeResults()
{
	//获取拔模方向
	CATMathVector dirTooling;
	CATIMeasurableLine_var spiMeasurableLine = _spBUToolingDir;
	if (spiMeasurableLine==NULL_var)
	{
		return E_FAIL;
	}
	spiMeasurableLine->GetDirection(dirTooling);
	if (dirTooling.GetZ()<0)
	{
		dirTooling = -1*dirTooling;
	}
	dirTooling.Normalize();

	//获取草图平面方向
	CATISketch_var spiSketch = _spBUSketch;
	if (spiSketch==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPlane=NULL_var;
	if (FAILED(spiSketch->GetPlanarSupport(spiSpecPlane))||spiSpecPlane==NULL_var)
	{
		return E_FAIL;
	}
	CATIMeasurablePlane_var spiMeasurablePlane = spiSpecPlane;
	if (spiMeasurablePlane==NULL_var)
	{
		return E_FAIL;
	}
	CATMathPlane planeSketch;
	spiMeasurablePlane->GetPlane(planeSketch);
	CATMathVector dirSketch;
	planeSketch.GetNormal(dirSketch);
	if (dirSketch.GetZ()<0)
	{
		dirSketch = -1*dirSketch;
	}
	dirSketch.Normalize();

	//创建工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=TJMWheelHouseDraftGeneralClass::GetProductGeoFactoryAndPrtCont(_spiRootProduct,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL || ospiCont==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPart = ospiCont->GetPart();
	if (spiSpecPart==NULL_var)
	{
		return E_FAIL;
	}
	CATIGSMFactory_var spiGSMFact = ospiCont;
	CATICkeParmFactory_var spiCkeFact = ospiCont;
	CATIPrtFactory_var spiPrtFact = ospiCont;
	if (spiGSMFact==NULL_var||spiCkeFact==NULL_var||spiPrtFact==NULL_var)
	{
		return E_FAIL;
	}
	CATIAPart_var spiaPart = spiSpecPart;
	if (spiaPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAFactory *pHybridShapeFactory=NULL;
	spiaPart->get_HybridShapeFactory(pHybridShapeFactory);
	CATIAHybridShapeFactory_var spHybridShapeFactory=pHybridShapeFactory;
	if (spHybridShapeFactory==NULL_var)
	{
		cout<<"====> get CATIAHybridShapeFactory_var failed............"<<endl;
		return E_FAIL;
	}

	//判断当前曲面的方向
	CATISpecObject_var spiSpecSurfaceBase = _spiSpecSurface;
	int iSplitSide;
	if (FAILED(JudgeSurfacePositiveOrNegative(pGeoFactory,topdata,spiSpecSurfaceBase,dirTooling,iSplitSide)))
	{
		cout<<"===> JudgeSurfacePositiveOrNegative failed.........."<<endl;
		return E_FAIL;
	}
	_structFeaturesInfo.spiSpecBaseSurface = spiSpecSurfaceBase;
	_structFeaturesInfo.iSplitSideBaseSurface = iSplitSide;

	//offset当前曲面并判断方向
	//先创建几何图形集
	CATISpecObject_var spiSpecGS=NULL_var;
	CATUnicodeString strAlias = "Hole_GS";
	if (FAILED(TJMWheelHouseDraftGeneralClass::CreateNewGeoSet(_spiRootProduct,strAlias,spiSpecGS))||spiSpecGS==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecSurfaceOffset=NULL_var;
	double dOffset = 4;
	//dOffset = dOffset/1000;
	boolean bOrientation = TRUE;
	if (1==_structFeaturesInfo.iSplitSideBaseSurface)
	{
		bOrientation=FALSE;
	}
	//if (FAILED(TJMWheelHouseDraftGeneralClass::CreateGSMOffsetSurface(spiGSMFact,spiCkeFact,spiSpecSurfaceBase,spiSpecGS,dOffset,bOrientation,spiSpecSurfaceOffset))||spiSpecSurfaceOffset==NULL_var)
	//{
	//	return E_FAIL;
	//}
	if (FAILED(TJMWheelHouseDraftGeneralClass::CreateVBOffset(spiaPart,spHybridShapeFactory,spiSpecSurfaceBase,spiSpecGS,dOffset,bOrientation,spiSpecSurfaceOffset))||spiSpecSurfaceOffset==NULL_var)
	{
		cout<<"===> CreateVBOffset failed.........."<<endl;
		return E_FAIL;
	}
	if (FAILED(JudgeSurfacePositiveOrNegative(pGeoFactory,topdata,spiSpecSurfaceOffset,-1*dirTooling,iSplitSide)))
	{
		cout<<"===> JudgeSurfacePositiveOrNegative failed.........."<<endl;
		return E_FAIL;
	}
	_structFeaturesInfo.spiSpecOffsetSurface = spiSpecSurfaceOffset;
	_structFeaturesInfo.iSplitSideOffsetSurface = iSplitSide;


	//
	vector<CATISpecObject_var> lstSpecCurves;
	if (FAILED(GetSeperatedCurvesFromSketch(lstSpecCurves)))
	{
		cout<<"===> GetSeperatedCurvesFromSketch failed.........."<<endl;
		return E_FAIL;
	}

	//循环创建实体
	for (int i=0;i<lstSpecCurves.size();i++)
	{
		CATISpecObject_var spiSpecCurve = lstSpecCurves[i];
		if (spiSpecCurve==NULL_var)
		{
			continue;
		}
		//创建prttool
		CATUnicodeString strIndex;
		strIndex.BuildFromNum(i+1);
		CATUnicodeString strAlias = "Hole_"+strIndex;
		CATISpecObject_var spiSpecPrtTool=NULL_var;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreateNewPrtTool(_spiRootProduct,strAlias,spiSpecPrtTool))||spiSpecPrtTool==NULL_var)
		{
			cout<<"====> CreateNewPrtTool failed............"<<endl;
			return E_FAIL;
		}
		//创建pad
		CATISpecObject_var spiSpecPad = spiPrtFact->CreatePad(spiSpecCurve,200,200,dirSketch);
		if (spiSpecPad==NULL_var)
		{
			continue;
		}

		int trytimes=1;
		if (TJMWheelHouseDraftGeneralClass::IsObjectExistUpdateError(spiSpecPrtTool,trytimes)==TRUE)
		{
			cout<<"CreatePad Try Update Failed"<<endl;
			//return E_FAIL;
		}

		CATIGSMProceduralView_var spProceduralView =NULL_var;
		spProceduralView = spiSpecPad;
		if (NULL_var != spProceduralView )
		{
			spProceduralView->InsertInProceduralView(spiSpecPrtTool);
		}

		//用basesurface切割
		CATISpecObject_var spiSpecCuttingSurface = _structFeaturesInfo.spiSpecBaseSurface;
		int iSplitSide = _structFeaturesInfo.iSplitSideBaseSurface;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreatePrtSolidSplit(spiPrtFact,spiSpecPrtTool,spiSpecCuttingSurface,iSplitSide)))
		{
			cout<<"====> First CreatePrtSolidSplit failed............."<<endl;
			continue;
		}

		//用offset面切割
		spiSpecCuttingSurface = _structFeaturesInfo.spiSpecOffsetSurface;
		iSplitSide = _structFeaturesInfo.iSplitSideOffsetSurface;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreatePrtSolidSplit(spiPrtFact,spiSpecPrtTool,spiSpecCuttingSurface,iSplitSide)))
		{
			cout<<"====> Second CreatePrtSolidSplit failed............."<<endl;
			continue;
		}
	}
	return S_OK;
}

//从草图中提取独立的封闭曲线用于后续拉伸成实体
HRESULT TJMWheelHouseDraftCls::GetSeperatedCurvesFromSketch(vector<CATISpecObject_var> &olstSpecCurves)
{
	//创建工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=TJMWheelHouseDraftGeneralClass::GetProductGeoFactoryAndPrtCont(_spiRootProduct,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL || ospiCont==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecPart = ospiCont->GetPart();
	if (spiSpecPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAPart_var spiaPart = spiSpecPart;
	if (spiaPart==NULL_var)
	{
		return E_FAIL;
	}

	CATIAFactory *pHybridShapeFactory=NULL;
	spiaPart->get_HybridShapeFactory(pHybridShapeFactory);
	CATIAHybridShapeFactory_var spHybridShapeFactory=pHybridShapeFactory;
	if (spHybridShapeFactory==NULL_var)
	{
		cout<<"====> get CATIAHybridShapeFactory_var failed............"<<endl;
		return E_FAIL;
	}

	
	//
	CATBody_var spBodySketch = TJMWheelHouseDraftGeneralClass::GetBodyFromFeature(_spBUSketch);
	if (spBodySketch==NULL_var)
	{
		return E_FAIL;
	}
	//获取所有的domain
	//CATLISTP(CATDomain) lstDomainCurve;
	//spBodySketch->GetAllDomains(1,1,lstDomainCurve);
	//if (lstDomainCurve.Size()==0)
	//{
	//	return E_FAIL;
	//}
	
	CATLONG32 longDomainNb = spBodySketch->GetNbDomains();
	if (longDomainNb==0)
	{
		return E_FAIL;
	}


	//特征化每个domain中的任意一个cell，后续用point连续的提取即可
	for (int i=1;i<=longDomainNb;i++)
	{
		CATDomain_var spDomain = spBodySketch->GetDomain(i);
		if (spDomain==NULL_var)
		{
			continue;
		}
		CATLISTP(CATCell) lstCell;
		spDomain->GetAllCells(lstCell,1);
		if (lstCell.Size()<1)
		{
			continue;
		}
		CATCell_var spCell = lstCell[1];
		if (spCell==NULL_var)
		{
			continue;
		}
		CATIBRepAccess_var spBRepAccess=CATBRepDecodeCellInBody( spCell, spBodySketch);  
		if (spBRepAccess==NULL_var)
		{
			cout<<"CATBRepDecodeCellInBody Failed"<<endl;
			continue;
		}

		CATISpecObject_var spFindSpec=NULL_var;
		TJMWheelHouseDraftGeneralClass::ConvertToSupportSpec(spBRepAccess, spFindSpec);
		if (spFindSpec==NULL_var)
		{
			cout<<"ConvertToSpec Failed"<<endl;
			continue;
		}

		//提取，并且使用点连续
		CATISpecObject_var spiSpecExtract=NULL_var;
		if (FAILED(TJMWheelHouseDraftGeneralClass::CreateVBExtract(spiaPart,spHybridShapeFactory,spFindSpec,NULL_var,1,spiSpecExtract))||spiSpecExtract==NULL_var)
		{
			cout<<"CreateVBExtract Failed"<<endl;
			continue;
		}

		olstSpecCurves.push_back(spiSpecExtract);

	}
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::JudgeSurfacePositiveOrNegative(CATGeoFactory *ipGeoFact,
															CATTopData *ipTopData,
															CATBaseUnknown_var ispBUSurface,
															CATMathVector iDir,
															int &oiSplitSide)
{
	//
	CATBody_var spBodySurface = TJMWheelHouseDraftGeneralClass::GetBodyFromFeature(ispBUSurface);
	if (spBodySurface==NULL_var)
	{
		return E_FAIL;
	}

	//获取面上任一二维cell的估算中心点
	CATMathPoint ptCenter;
	if (FAILED(GetCenterOfSurface(spBodySurface,ptCenter)))
	{
		cout<<"GetCenterOfSurface failed......."<<endl;
		return E_FAIL;
	}

	//把该点投影到曲面上
	CATBody_var spBodyPt = CATCreateTopPointXYZ(ipGeoFact,ipTopData,ptCenter.GetX(),ptCenter.GetY(),ptCenter.GetZ());
	if (spBodyPt==NULL_var)
	{
		return E_FAIL;
	}
	CATMathVector dirProj = iDir;
	CATBody_var spBodyProj = TJMWheelHouseDraftGeneralClass::CreateTopProject(ipGeoFact,ipTopData,spBodyPt,spBodySurface,dirProj);
	if (spBodyProj==NULL_var)
	{
		spBodyProj = TJMWheelHouseDraftGeneralClass::CreateTopProject(ipGeoFact,ipTopData,spBodyPt,spBodySurface,-1*dirProj);
		if (spBodyProj==NULL_var)
		{
			return E_FAIL;
		}
	}

	CATMathPoint ptProj;
	if (FAILED(TJMWheelHouseDraftGeneralClass::GetMathPoint(spBodyProj,ptProj)))
	{
		return E_FAIL;
	}

	//
	int iStatus = TJMWheelHouseDraftGeneralClass::GetSurfacePositiveOrNegative(ipGeoFact,ipTopData,spBodySurface,ptProj,iDir,10);
	if (iStatus==-1)
	{
		return E_FAIL;
	}

	oiSplitSide = iStatus;
	
	return S_OK;
}

HRESULT TJMWheelHouseDraftCls::GetCenterOfSurface( CATBody_var ispBodySurface,CATMathPoint &omathOriginalPoint )
{
	CATBoolean isMathPlane = FALSE;
	CATBody_var spBody = ispBodySurface;
	double maxAreaValue=0.0;
	if(spBody != NULL_var ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 2 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;
			CATFace_var spFace = spCell;
			if(spFace == NULL_var) 
			{
				cout<<"CATFace_var is NULL_var."<<endl;
				continue;
			}

			CATSurParam oCenterParam;
			spFace->EstimateCenterParam(oCenterParam);

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) 
			{
				cout<<"CATSurface_var is NULL_var."<<endl;
				continue;
			}

			omathOriginalPoint = spSurface->EvalPoint(oCenterParam);

			return S_OK;
		}
	}
	else  
	{
		cout<<"Get Body From Feature is failed."<<endl;
		return E_FAIL;
	}

	return S_OK;
}