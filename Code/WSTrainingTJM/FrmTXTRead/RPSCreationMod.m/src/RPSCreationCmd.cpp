// COPYRIGHT Dassault Systemes 2018
//===================================================================
//
// RPSCreationCmd.cpp
// The state chart based command: RPSCreationCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Dec 2018  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "RPSCreationCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( RPSCreationCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
RPSCreationCmd::RPSCreationCmd() :
  CATStateCommand ("RPSCreationCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,_Indication(NULL)
{
	_pDlg = NULL;
	_pDlg = new RPSCreationDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
RPSCreationCmd::~RPSCreationCmd()
{
   if (_Indication != NULL) 
      _Indication->RequestDelayedDestruction();

   if (_pDlg != NULL)
   {
	   _pDlg->RequestDelayedDestruction();
	   _pDlg = NULL;
   }
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void RPSCreationCmd::BuildGraph()
{
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&RPSCreationCmd::ExitCmd,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&RPSCreationCmd::ExitCmd,
		NULL);

	AddAnalyseNotificationCB(_pDlg->GetPushButtonRPSList(),
		_pDlg->GetPushButtonRPSList()->GetPushBActivateNotification(),
		(CATCommandMethod)&RPSCreationCmd::ShowRPSList,
		NULL);
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean RPSCreationCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}


void RPSCreationCmd::ExitCmd()
{
	this->RequestDelayedDestruction();
}

void RPSCreationCmd::ShowRPSList()
{
	//获取Root Product
	CATIProduct *piProductOnRoot = NULL;
	HRESULT rc = GetRootProduct(piProductOnRoot);
	if (FAILED(rc))
	{
		return;
	}
	//获得所有Children
	CATListValCATBaseUnknown_var *lstChildren = piProductOnRoot->GetAllChildren();
	if (lstChildren == NULL)
	{
		return;
	}
	//过滤出Part
	CATIProduct_var spChild = NULL_var;
	CATLISTP(CATIProduct) lstRefProduct = NULL;
	for (int i = 1; i <= lstChildren->Size(); i++)
	{
		spChild = (*lstChildren)[i];
		if (IsProduct(spChild))
		{	
			continue;
		}
		CATIProduct_var spRefProduct = spChild->GetReferenceProduct(); 
		lstRefProduct.Append(spRefProduct);
	}
	//过滤重复Part
	for (int i = 1; i<=lstRefProduct.Size(); i++)
	{
		for (int j = lstRefProduct.Size(); j>i; j--)
		{
			if (lstRefProduct[i] == lstRefProduct[j])
			{
				lstRefProduct.RemovePosition(j);
			}
		}
	}
	//打印出过滤出的Part的零件号以及总数量
	for (int i = 1; i<= lstRefProduct.Size(); i++)
	{
		cout<<lstRefProduct[i]->GetPartNumber()<<endl;
	}
	cout<<lstRefProduct.Size()<<endl;

	//遍历Part内的几何图形集
	for (int i = 1; i<= lstRefProduct.Size(); i++)
	{
		CATILinkableObject *piLinkableObjOnChild = NULL;
		HRESULT rc = lstRefProduct[i]->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObjOnChild);
		if (FAILED(rc))
		{
			continue;
		}
		CATDocument *pDocOnChild = NULL;
		pDocOnChild = piLinkableObjOnChild->GetDocument();
		if (NULL == pDocOnChild)
		{
			continue;
		}
		CATIContainerOfDocument_var spContOfDocOnChild = pDocOnChild;
		CATIContainer *piSpecContainerOnChild = NULL;
		rc = spContOfDocOnChild->GetSpecContainer(piSpecContainerOnChild);
		if (FAILED(rc))
		{
			continue;
		}
		CATIPrtContainer *piPrtContainerOnChild = NULL;
		rc = piSpecContainerOnChild->QueryInterface(IID_CATIPrtContainer,(void**)&piPrtContainerOnChild);
		piSpecContainerOnChild->Release();
		if (FAILED(rc))
		{
			continue;
		}
		CATIPrtPart_var spPartOnChild = piPrtContainerOnChild->GetPart();
		piPrtContainerOnChild->Release();
		if (NULL_var == spPartOnChild)
		{
			continue;
		}
		CATIDescendants *pDescendantsOnChild = NULL;
		rc = spPartOnChild->QueryInterface(IID_CATIDescendants,(void**)&pDescendantsOnChild);
		if (FAILED(rc))
		{
			continue;
		}
		CATLISTV(CATISpecObject_var) lstGeomSetList;
		pDescendantsOnChild->GetAllChildren("CATIMmiNonOrderedGeometricalSet",lstGeomSetList);
		pDescendantsOnChild->Release();
		pDescendantsOnChild = NULL;

		CATBoolean existRPS = FALSE;
		cout<<"GS numbers:  "<<lstGeomSetList.Size()<<endl;
		for (int j = 1; j<= lstGeomSetList.Size(); j++)
		{
			CATIAlias_var spiAliasOnGS = lstGeomSetList[j];
			CATUnicodeString strGSName = spiAliasOnGS->GetAlias();
			if (strGSName == "RPS")
			{
				cout<<lstRefProduct[i]->GetPartNumber()<<"  has RPS GS"<<endl;
				existRPS = TRUE;
				break;
			}
		}
		if (existRPS == FALSE)
		{
			cout<<lstRefProduct[i]->GetPartNumber()<<"  has no RPS"<<endl;
		}
	}


	return;
}

HRESULT RPSCreationCmd::GetRootProduct(CATIProduct *&opiRootProduct)
{
	//获取Document
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	if (pEditor == NULL)
	{
		return E_FAIL;
	}
	CATDocument *pDoc = pEditor->GetDocument();
	if (pDoc == NULL)
	{
		return E_FAIL;
	}

	//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDoc->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
	CATIProduct_var spRootProduct = NULL_var;
	if (pRootProducts->Size())
	{
		spRootProduct = (*pRootProducts)[1];
		delete pRootProducts;
		pRootProducts = NULL;
	}

	piDocRootsOnDoc->Release();

	//CATIProduct *piProductOnRoot = NULL;
	rc = spRootProduct->QueryInterface(IID_CATIProduct, (void**)&opiRootProduct);
	if (FAILED(rc) || piDocRootsOnDoc == NULL)
	{
		return E_FAIL;
	}

	return S_OK;
}

void RPSCreationCmd::GetAllSubParts(CATIProduct *ipiRootProduct, CATListPtrCATIProduct *&lstSubParts)
{
	CATListValCATBaseUnknown_var *lstChildren = ipiRootProduct->GetAllChildren();
	if (lstChildren == NULL)
	{
		return;
	}

	CATIProduct_var spChild = NULL_var;
	lstSubParts = NULL;

	for (int i = 1; i <= lstChildren->Size(); i++)
	{
		spChild = (*lstChildren)[i];
		if (FALSE == IsProduct(spChild))
		{
			CATIProduct_var spRefProduct = spChild->GetReferenceProduct(); 
			CATIProduct *piRefProductOnChild = NULL;
			HRESULT rc = spRefProduct->QueryInterface(IID_CATIProduct, (void**)&piRefProductOnChild);
			lstSubParts->Append(piRefProductOnChild);
		}
	}
	return;
}

//判断是否为PRD check if is a product
CATBoolean RPSCreationCmd::IsProduct(CATIProduct_var ispiPrd)
{
	HRESULT rc = S_OK;

	CATBoolean isProduct=FALSE;

	CATIProduct *piPrd=NULL;
	rc = ispiPrd->QueryInterface(IID_CATIProduct,(void **)&piPrd);

	CATIProduct_var spRefPrd=ispiPrd->GetReferenceProduct();
	piPrd->Release();  piPrd = NULL;

	if (spRefPrd==NULL_var)
	{
		isProduct = TRUE;
		cout<<"==>Get ReferenceProduct failed"<<endl;
		return isProduct;
	}

	CATILinkableObject *piLinkObj=NULL;
	rc=spRefPrd->QueryInterface(IID_CATILinkableObject,(void **)&piLinkObj);
	if( FAILED(rc) || !piLinkObj ) 
	{
		cout << "==> Get CATILinkableObject error !" << endl;
		return isProduct;
	}

	CATDocument *pDoc=piLinkObj->GetDocument();
	piLinkObj->Release();  piLinkObj = NULL;
	if( !pDoc ) 
	{
		cout << "==> Get CATDocument error !" << endl;
		return isProduct;
	}

	CATIDocId *pDocID;
	CATUnicodeString typeDoc="";
	rc = pDoc->GetDocId(&pDocID);
	if( !(FAILED(rc)) )
		rc = pDocID->GetType(typeDoc);
	//cout << " ==> The type of document is: " << typeDoc << endl;

	if( typeDoc == "CATProduct" )
		isProduct = TRUE;

	return isProduct;
}