// COPYRIGHT Dassault Systemes 2020
//===================================================================
//
// TestEnvelopeCmd.cpp
// The state chart based command: TestEnvelopeCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  May 2020  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestEnvelopeCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( TestEnvelopeCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestEnvelopeCmd::TestEnvelopeCmd() :
  CATStateCommand ("TestEnvelopeCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
,_pGeneralCls(NULL)
,_pEditor(NULL)
,_pHSO(NULL)
,_pISO(NULL)
{
	_pDlg = NULL;
	_pDlg = new TestEnvelopeDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

	_pSelAAgent = NULL;
	_pSelBAgent = NULL;
	_pSelAFieldAgent = NULL;
	_pSelBFieldAgent = NULL;

	_pGeneralCls = new GeneralClass();

	_pEditor = CATFrmEditor::GetCurrentEditor();

	if (NULL!=_pEditor)
	{
		_pHSO = _pEditor->GetHSO();
		_pISO = _pEditor->GetISO();
	}

	_dMotionStep=0.8;

	_dTessellateStep=2;

	_dRadiusRolling=1.6;

	//vector<CATMathPoint> lstPt;
	//vector<vector<CATMathPoint>> vecLstPtH(3000,lstPt);
	//vector<vector<vector<CATMathPoint>>> vecLstPtAll(3000,vecLstPtH);

	//int iSize = _mapXY[1][1].size();

	//_mapXY[1][1].push_back(CATMathPoint(0,0,1));
	//_mapXY[100][6].push_back(CATMathPoint(222,0,1));
	//_mapXY[50][1].push_back(CATMathPoint(50,0,1));
	//_mapXY[1][50].push_back(CATMathPoint(0,5555,1));
	//_mapXY[1][20].push_back(CATMathPoint(0,22222,1));

	//int iA=(int)1.5;	//1

	//int iB=(int)(-1.5);	//-1


	cout<<"---------------"<<endl;
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestEnvelopeCmd::~TestEnvelopeCmd()
{
	if (_pDlg != NULL)
	{
		_pDlg->RequestDelayedDestruction();
		_pDlg = NULL;
	}

	if (_pGeneralCls != NULL)
	{
		delete _pGeneralCls;
		_pGeneralCls = NULL;
	}

	_pEditor = NULL;

	_pHSO->Empty();
	_pHSO = NULL;

	_pISO->Empty();
	_pISO = NULL;

	if (_pSelAAgent != NULL)
	{
		_pSelAAgent->RequestDelayedDestruction();
		_pSelAAgent = NULL;
	}

	if (_pSelAFieldAgent != NULL)
	{
		_pSelAFieldAgent->RequestDelayedDestruction();
		_pSelAFieldAgent = NULL;
	}

	if (_pSelBAgent != NULL)
	{
		_pSelBAgent->RequestDelayedDestruction();
		_pSelBAgent = NULL;
	}

	if (_pSelBFieldAgent != NULL)
	{
		_pSelBFieldAgent->RequestDelayedDestruction();
		_pSelBFieldAgent = NULL;
	}
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestEnvelopeCmd::BuildGraph()
{
	//对话框
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	//Translate
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionOK7,
		NULL);

	//Rotate
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaAPPLYNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionOK3,
		NULL);
	//
	_pSelAFieldAgent = new CATDialogAgent("Select A");
	_pSelAFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjA(),
		_pDlg->GetSelectorListObjA()->GetListSelectNotification());
	//
	_pSelBFieldAgent = new CATDialogAgent("Select B");
	_pSelBFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjB(),
		_pDlg->GetSelectorListObjB()->GetListSelectNotification());
	//选择Point
	_pSelAAgent = new CATFeatureImportAgent("Select A");
	//_pPointAgent->AddElementType("CATIGSMPoint");
	_pSelAAgent->AddElementType("CATIMechanicalTool");
	_pSelAAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//选择Solid
	//_pSelBAgent = new CATFeatureImportAgent("Select B");
	_pSelBAgent = new CATPathElementAgent("Select B");
	//_pSelBAgent->AddElementType("CATRep");
	//_pSelBAgent->AddElementType("CATIMfMonoDimResult");
	//_pSolidAgent->AddElementType("CATSurface");
	//_pSolidAgent->AddElementType("CATIMechanicalTool");
	//_pSolidAgent->AddElementType("CATIMfBiDimResult");
	_pSelBAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//
	CATDialogState *pSelAState = GetInitialState("Select A");
	pSelAState->AddDialogAgent(_pSelAAgent);
	pSelAState->AddDialogAgent(_pSelAFieldAgent);
	pSelAState->AddDialogAgent(_pSelBFieldAgent);

	CATDialogState *pSelBState = AddDialogState("Select B");
	pSelBState->AddDialogAgent(_pSelBAgent);
	pSelBState->AddDialogAgent(_pSelAFieldAgent);
	pSelBState->AddDialogAgent(_pSelBFieldAgent);

	//
	AddTransition(pSelAState,pSelAState,
		IsOutputSetCondition(_pSelAAgent),
		Action((ActionMethod)& TestEnvelopeCmd::selectObjAFunc));

	AddTransition(pSelBState,pSelBState,
		IsOutputSetCondition(_pSelBAgent),
		Action((ActionMethod)& TestEnvelopeCmd::selectObjBFunc));

	AddTransition(pSelAState,pSelBState,
		IsOutputSetCondition(_pSelBFieldAgent),
		Action((ActionMethod)& TestEnvelopeCmd::TransToSelectB));

	AddTransition(pSelBState,pSelAState,
		IsOutputSetCondition(_pSelAFieldAgent),
		Action((ActionMethod)& TestEnvelopeCmd::TransToSelectA));
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestEnvelopeCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}
CATBoolean TestEnvelopeCmd::ActionExit(void * data)
{
	RequestDelayedDestruction();
	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK(void * data)
{
	/*
	HRESULT rc=this->CreateEnvelope(_spBUSelectA,_spBUSelectB);
	if (FAILED(rc))
	{
		return FALSE;
	}
	*/

	HRESULT rc=this->TestCgr();

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK2(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();
	
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}

	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	CATMathLine mathAxis(pt1,pt2);

	vector<CATMathPoint> lstVerticesAll;
	rc = this->CreateRotationTransformation(lstVertices,30,mathAxis,0.5,lstVerticesAll);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesAll Size: "<<lstVerticesAll.size()<<endl;

	//
	vector<CATMathPoint> lstVerticesOuter;
	rc=this->CalculateOuterPoints(lstVerticesAll,1);
	if (FAILED(rc))
	{
		return FALSE;
	}
	lstVerticesOuter.swap(lstVerticesAll);
	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	//
	//模型上画出虚拟点，CATISO高亮
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		DumITempPoint *piTempPoint = NULL;
		HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
		if (SUCCEEDED(rc) && piTempPoint != NULL)
		{
			piTempPoint->SetDatas(&mathPt);
			_pISO->AddElement(piTempPoint);
		}
	}

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK3(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}
	cout<<"lstVertices Size: "<<lstVertices.size()<<endl;

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"TestOG",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVertices.size();i++)
	{
		CATMathPoint mathPt=lstVertices[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	this->CalculateOuterPoints(lstVertices,0.5);
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"TestOGFilter",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	for (int i=0;i<lstVertices.size();i++)
	{
		CATMathPoint mathPt=lstVertices[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	/*
	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	CATMathLine mathAxis(pt1,pt2);

	vector<CATMathPoint> lstVerticesOuter;
	rc = this->CreateRotationTransformationUpdate(lstVertices,30,mathAxis,0.5,lstVerticesOuter);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	////模型上画出虚拟点，CATISO高亮
	//for (int i=0;i<lstVerticesOuter.size();i++)
	//{
	//	CATMathPoint mathPt=lstVerticesOuter[i];
	//	DumITempPoint *piTempPoint = NULL;
	//	HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
	//	if (SUCCEEDED(rc) && piTempPoint != NULL)
	//	{
	//		piTempPoint->SetDatas(&mathPt);
	//		_pISO->AddElement(piTempPoint);
	//	}
	//}

	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Rotate Calculate Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	*/

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK4(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}
	cout<<"lstVertices Size: "<<lstVertices.size()<<endl;

	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	//CATMathLine mathAxis(pt1,pt2);
	CATMathVector mathDir=pt1-pt2;

	vector<CATMathPoint> lstVerticesOuter;
	rc = this->CreateTranslateTransformation(lstVertices,30,mathDir,0.5,lstVerticesOuter);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	////模型上画出虚拟点，CATISO高亮
	//for (int i=0;i<lstVerticesOuter.size();i++)
	//{
	//	CATMathPoint mathPt=lstVerticesOuter[i];
	//	DumITempPoint *piTempPoint = NULL;
	//	HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
	//	if (SUCCEEDED(rc) && piTempPoint != NULL)
	//	{
	//		piTempPoint->SetDatas(&mathPt);
	//		_pISO->AddElement(piTempPoint);
	//	}
	//}

	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Translate Calculation Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	return TRUE;
}
//Translate
CATBoolean TestEnvelopeCmd::ActionOK5(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();
	
	//根据选择实体算出包围盒
	CATBody_var spBody=_pGeneralCls->GetBodyFromFeature(_spBUSelectA);
	if (spBody==NULL_var)
	{
		return FALSE;
	}
	CATMathBox mathBox;
	_pGeneralCls->GetBodyBox(spBody,_spiProdSelA,mathBox);
	double oXMin,oXMax,oYMin,oYMax,oZMin,oZMax;
	mathBox.GetExtremities(oXMin,oXMax,oYMin,oYMax,oZMin,oZMax);
	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	
	CATMathVector mathDir=pt1-pt2;
	//
	CATBody *pBodyAssy=NULL;
	CreateTranslateTransformation(spBody,_spiProdSelA,30,mathDir,0.8,pBodyAssy);
	if (pBodyAssy==NULL)
	{
		return FALSE;
	}
	
	//
	//先XY方向切面
	double iStep=0.5;
	int iNumRepeatX=(oXMax-oXMin)/iStep;
	int iNumRepeatY=(oYMax-oYMin)/iStep;
	int iNumRepeatZ=(oZMax-oZMin)/iStep;

	double iStepX=(oXMax-oXMin)/iNumRepeatX;
	double iStepY=(oYMax-oYMin)/iNumRepeatY;
	double iStepZ=(oZMax-oZMin)/iNumRepeatZ;

	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}

	vector<vector<CATMathPoint>> lstPtConcaveHull;
	for (int i=0;i<=iNumRepeatZ;i++)
	{
		CATMathPoint pt(0,0,oZMin+i*iStep);
		CATMathVector dir(0,0,1);
		CATMathPlane planeIntersect(pt,dir);
		CATBody_var spBodyPlane=NULL_var;
		if (CreatePlaneBody(pGeoFactory,topdata,planeIntersect,spBodyPlane)&&spBodyPlane!=NULL_var)
		{
			CATBody *pBodyResult=CreateTopIntersect(pGeoFactory,topdata,pBodyAssy,spBodyPlane);

			if (pBodyResult!=NULL)
			{
				vector<CATMathPoint> lstPt;
				if (SUCCEEDED(CreateEdgeTessellation(pBodyResult,lstPt))&&lstPt.size()>0)
				{
					vector<CATMathPoint> lstPtOuter;
					CalculateOuterHull(lstPt,1.6,"XY",lstPtOuter);
					lstPtConcaveHull.push_back(lstPtOuter);
				}
			}
			//////////////////////////////////////////////////////////////////////////
			//相交结果挂模型树
			CATUnicodeString strIndex;
			strIndex.BuildFromNum(i);
			CATUnicodeString strGeoSetName="TestIntersect_"+strIndex;
			CATISpecObject_var spiGeoSet=NULL_var;
			HRESULT rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,strGeoSetName,spiGeoSet);
			if (FAILED(rc)||spiGeoSet==NULL_var)
			{
				continue;;
			}

			CATISpecObject_var spiSpecObj=NULL_var;
			_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"Curve",pBodyResult,spiSpecObj);

			spiGeoSet->Update();
		}
	}
	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Translate Calculation Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//挂模型树 
	for (int i=0;i<lstPtConcaveHull.size();i++)
	{
		vector<CATMathPoint> lstPtCurrentLayer=lstPtConcaveHull[i];
		for (int j=0;j<lstPtCurrentLayer.size();j++)
		{
			CATUnicodeString strIndex;
			strIndex.BuildFromNum(i);
			CATUnicodeString strGeoSetName="Test_"+strIndex;
			CATISpecObject_var spiGeoSet=NULL_var;
			HRESULT rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,strGeoSetName,spiGeoSet);
			if (FAILED(rc)||spiGeoSet==NULL_var)
			{
				return FALSE;
			}
			
			CATMathPoint ptCurrent = lstPtCurrentLayer[j];
			int iNext = (j+1)%lstPtCurrentLayer.size();	//封闭图形的序号取法，当i是最后的的时候，下一位是回到第一位
			CATMathPoint ptNext = lstPtCurrentLayer[iNext];

			CATBody *pBodyPtCurrent =::CATCreateTopPointXYZ( pGeoFactory,topdata,ptCurrent.GetX(),ptCurrent.GetY(),ptCurrent.GetZ());
			CATBody *pBodyPtNext =::CATCreateTopPointXYZ( pGeoFactory,topdata,ptNext.GetX(),ptNext.GetY(),ptNext.GetZ());
			if (pBodyPtCurrent==NULL||pBodyPtNext==NULL)
			{
				continue;
			}
			CATBody *pBodyLine=::CATCreateTopLineFromPoints(pGeoFactory,topdata,pBodyPtCurrent,pBodyPtNext);
			if (pBodyLine==NULL)
			{
				continue;
			}

			CATISpecObject_var spiSpecObj=NULL_var;
			_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"Line",pBodyLine,spiSpecObj);

			spiGeoSet->Update();
		}
	}

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	
	return TRUE;
}

//Translate Optimize
CATBoolean TestEnvelopeCmd::ActionOK6(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();

	//根据选择实体算出包围盒
	CATBody_var spBody=_pGeneralCls->GetBodyFromFeature(_spBUSelectA);
	if (spBody==NULL_var)
	{
		return FALSE;
	}
	CATMathBox mathBox;
	_pGeneralCls->GetBodyBox(spBody,_spiProdSelA,mathBox);
	double oXMin,oXMax,oYMin,oYMax,oZMin,oZMax;
	mathBox.GetExtremities(oXMin,oXMax,oYMin,oYMax,oZMin,oZMax);
	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}

	CATMathVector mathDir=pt1-pt2;
	//

	//
	//先XY方向切面
	double iStep=0.5;
	int iNumRepeatX=(oXMax-oXMin)/iStep;
	int iNumRepeatY=(oYMax-oYMin)/iStep;
	int iNumRepeatZ=(oZMax-oZMin)/iStep;

	double iStepX=(oXMax-oXMin)/iNumRepeatX;
	double iStepY=(oYMax-oYMin)/iNumRepeatY;
	double iStepZ=(oZMax-oZMin)/iNumRepeatZ;

	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}

	vector<vector<CATMathPoint>> lstPtConcaveHull;
	for (int i=0;i<=iNumRepeatZ;i++)
	{
		CATMathPoint pt(0,0,oZMin+i*iStep);
		CATMathVector dir(0,0,1);
		CATMathPlane planeIntersect(pt,dir);
		CATBody_var spBodyPlane=NULL_var;
		if (CreatePlaneBody(pGeoFactory,topdata,planeIntersect,spBodyPlane)&&spBodyPlane!=NULL_var)
		{
			CATBody *pBodyResult=CreateTopIntersect(pGeoFactory,topdata,spBody,spBodyPlane);

			if (pBodyResult!=NULL)
			{
				//根据domain重新构建body

				CATLISTP(CATDomain) lstDomainCurve;
				pBodyResult->GetAllDomains(1,2,lstDomainCurve);
				if (lstDomainCurve.Size()==0)
				{
					continue;
				}
				//对每个domain单独进行translate 和 ConcaveHull构建
				for (int j=1;j<=lstDomainCurve.Size();j++)
				{
					CATDomain *pDomain=lstDomainCurve[j];
					if (pDomain==NULL)
					{
						continue;
					}
					CATBody *pBodyDomain=this->CreateBodyFromDomain(pGeoFactory,pDomain,1);
					if (pBodyDomain==NULL)
					{
						continue;
					}

					CATBody *pBodyAssy=NULL;
					CreateTranslateTransformationUpdate(pBodyResult,_spiProdSelA,30,mathDir,_dMotionStep,pBodyAssy);
					if (pBodyAssy==NULL)
					{
						return FALSE;
					}

					vector<CATMathPoint> lstPt;
					if (SUCCEEDED(CreateEdgeTessellation(pBodyAssy,lstPt))&&lstPt.size()>0)
					{
						vector<CATMathPoint> lstPtOuter;
						CalculateOuterHull(lstPt,_dRadiusRolling,"XY",lstPtOuter);
						lstPtConcaveHull.push_back(lstPtOuter);
					}

				}

			}
			//////////////////////////////////////////////////////////////////////////
			//相交结果挂模型树
			CATUnicodeString strIndex;
			strIndex.BuildFromNum(i);
			CATUnicodeString strGeoSetName="TestIntersect_"+strIndex;
			CATISpecObject_var spiGeoSet=NULL_var;
			HRESULT rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,strGeoSetName,spiGeoSet);
			if (FAILED(rc)||spiGeoSet==NULL_var)
			{
				continue;;
			}

			CATISpecObject_var spiSpecObj=NULL_var;
			_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"Curve",pBodyResult,spiSpecObj);

			spiGeoSet->Update();
		}
	}
	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Translate Calculation Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//挂模型树 
	for (int i=0;i<lstPtConcaveHull.size();i++)
	{
		vector<CATMathPoint> lstPtCurrentLayer=lstPtConcaveHull[i];
		for (int j=0;j<lstPtCurrentLayer.size();j++)
		{
			CATUnicodeString strIndex;
			strIndex.BuildFromNum(i);
			CATUnicodeString strGeoSetName="Test_"+strIndex;
			CATISpecObject_var spiGeoSet=NULL_var;
			HRESULT rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,strGeoSetName,spiGeoSet);
			if (FAILED(rc)||spiGeoSet==NULL_var)
			{
				return FALSE;
			}

			CATMathPoint ptCurrent = lstPtCurrentLayer[j];
			int iNext = (j+1)%lstPtCurrentLayer.size();	//封闭图形的序号取法，当i是最后的的时候，下一位是回到第一位
			CATMathPoint ptNext = lstPtCurrentLayer[iNext];

			CATBody *pBodyPtCurrent =::CATCreateTopPointXYZ( pGeoFactory,topdata,ptCurrent.GetX(),ptCurrent.GetY(),ptCurrent.GetZ());
			CATBody *pBodyPtNext =::CATCreateTopPointXYZ( pGeoFactory,topdata,ptNext.GetX(),ptNext.GetY(),ptNext.GetZ());
			if (pBodyPtCurrent==NULL||pBodyPtNext==NULL)
			{
				continue;
			}
			CATBody *pBodyLine=::CATCreateTopLineFromPoints(pGeoFactory,topdata,pBodyPtCurrent,pBodyPtNext);
			if (pBodyLine==NULL)
			{
				continue;
			}

			CATISpecObject_var spiSpecObj=NULL_var;
			_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"Line",pBodyLine,spiSpecObj);

			spiGeoSet->Update();
		}
	}

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");


	return TRUE;
}
//Translate Optimize Point Cloud
CATBoolean TestEnvelopeCmd::ActionOK7(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();

	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	CATMathVector mathDir=pt1-pt2;

	//
	CreateSurfaceTessellation(_spBUSelectA,_mapXY,_mapXZ,_mapYZ);

	//
	CreateTranslateTransformation(30,mathDir,1,_mapXY,2);
	CreateTranslateTransformation(30,mathDir,1,_mapXZ,1);
	CreateTranslateTransformation(30,mathDir,1,_mapYZ,0);


	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Translate Calculation Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;

	/*
	//模型上画出虚拟点，CATISO高亮
	DrawTempPoints(_mapXY);
	DrawTempPoints(_mapXZ);
	DrawTempPoints(_mapYZ);

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> TempPoint Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;
	*/

	/*
	//
	CATUnicodeString strSavePath="c:\\envelop.cgr";
	HRESULT rc = PointsSaveAsCgr(_mapXY,_mapXZ,_mapYZ,strSavePath);

	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"=====>>> Save as Cgr finished!................."<<endl;
	*/
	
	//点坐标写入txt中
	CATUnicodeString strTxtPath="c:\\Temp\\points.txt";
	PointsOutputTxt(_mapXY,strTxtPath);
	PointsOutputTxt(_mapXZ,strTxtPath);
	PointsOutputTxt(_mapYZ,strTxtPath);

	cout<<"OutputTxt Finished!..........."<<endl;

	return TRUE;
}

void TestEnvelopeCmd::selectObjAFunc(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	_pGeneralCls->TransferSelectToBU(_pSelAAgent,pBUSelect,spiProdSelect);
	if (pBUSelect == NULL || spiProdSelect == NULL_var)
	{
		_pSelAAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjA()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjA()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjA()->SetSelect(&iTabRow,1);
	//
	_spBUSelectA = pBUSelect;
	_spiProdSelA = spiProdSelect;

	_pGeneralCls->SetHighlight(pBUSelect);
	//
	_pSelAAgent->InitializeAcquisition();
}

void TestEnvelopeCmd::selectObjBFunc(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	//_pGeneralCls->TransferSelectToBU(_pSelBAgent,pBUSelect,spiProdSelect);

	pBUSelect = _pSelBAgent->GetElementValue();
	if (pBUSelect == NULL /*|| spiProdSelect == NULL_var*/)
	{
		_pSelBAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjB()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjB()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjB()->SetSelect(&iTabRow,1);

	//
	_spBUSelectB = pBUSelect;
	_spiProdSelB = spiProdSelect;

	_pGeneralCls->SetHighlight(pBUSelect);
	//
	_pSelBAgent->InitializeAcquisition();
}

void TestEnvelopeCmd::TransToSelectA(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjB()->ClearSelect();
}

void TestEnvelopeCmd::TransToSelectB(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjA()->ClearSelect();
}

HRESULT TestEnvelopeCmd::CreateEnvelope(CATBaseUnknown_var ispBUObj,CATBaseUnknown_var ispBUCurve)
{
	HRESULT rc=S_OK;
	//
	if (ispBUObj==NULL_var||ispBUCurve==NULL_var)
	{
		return E_FAIL;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	//
	CATBody_var spBodyOrigin = _pGeneralCls->GetBodyFromFeature(ispBUObj);
	if (spBodyOrigin==NULL_var)
	{
		return E_FAIL;
	}
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(ispBUCurve,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return E_FAIL;
	}
	CATMathLine mathAxis(pt1,pt2);

	//包络实体
	CATBody_var spBodyAssy=spBodyOrigin;
	for (int i=1;i<=10;i++)
	{
		//旋转
		CATDynTransformation *pDynTranf = CATCreateDynTransformation(pGeoFactory,topdata,spBodyOrigin);
		if (pDynTranf==NULL)
		{
			continue;
		}
		CATAngle angleRotate = i*CATPI/9;
		pDynTranf->SetRotation(angleRotate,mathAxis);
		CATTry
		{
			pDynTranf->Run();
		}
		CATCatch(CATMfErrUpdate , pUpdateError)
		{
			continue;
		}
		CATCatch(CATError , error)
		{
			delete pDynTranf;
			pDynTranf = NULL;
			CATReturnError(error);
			continue;
		}
		CATEndTry;

		CATBody *pBodyTransfResult = pDynTranf->GetResult();
		delete pDynTranf;
		pDynTranf = NULL;
		if (pBodyTransfResult == NULL)
		{
			continue;
		}
		
		//布尔合并
		CATDynBoolean *pDynBool=CATCreateDynBoolean(pGeoFactory,topdata,CATBoolUnion,spBodyAssy,pBodyTransfResult);
		if (pDynBool==NULL)
		{
			continue;
		}
		CATTry
		{
			pDynBool->Run();
		}
		CATCatch(CATMfErrUpdate , pUpdateError)
		{
			continue;
		}
		CATCatch(CATError , error)
		{
			delete pDynBool;
			pDynBool = NULL;
			CATReturnError(error);
			continue;
		}
		CATEndTry;

		CATBody *pBodyResult = pDynBool->GetResult();
		delete pDynBool;
		pDynBool = NULL;
		if (pBodyResult == NULL)
		{
			continue;
		}
		spBodyAssy=pBodyResult;
	}

	//
	CATLISTP(CATCell) lstCells;
	spBodyAssy->GetAllCells(lstCells,2);
	CATLISTP(CATBody) lstBody;
	for (int i=1;i<=lstCells.Size();i++)
	{
		CATCell_var spCell=lstCells[i];
		if (spCell==NULL_var)
		{
			continue;
		}
		CATBody *pBodyCell=NULL;
		pBodyCell=_pGeneralCls->CreateBodyFromCell(pGeoFactory,spCell,2);
		if (pBodyCell!=NULL)
		{
			lstBody.Append(pBodyCell);
		}
	}

	if (lstBody.Size()>0)
	{
		//把这些body组合起来
		ListPOfCATBody * HListOfCurve=&lstBody;
		CATHybAssemble * pHybAssemble=CATCreateTopAssemble(pGeoFactory, topdata, HListOfCurve);
		if (pHybAssemble==NULL)
		{
			return FALSE;
		}
		//
		pHybAssemble->Run();
		CATBody*pResultBody= pHybAssemble->GetResult();
		delete pHybAssemble; 
		pHybAssemble = NULL;

		if (pResultBody==NULL)
		{
			return E_FAIL;
		}

		//挂模型树
		CATISpecObject_var spiSpecGeoSet=NULL_var;
		rc = _pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test_Envelope",spiSpecGeoSet);
		if (FAILED(rc)||spiSpecGeoSet==NULL_var)
		{
			return E_FAIL;
		}
		CATISpecObject_var spiSpecEnvelope=NULL_var;
		rc=_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiSpecGeoSet,"Envelope",pResultBody,spiSpecEnvelope);
		if (FAILED(rc)||spiSpecEnvelope==NULL_var)
		{
			return E_FAIL;
		}
		spiSpecEnvelope->Update();
	}
	

	return rc;
}

HRESULT TestEnvelopeCmd::TestCgr()
{
	HRESULT rc=S_OK;

	//
	//CATRep *pRep=NULL;
	//CATFrmEditor *pEditor=CATFrmEditor::GetCurrentEditor();
	//CATRepPath repPath;
	//rc=this->GetRepFromBU(_spBUSelectB,pEditor,&pRep,repPath);
	//if (FAILED(rc))
	//{
	//	return E_FAIL;
	//}

	//
	/*
	CATI3DGeoVisu_var spGeoVis = _spBUSelectB;
	if (spGeoVis==NULL_var)
	{
		return E_FAIL;
	}
	CATRep *pRep=spGeoVis->BuildRep();
	if( pRep == NULL ) {
		cout << "==> Get CATRep error !" << endl;
		return E_FAIL;
	}
	//CAT3DRep *p3DRep = (CAT3DRep*)pRep;
	//if (p3DRep==NULL)
	//{
	//	return E_FAIL;
	//}
	CAT3DBagRep *p3DBagRep = new CAT3DBagRep();
	p3DBagRep->AddChild(*pRep);
	const CAT4x4Matrix *pMatrix=p3DBagRep->GetMatrix();
	CATMathVectorf oU,oV,oW;
	CATMathPointf oT;
	pMatrix->GetComponents(oU,oV,oW,oT);
	*/

	//CATIMeasurableCurve_var spiMeasurableCrv=_spBUSelectB;	//该接口只能适用于没有坐标变换过的对象
	//if (spiMeasurableCrv==NULL_var)
	//{
	//	return E_FAIL;
	//}
	CATIMeasurableInContext_var spiMeasurableInContext=_spBUSelectB;	//必须用context来获取点，这样可以包含坐标变换
	if (spiMeasurableInContext==NULL_var)
	{
		return E_FAIL;
	}

	CATMathPoint ptStart,ptMid,ptEnd;
	rc=spiMeasurableInContext->GetPointsOnCurve(ptStart,ptMid,ptEnd);

	return rc;
}

HRESULT TestEnvelopeCmd::GetRepFromBU(CATBaseUnknown_var ispBU,CATRep **opRep)
{
	HRESULT rc = S_OK;
	//特征化
	CATISpecObject_var spiSpecObj = _pGeneralCls->GetSpecFromBaseUnknownFunc(ispBU);
	if (spiSpecObj==NULL_var)
	{
		return E_FAIL;
	}
	//CATVisManager * pVisuManager = CATVisManager::GetVisManager();
	//CATModelIdentificator Ident(spiSpecObj);
	//CAT3DRep * pRepChild = (CAT3DRep *) pVisuManager->BuildRep(Ident);

	//CATIVisu *piVisu = NULL;
	//rc = spiSpecObj->QueryInterface(IID_CATIVisu,(void**)&piVisu);
	//if (FAILED(rc)||piVisu==NULL)
	//{
	//	return E_FAIL;
	//}
	//CATRep *pRep = piVisu->BuildRep();

	CATI3DGeoVisu *pi3DGeoVisu = NULL;
	rc = spiSpecObj->QueryInterface(IID_CATI3DGeoVisu,(void**)&pi3DGeoVisu);
	if (FAILED(rc)||pi3DGeoVisu==NULL)
	{
		return E_FAIL;
	}
	CATRep *pRep = pi3DGeoVisu->GiveRep();

	*opRep = pRep;
	//
	return E_FAIL;
}

HRESULT TestEnvelopeCmd::Get3DRep(CATPathElement *iObject, CAT3DRep ** oRep,CATRepPath &oRepPath)
{
	HRESULT rc = E_FAIL ;

	if ( NULL == oRep ) return rc ;

	CATVisManager * pVisManager = CATVisManager::GetVisManager();

	if ( NULL != pVisManager )
	{
		CATViewpoint *pViewpoint=NULL;
		CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
		if ( NULL !=  pLayout )
		{
			CATFrmWindow * pWindow = pLayout->GetCurrentWindow();
			if ( NULL !=  pWindow )
			{
				CATViewer * pViewer = pWindow->GetViewer();

				if ( NULL != pViewer )
				{
					CAT3DViewpoint & Main3DViewpoint = pViewer->GetMain3DViewpoint();
					pViewpoint = (CATViewpoint*)(& Main3DViewpoint);
				}
			}
		}

		// Generation of the rep
		pVisManager->GenerateRepPathFromPathElement(*iObject,pViewpoint,oRepPath);

		if ( oRepPath.Size() >= 1 )
		{                   
			//*oRep = (CAT3DRep*) oRepPath[oRepPath.Size()-1];
			*oRep = (CAT3DRep*) oRepPath[0];
			if ( NULL != *oRep )
			{
				rc = S_OK ;
			}
		}
	}
	return rc ;
}

HRESULT TestEnvelopeCmd::GetRepFromBU(CATBaseUnknown *ipBU, CATFrmEditor *ipEditor,CATRep ** oRep,CATRepPath &oRepPath)
{
	HRESULT rc = E_FAIL ;

	if ( NULL == oRep ) return rc ;

	CATVisManager * pVisManager = CATVisManager::GetVisManager();

	if ( NULL != pVisManager )
	{
		CATViewpoint *pViewpoint=NULL;
		CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
		if ( NULL !=  pLayout )
		{
			CATFrmWindow * pWindow = pLayout->GetCurrentWindow();
			if ( NULL !=  pWindow )
			{
				CATViewer * pViewer = pWindow->GetViewer();

				if ( NULL != pViewer )
				{
					CAT3DViewpoint & Main3DViewpoint = pViewer->GetMain3DViewpoint();
					pViewpoint = (CATViewpoint*)(& Main3DViewpoint);
				}
			}
		}

		CATPathElement *iObject = NULL;
		rc = GetPathElemFromBU(ipBU,ipEditor,iObject);
		if (FAILED(rc)||iObject==NULL)
		{
			return E_FAIL;
		}

		CATUnicodeString strPathElem = "";
		_pGeneralCls->PathElementString(iObject,strPathElem);
		cout<<"==> PathElement: "<<strPathElem<<endl;
		cout<<"==> PathElement Num: "<<iObject->GetSize()<<endl;

		// Generation of the rep
		pVisManager->GenerateRepPathFromPathElement(*iObject,pViewpoint,oRepPath);

		if ( oRepPath.Size() >= 1 )
		{                   
			CATUnicodeString strPathName = "";
			int NumOfPath = oRepPath.Size();
			for(int i=0;i<NumOfPath;i++)  
			{
				CATRep *pRep =(CATRep*)(oRepPath)[i];
				if (pRep == NULL)
				{
					continue;
				}
				CATBaseUnknown *pElt = NULL; 
				rc = pRep->QueryInterface(IID_CATBaseUnknown,(void**)&pElt);
				if(pElt != NULL) 
				{
					CATIAlias *piAlias = NULL;
					rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
					if(SUCCEEDED(rc) && piAlias!=NULL)
					{
						CATUnicodeString Name = piAlias->GetAlias();
						strPathName.Append(Name) ;
						if(i<=(NumOfPath-2)) 
						{
							strPathName.Append("/");
						}
						piAlias->Release(); piAlias = NULL;
					}
				}
				if (pElt == ipBU)
				{
					*oRep = (CATRep*) oRepPath[i];
				}
			}

			cout<<"==> RepPath: "<<strPathName<<endl;
			
			//*oRep = (CAT3DRep*) oRepPath[oRepPath.Size()-1];
			//*oRep = (CAT3DRep*) oRepPath[0];
			if ( NULL != *oRep )
			{
				rc = S_OK ;
			}
		}
	}
	return rc ;
}

HRESULT TestEnvelopeCmd::GetPathElemFromBU(CATBaseUnknown_var ispBU,CATFrmEditor *ipEditor,CATPathElement *&opPathElem)
{

	CATIBuildPath *piBuildPath = NULL;
	HRESULT rc = ispBU->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
	if (SUCCEEDED(rc))
	{
		CATPathElement context = ipEditor->GetUIActiveObject();
		CATPathElement *pPathElement = NULL;

		rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
		if (pPathElement != NULL)
		{
			opPathElem = pPathElement;
			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT TestEnvelopeCmd::CreateTessellation(CATBaseUnknown_var ispBUElement,vector<CATMathPoint> &olstVertices)
{
	HRESULT rc = S_OK;
	//
	if (ispBUElement==NULL_var)
	{
		return E_FAIL;
	}
	CATBody_var spBody = _pGeneralCls->GetBodyFromFeature(ispBUElement);
	if (spBody==NULL_var)
	{
		return E_FAIL;
	}
	CAT3DBagRep* pBagRep = new CAT3DBagRep();
	//Tessellate the body
	double iStep   = 1;
	double sag=	10;
	//CATBodyTessellator * pTessellator = new CATBodyTessellator(spBody,sag);
	CATCellTessellator * pTessellator = new CATCellTessellator(sag);
	if( NULL == pTessellator ) 
	{
		cout << "==> Create CATCellTessellator error !" << endl;
		return E_FAIL;
	}
	//Set the step to the CATCellTessellator.
	pTessellator->SetStep(iStep);
	cout << "==> The step is: " << iStep << endl;

	//Add face to the CATCellTessellator.
	CATLISTP(CATCell) cells;
	spBody->GetAllCells( cells,2); 
	int numberOfCells = cells.Size();
	cout <<"==> Number of face: " << numberOfCells << endl;
	for (int ifa=1 ; ifa<=numberOfCells ; ifa++)
	{
		pTessellator->AddFace((CATFace *)(cells[ifa]));
	}
	//Run the CATCellTessellator
	pTessellator->Run();



	//CATISpecObject_var spLine;
	// For every face.
	for(int i=1;i<=numberOfCells;i++) 
	{
		cout << "==> Face: " << i << endl;
		// for each face, retrieve the tessellation results.
		CATFace * piFace = (CATFace*) cells[i];
		if( NULL == piFace )
		{
			return E_FAIL;
		}
		//Get the result.
		CATBoolean isPlanar;
		CATTessPointIter *    pVertices  = NULL;
		CATTessStripeIter *   pStrips    = NULL;
		CATTessFanIter *      pFans      = NULL;
		CATTessPolyIter *     pPolygons  = NULL;
		CATTessTrianIter *    pTriangles = NULL;
		short side;
		pTessellator->GetFace(piFace,isPlanar,&pVertices,&pStrips,&pFans,&pPolygons,&pTriangles,&side);		//获得的点都是局部坐标，按需转成全局

		if (NULL==pVertices)
		{
			continue;
		}

		//获取所有点和法向的基础信息
		float  (* aCoord)[3] = NULL;
		float  (* aNormal)[3] = NULL;
		int     * aNuPts     = NULL;
		CATLONG32 nbp = 0;

		nbp=pVertices->GetNbPoint();
		aCoord = new float[nbp][3];
		aNormal = new float[nbp][3];
		pVertices->GetPointXyzAll(aCoord);	//获得所有的离散点
		pVertices->GetPointNorAll(aNormal);	//获得每个离散点处的法向

		//2维列表变成1维列表
		int verticesArraySize=3*nbp;
		int normalsArraySize=3*nbp;

		cout << "  ==> Total point: " << nbp << endl;

		float *vertices=new float[verticesArraySize];
		float *normals=new float[normalsArraySize];
		for(int j=0;j<nbp;j++) {
			for(int k=0;k<3;k++) {
				vertices[3*j+k] = aCoord[j][k];
				normals[3*j+k] = aNormal[j][k];
			}
		}

		//   循环画点
		int iNum = 0;
		while (0 == (pVertices->IsExhausted()))
		{
			const double *aCoord = pVertices->GetPointXyz();
			////模型上画出虚拟点，CATISO高亮
			//DumITempPoint *piTempPoint = NULL;
			//HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
			//if (SUCCEEDED(rc) && piTempPoint != NULL)
			//{
			//	piTempPoint->SetDatas(&CATMathPoint(*aCoord,*(aCoord+1),*(aCoord+2)));
			//	_pISO->AddElement(piTempPoint);
			//}

			olstVertices.push_back(CATMathPoint(*aCoord,*(aCoord+1),*(aCoord+2)));

			pVertices->GoToNext();
			iNum++;
		}

		cout<<"==> Vertex number: "<<iNum<<endl;
		

		if (NULL!=aCoord)
		{
			delete []aCoord;
		}
		if (NULL!=aNormal)
		{
			delete []aNormal;
		}
	}
	delete pTessellator;   pTessellator = NULL;

	return rc;
}

HRESULT TestEnvelopeCmd::CreateRotationTransformation(vector<CATMathPoint> ilstVertices,double iDeg,CATMathLine iAxis,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDeg/iStep;
	CATAngle angleStep=iStep*CATPI/180;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*angleStep,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
	}

	double iRepeatLast=fmod(iDeg,iStep);
	if (iRepeatLast>0.01)
	{
		CATAngle angleLast=iDeg*CATPI/180;
		CATMathTransformation trans(angleLast,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
	}

	return rc;
}

HRESULT TestEnvelopeCmd::CreateRotationTransformationUpdate(vector<CATMathPoint> ilstVertices,double iDeg,CATMathLine iAxis,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	//先把输入点集过滤一下
	this->CalculateOuterPoints(ilstVertices,1);

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDeg/iStep;
	CATAngle angleStep=iStep*CATPI/180;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*angleStep,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,1);
	}

	double iRepeatLast=fmod(iDeg,iStep);
	if (iRepeatLast>0.01)
	{
		CATAngle angleLast=iDeg*CATPI/180;
		CATMathTransformation trans(angleLast,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,1);
	}

	return rc;
}

HRESULT TestEnvelopeCmd::CreateTranslateTransformation(vector<CATMathPoint> ilstVertices,double iDistance,CATMathVector iDir,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	iDir.Normalize();

	//先把输入点集过滤一下
	this->CalculateOuterPoints(ilstVertices,0.4);

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDistance/iStep;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*iStep*iDir);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,0.4);
	}

	double iRepeatLast=fmod(iDistance,iStep);
	if (iRepeatLast>0.01)
	{
		CATMathTransformation trans(iDistance*iDir);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,0.4);
	}

	return rc;
}




HRESULT TestEnvelopeCmd::CalculateOuterPoints(vector<CATMathPoint> &iolstVerticesAll,double iStep)
{
	HRESULT rc=S_OK;

	vector<CATMathPoint> lstPtOuter;
	//
	CATMathBox mathBox;
	for (int i=0;i<iolstVerticesAll.size();i++)
	{
		CATMathPoint pt=iolstVerticesAll[i];
		mathBox.AddInside(pt);
	}
	double oXMin,oXMax,oYMin,oYMax,oZMin,oZMax;
	mathBox.GetExtremities(oXMin,oXMax,oYMin,oYMax,oZMin,oZMax);

	//
	int iNumRepeatX=(oXMax-oXMin)/iStep;
	int iNumRepeatY=(oYMax-oYMin)/iStep;
	int iNumRepeatZ=(oZMax-oZMin)/iStep;

	double iStepX=(oXMax-oXMin)/iNumRepeatX;
	double iStepY=(oYMax-oYMin)/iNumRepeatY;
	double iStepZ=(oZMax-oZMin)/iNumRepeatZ;

	vector<CATMathPoint> lstPtFilter;
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());
	//XY面内判断Z向极值
	vector<CATMathPoint> lstPtAll;
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());
	for (int i=1;i<=iNumRepeatX;i++)
	{
		double dblFirstDirMin=oXMin+((i-1)*iStepX);
		double dblFirstDirMax=oXMin+(i*iStepX);
		if (i==1)			dblFirstDirMin=oXMin-0.5;
		if (i==iNumRepeatX) dblFirstDirMax=oXMax+0.5;

		for (int j=1;j<=iNumRepeatY;j++)
		{
			double dblSecondDirMin=oYMin+((j-1)*iStepY);
			double dblSecondDirMax=oYMin+(j*iStepY);
			if (j==1)			dblSecondDirMin=oYMin-0.5;
			if (j==iNumRepeatY) dblSecondDirMax=oYMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"Z",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);
			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}

	//int iFinish=0;
	//int iRepeatFirst=1;
	//int iRepeatSecond=1;
	//while(iFinish==0)
	//{
	//	
	//}

	//XZ面内判断Y向极值
	lstPtAll.swap(vector<CATMathPoint>());
	//lstPtAll.insert(lstPtAll.end(),lstPtFilter.begin(),lstPtFilter.end());
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	lstPtFilter.swap(vector<CATMathPoint>());
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	for (int i=1;i<=iNumRepeatX;i++)
	{
		double dblFirstDirMin=oXMin+((i-1)*iStepX);
		double dblFirstDirMax=oXMin+(i*iStepX);
		if (i==1)			dblFirstDirMin=oXMin-0.5;
		if (i==iNumRepeatX) dblFirstDirMax=oXMax+0.5;
		
		for (int j=1;j<=iNumRepeatZ;j++)
		{
			double dblSecondDirMin=oZMin+((j-1)*iStepZ);
			double dblSecondDirMax=oZMin+(j*iStepZ);
			if (j==1)			dblSecondDirMin=oZMin-0.5;
			if (j==iNumRepeatZ) dblSecondDirMax=oZMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"Y",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);

			//if (FALSE==this->IsOccur(oPtMin,lstPtOuter))	olstVerticesOuter.push_back(oPtMin);
			//if (FALSE==this->IsOccur(oPtMax,lstPtOuter))	olstVerticesOuter.push_back(oPtMax);

			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}
	//YZ面内判断X向极值
	lstPtAll.swap(vector<CATMathPoint>());
	//lstPtAll.insert(lstPtAll.end(),lstPtFilter.begin(),lstPtFilter.end());
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	lstPtFilter.swap(vector<CATMathPoint>());
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	for (int i=1;i<=iNumRepeatY;i++)
	{
		double dblFirstDirMin=oYMin+((i-1)*iStepY);
		double dblFirstDirMax=oYMin+(i*iStepY);
		if (i==1)			dblFirstDirMin=oYMin-0.5;
		if (i==iNumRepeatY) dblFirstDirMax=oYMax+0.5;
		
		for (int j=1;j<=iNumRepeatZ;j++)
		{

			double dblSecondDirMin=oZMin+((j-1)*iStepZ);
			double dblSecondDirMax=oZMin+(j*iStepZ);
			if (j==1)			dblSecondDirMin=oZMin-0.5;
			if (j==iNumRepeatZ) dblSecondDirMax=oZMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"X",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);

			//if (FALSE==this->IsOccur(oPtMin,olstVerticesOuter))	olstVerticesOuter.push_back(oPtMin);
			//if (FALSE==this->IsOccur(oPtMax,olstVerticesOuter)) olstVerticesOuter.push_back(oPtMax);

			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}

	//
	iolstVerticesAll.swap(lstPtOuter);

	return rc;
}

void TestEnvelopeCmd::GetExtremePointsInEachArea(vector<CATMathPoint> &iolstPt,double iFirstDirMin,double iFirstDirMax,double iSecondDirMin,double iSecondDirMax,
												 CATUnicodeString istrThirdDir,CATMathPoint &oPtMin,CATMathPoint &oPtMax,CATBoolean &obFindMin,CATBoolean &obFindMax,
												 vector<CATMathPoint> &iolstPtFilter)
{
	int iFirst,iSecond,iThird;
	if (istrThirdDir=="Z")
	{
		iFirst=0;
		iSecond=1;
		iThird=2;
	}
	else if (istrThirdDir=="Y")
	{
		iFirst=0;
		iSecond=2;
		iThird=1;
	}
	else
	{
		iFirst=1;
		iSecond=2;
		iThird=0;
	}
	//
	double dblMax=-DBL_MAX;
	double dblMin=DBL_MAX;
	obFindMin=FALSE;
	obFindMax=FALSE;
	int iIndexMin=0;
	int iIndexMax=0;
	for (int i=0;i<iolstPt.size();i++)
	{
		CATMathPoint ptCurrent=iolstPt[i];
		double arrPt[3]={ptCurrent.GetX(),ptCurrent.GetY(),ptCurrent.GetZ()};

		double dFirstDir=arrPt[iFirst];
		double dSecondDir=arrPt[iSecond];
		double dThirdDir=arrPt[iThird];
		if (dFirstDir<iFirstDirMin||dFirstDir>iFirstDirMax||dSecondDir<iSecondDirMin||dSecondDir>iSecondDirMax)	//点没在范围内，直接判断下一个
		{
			continue;
		}
		if (dThirdDir>dblMax)
		{
			dblMax=dThirdDir;
			oPtMax=ptCurrent;
			obFindMax=TRUE;
			iIndexMax=i;
		}
		if (dThirdDir<dblMin)
		{
			dblMin=dThirdDir;
			oPtMin=ptCurrent;
			obFindMin=TRUE;
			iIndexMin=i;
		}
		//把在当前范围内的点从列表中删除，这样在下次计算别的范围时，这些点就不会包含进去了，减少循环量
		iolstPt.erase(iolstPt.begin()+i);
		i--;

	}

	//如果有极值点，则在输出的列表中删除该极值点，用该列表传给下个方向求极值
	if (TRUE==obFindMax)
	{
		if (iIndexMax==iIndexMin)
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
		} 
		else if (iIndexMax>iIndexMin)
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMin);
		}
		else
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMin);
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
		}

	}
}

CATBoolean TestEnvelopeCmd::IsOccur(CATMathPoint iPt,vector<CATMathPoint> ilstPt)
{
	for (int i=0;i<ilstPt.size();i++)
	{
		CATMathPoint iPtTemp=ilstPt[i];
		if (iPt.DistanceTo(iPtTemp)<=0.001)
		{
			return TRUE;
		}
	}
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

HRESULT TestEnvelopeCmd::CreateTranslateTransformation(CATBody_var ispBody,CATIProduct_var ispiProd,double iDistance,CATMathVector iDir,double iStep,CATBody *&opBodyAssy)
{
	HRESULT rc=S_OK;

	iDir.Normalize();

	//

	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(ispiProd,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return E_FAIL;
	}
	//
	CATLISTP(CATBody) lstBody;

	CATBody *pBody=NULL;
	if (SUCCEEDED(GetBodyFromBodyCells(ispBody,pGeoFactory,2,pBody))&&pBody!=NULL)
	{
		lstBody.Append(pBody);
	}
	
	
	int iRepeatNum=iDistance/iStep;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*iStep*iDir);
		CATBody_var spBodyTrans=NULL_var;
		GetTransformationBody(ispBody,trans,spBodyTrans);
		if (spBodyTrans!=NULL_var)
		{
			CATBody *pBody=NULL;
			if (SUCCEEDED(GetBodyFromBodyCells(spBodyTrans,pGeoFactory,2,pBody))&&pBody!=NULL)
			{
				lstBody.Append(pBody);
			}
		}
	}

	double iRepeatLast=fmod(iDistance,iStep);
	if (iRepeatLast>0.01)
	{
		CATMathTransformation trans(iDistance*iDir);
		CATBody_var spBodyTrans=NULL_var;
		GetTransformationBody(ispBody,trans,spBodyTrans);
		if (spBodyTrans!=NULL_var)
		{
			CATBody *pBody=NULL;
			if (SUCCEEDED(GetBodyFromBodyCells(spBodyTrans,pGeoFactory,2,pBody))&&pBody!=NULL)
			{
				lstBody.Append(pBody);
			}
		}
	}
	

	//
	CATBody *pBodyAssy=CreateTopAssembly(pGeoFactory,topdata,lstBody);
	if (pBodyAssy==NULL)
	{
		return E_FAIL;
	}

	opBodyAssy=pBodyAssy;

	return rc;
}

HRESULT TestEnvelopeCmd::CreateTranslateTransformationUpdate(CATBody_var ispBody,CATIProduct_var ispiProd,double iDistance,CATMathVector iDir,double iStep,CATBody *&opBodyAssy)
{
	HRESULT rc=S_OK;

	iDir.Normalize();

	//

	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(ispiProd,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return E_FAIL;
	}
	//
	CATLISTP(CATBody) lstBody;

	//CATBody *pBody=NULL;
	//if (SUCCEEDED(GetBodyFromBodyCells(ispBody,pGeoFactory,2,pBody))&&pBody!=NULL)
	//{
	//	lstBody.Append(pBody);
	//}
	lstBody.Append(ispBody);

	int iRepeatNum=iDistance/iStep;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*iStep*iDir);
		CATBody_var spBodyTrans=NULL_var;
		GetTransformationBody(ispBody,trans,spBodyTrans);
		if (spBodyTrans!=NULL_var)
		{
			//CATBody *pBody=NULL;
			//if (SUCCEEDED(GetBodyFromBodyCells(spBodyTrans,pGeoFactory,2,pBody))&&pBody!=NULL)
			//{
			//	lstBody.Append(pBody);
			//}
			lstBody.Append(spBodyTrans);
		}
	}

	double iRepeatLast=fmod(iDistance,iStep);
	if (iRepeatLast>0.01)
	{
		CATMathTransformation trans(iDistance*iDir);
		CATBody_var spBodyTrans=NULL_var;
		GetTransformationBody(ispBody,trans,spBodyTrans);
		if (spBodyTrans!=NULL_var)
		{
			//CATBody *pBody=NULL;
			//if (SUCCEEDED(GetBodyFromBodyCells(spBodyTrans,pGeoFactory,2,pBody))&&pBody!=NULL)
			//{
			//	lstBody.Append(pBody);
			//}
			lstBody.Append(spBodyTrans);
		}
	}


	//
	CATBody *pBodyAssy=CreateTopAssembly(pGeoFactory,topdata,lstBody);
	if (pBodyAssy==NULL)
	{
		return E_FAIL;
	}

	opBodyAssy=pBodyAssy;

	return rc;
}

HRESULT TestEnvelopeCmd::CreateEdgeTessellation(CATBody *ipBodyCurve,vector<CATMathPoint> &olstVertices)
{
	HRESULT rc = S_OK;
	//
	if (ipBodyCurve==NULL)
	{
		return E_FAIL;
	}
	//Tessellate the body
	double iStep   = _dTessellateStep;
	double sag=	10;
	//CATBodyTessellator * pTessellator = new CATBodyTessellator(spBody,sag);
	CATCellTessellator * pTessellator = new CATCellTessellator(sag);
	if( NULL == pTessellator ) 
	{
		cout << "==> Create CATCellTessellator error !" << endl;
		return E_FAIL;
	}
	//Set the step to the CATCellTessellator.
	pTessellator->SetStep(iStep);
	cout << "==> The step is: " << iStep << endl;

	//Add face to the CATCellTessellator.
	CATLISTP(CATCell) cells;
	ipBodyCurve->GetAllCells( cells,1); 
	int numberOfCells = cells.Size();
	cout <<"==> Number of edge: " << numberOfCells << endl;
	for (int ifa=1 ; ifa<=numberOfCells ; ifa++)
	{
		pTessellator->AddEdge((CATEdge *)(cells[ifa]));
	}
	//Run the CATCellTessellator
	pTessellator->Run();



	//CATISpecObject_var spLine;
	// For every face.
	for(int i=1;i<=numberOfCells;i++) 
	{
		cout << "==> Edge: " << i << endl;
		// for each face, retrieve the tessellation results.
		CATEdge * pEdge = (CATEdge*) cells[i];
		if( NULL == pEdge )
		{
			return E_FAIL;
		}
		//Get the result.
		CATLONG32 oNumberOfPoints;
		double *oPointData=NULL;
		pTessellator->GetEdge(pEdge,oNumberOfPoints,&oPointData);		//获得的点都是局部坐标，按需转成全局

		if (NULL==oPointData||oNumberOfPoints==0)
		{
			continue;
		}
		cout << "  ==> Total point: " << oNumberOfPoints << endl;

		//   循环画点

		for (int i=1;i<=oNumberOfPoints;i++)
		{
			double dX=oPointData[3*(i-1)];
			double dY=oPointData[3*(i-1)+1];
			double dZ=oPointData[3*(i-1)+2];

			olstVertices.push_back(CATMathPoint(dX,dY,dZ));
		}

		cout<<"==> Vertex number: "<<oNumberOfPoints<<endl;
	}
	delete pTessellator;   pTessellator = NULL;

	return rc;
}

//滚球法求点集最外轮廓，考虑凹包，在指定平面内计算
HRESULT TestEnvelopeCmd::CalculateOuterHull(vector<CATMathPoint> ilstPtAll, double idR,CATUnicodeString istrDir,vector<CATMathPoint> &olstPtConcaveHull)
{
	HRESULT rc=S_OK;

	//删除重复点集并转换为2D点
	vector<CATMathPoint2D> lstPt2D;
	double dThirdDimension;
	for (int i=0;i<ilstPtAll.size();i++)
	{
		CATMathPoint ptForward=ilstPtAll[i];
		for (int j=ilstPtAll.size()-1;j>i;j--)
		{
			CATMathPoint ptBackward=ilstPtAll[j];
			if (ptBackward.DistanceTo(ptForward)<=0.001)
			{
				ilstPtAll.erase(ilstPtAll.begin()+j);
			}
		}
		if (istrDir=="XY")
		{
			lstPt2D.push_back(CATMathPoint2D(ptForward.GetX(),ptForward.GetY()));
			dThirdDimension=ptForward.GetZ();
		}
		else if (istrDir=="XZ")
		{
			lstPt2D.push_back(CATMathPoint2D(ptForward.GetX(),ptForward.GetZ()));
			dThirdDimension=ptForward.GetY();
		}
	}

	//找到y值最小的点
	double dYmin = DBL_MAX;
	int iIndexMin = -1;
	for (int i=0;i<lstPt2D.size();i++)
	{
		CATMathPoint2D mathPt = lstPt2D[i];
		double dYcoord = mathPt.GetY();
		if (dYcoord<dYmin)
		{
			dYmin = dYcoord;
			iIndexMin = i;
		}
		else if (dYcoord==dYmin)	//如果y坐标相同，取x坐标小的
		{
			if (mathPt.GetX()<lstPt2D[iIndexMin].GetX())
			{
				dYmin = dYcoord;
				iIndexMin = i;
			}
		}
	}
	if (iIndexMin==-1)
	{
		return E_FAIL;
	}

	//
	CATMathPoint2D mathPtFirst = lstPt2D[iIndexMin];
	lstPt2D.erase(lstPt2D.begin()+iIndexMin);
	if (istrDir=="XY")
	{
		olstPtConcaveHull.push_back(CATMathPoint(mathPtFirst.GetX(),mathPtFirst.GetY(),dThirdDimension));
	}
	else if (istrDir=="XZ")
	{
		olstPtConcaveHull.push_back(CATMathPoint(mathPtFirst.GetX(),dThirdDimension,mathPtFirst.GetY()));
	}

	CATMathPoint2D ptCurrent=mathPtFirst;
	CATMathVector2D dirRef(0,1);

	int iRepeatNum=0;
	while(1)
	{
		CATMathPoint2D ptNext,ptCenter;
		CATBoolean bIsFind=IsFindNextHullPoint(lstPt2D,ptCurrent,dirRef,idR,ptNext,ptCenter);
		if (!bIsFind||ptNext.DistanceTo(mathPtFirst)<=0.001)
		{
			break;
		}
		iRepeatNum++;
		if (iRepeatNum==1)
		{
			lstPt2D.push_back(mathPtFirst);
		}
		CATMathPoint oCenter;
		CATMathVector dir;
		if (istrDir=="XY")
		{
			olstPtConcaveHull.push_back(CATMathPoint(ptNext.GetX(),ptNext.GetY(),dThirdDimension));

			oCenter.SetCoord(ptCenter.GetX(),ptCenter.GetY(),dThirdDimension);
			dir.SetCoord(0,0,1);
		}
		else if (istrDir=="XZ")
		{
			olstPtConcaveHull.push_back(CATMathPoint(ptNext.GetX(),dThirdDimension,ptNext.GetY()));

			oCenter.SetCoord(ptCenter.GetX(),dThirdDimension,ptCenter.GetY());
			dir.SetCoord(0,1,0);
		}

		dirRef=ptCurrent-ptNext;
		ptCurrent=ptNext;

		//圆挂树上
		//获取工厂
		CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
		CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
		CATIPrtContainer_var ospiCont=NULL_var;
		CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
		if (topdata == NULL || pGeoFactory == NULL)
		{
			return FALSE;
		}

		//
		CATBody_var spBodyCircle=NULL_var;
		CATMathPlane mathPlane(oCenter,dir);
		CreateCircle(pGeoFactory,topdata,mathPlane,0.5*idR,spBodyCircle);
		if (spBodyCircle!=NULL_var)
		{
			CATUnicodeString strGeoSetName="Test_Circle";
			CATISpecObject_var spiGeoSet=NULL_var;
			HRESULT rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,strGeoSetName,spiGeoSet);
			if (FAILED(rc)||spiGeoSet==NULL_var)
			{
				continue;;
			}

			CATISpecObject_var spiSpecObj=NULL_var;
			_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"Circle",spBodyCircle,spiSpecObj);

			spiGeoSet->Update();
		}
	}
	

	return rc;
}

CATBoolean TestEnvelopeCmd::IsFindNextHullPoint(vector<CATMathPoint2D> &iolstPtRest,CATMathPoint2D iPtCurrent,CATMathVector2D iDirRef,double idR,CATMathPoint2D &oPtNext)
{
	//
	vector<int> lstIndexSorted;
	this->SortAdjListByAngle(iolstPtRest,iPtCurrent,iDirRef,idR,lstIndexSorted);

	//
	double dR=0.5*idR;
	for (int i=0;i<lstIndexSorted.size();i++)
	{
		CATMathPoint2D ptAdj=iolstPtRest[lstIndexSorted[i]];
		CATMathPoint2D ptCenter;
		if (this->GetCircleCenter(iPtCurrent,ptAdj,dR,ptCenter))
		{
			if (!this->HasPointsInCircle(iolstPtRest,lstIndexSorted,ptCenter,dR,i))
			{
				oPtNext=ptAdj;
				iolstPtRest.erase(iolstPtRest.begin()+lstIndexSorted[i]);
				return TRUE;
			}
		}
	}

	return FALSE;
}

CATBoolean TestEnvelopeCmd::IsFindNextHullPoint(vector<CATMathPoint2D> &iolstPtRest,CATMathPoint2D iPtCurrent,CATMathVector2D iDirRef,double idR,CATMathPoint2D &oPtNext,CATMathPoint2D &oCenter)
{
	//
	vector<int> lstIndexSorted;
	this->SortAdjListByAngle(iolstPtRest,iPtCurrent,iDirRef,idR,lstIndexSorted);

	//
	double dR=0.5*idR;
	for (int i=0;i<lstIndexSorted.size();i++)
	{
		CATMathPoint2D ptAdj=iolstPtRest[lstIndexSorted[i]];
		CATMathPoint2D ptCenter;
		if (this->GetCircleCenter(iPtCurrent,ptAdj,dR,ptCenter))
		{
			if (!this->HasPointsInCircle(iolstPtRest,lstIndexSorted,ptCenter,dR,lstIndexSorted[i]))
			{
				oPtNext=ptAdj;
				iolstPtRest.erase(iolstPtRest.begin()+lstIndexSorted[i]);
				oCenter=ptCenter;
				return TRUE;
			}
		}
	}

	return FALSE;
}

/*
void TestEnvelopeCmd::SortAdjListByAngle(vector<CATMathPoint2D> ilstPt, CATMathPoint2D iPtCurrent,CATMathPoint2D iDirRef,double idR,vector<CATMathPoint2D> &olstPtSorted)
{
	//先根据半径过滤一波，不在圆内的删掉
	for (int i=0;i<ilstPt.size();i++)
	{
		CATMathPoint2D pt=ilstPt[i];
		if (pt.DistanceTo(iPtCurrent)-idR >0)
		{
			ilstPt.erase(ilstPt.begin()+i);
		}
	}
	//
	CATMathPoint2D ptTemp;
	for (int i=ilstPt.size();i>0;i--)
	{
		for (int j=0;j<i-1;j++)
		{
			CATMathPoint2D ptA=ilstPt[j];
			CATMathPoint2D ptB=ilstPt[j+1];
			if (this->CompareAngle(ptA,ptB,iPtCurrent,iDirRef))
			{
				swap(ilstPt[j],ilstPt[j+1]);
			}
		}
	}
	//
	olstPtSorted.swap(ilstPt);
	
}
*/

void TestEnvelopeCmd::SortAdjListByAngle(vector<CATMathPoint2D> ilstPt, CATMathPoint2D iPtCurrent,CATMathVector2D iDirRef,double idR,vector<int> &olstIndexSorted)
{
	//先根据半径过滤一波，不在圆内的删掉
	for (int i=0;i<ilstPt.size();i++)
	{
		CATMathPoint2D pt=ilstPt[i];
		if (pt.DistanceTo(iPtCurrent)-idR <=0)
		{
			olstIndexSorted.push_back(i);
		}
	}
	//
	CATMathPoint2D ptTemp;
	for (int i=olstIndexSorted.size();i>0;i--)
	{
		for (int j=0;j<i-1;j++)
		{
			CATMathPoint2D ptA=ilstPt[olstIndexSorted[j]];
			CATMathPoint2D ptB=ilstPt[olstIndexSorted[j+1]];
			if (this->CompareAngle(ptA,ptB,iPtCurrent,iDirRef))
			{
				swap(olstIndexSorted[j],olstIndexSorted[j+1]);
			}
		}
	}
}

//根据当前点和前一个点组成的向量，判断后面两个点相对于该向量哪个夹角大，iPtA大则返回false，iPtB大返回true，后续需要交换位置
CATBoolean TestEnvelopeCmd::CompareAngle(CATMathPoint2D iPtA,CATMathPoint2D iPtB,CATMathPoint2D iPtCurrent,CATMathVector2D idirRef)
{
	CATMathVector2D dirA=iPtA-iPtCurrent;
	CATMathVector2D dirB=iPtB-iPtCurrent;

	//CATMathPoint2D idirRef=iPtPrev-iPtCurrent;

	//
	double detB=GetCross(idirRef,dirB);
	double dotB=GetDot(idirRef,dirB);
	// nothing is less than zero degrees
	if (detB==0 && dotB>=0) return FALSE;	//叉积为0，说明同向或者反向平行，点积大于等于0，说明是同向，也就是夹角0

	//
	double detA=GetCross(idirRef,dirA);
	double dotA=GetDot(idirRef,dirA);
	// zero degrees is less than anything else
	if (detA==0 && dotA>=0)	return TRUE;	//

	//
	if (detA*detB >=0)	//叉积相乘大于等于0，说明两个向量在ref向量的同侧（左侧或者右侧）
	{
		return GetCross(dirA,dirB)>0;	//叉积大于0，说明a方向夹角小于b方向夹角
	}

	//
	return detA>0;	//如果a，b方向没有在ref的同侧，detA大于0，说明a的夹角比b的夹角小

}

//叉积
double TestEnvelopeCmd::GetCross(CATMathVector2D a, CATMathVector2D b) 
{
	return a.GetX() * b.GetY() - a.GetY() * b.GetX();
}
//点积
double TestEnvelopeCmd::GetDot(CATMathVector2D a,CATMathVector2D b)
{
	return a.GetX() * b.GetX() + a.GetY() * b.GetY();
}

//
CATBoolean TestEnvelopeCmd::GetCircleCenter(CATMathPoint2D iPtA, CATMathPoint2D iPtB, double idR,CATMathPoint2D &oCenter)
{
	double dx = iPtB.GetX() - iPtA.GetX();
	double dy = iPtB.GetY() - iPtA.GetY();
	double cx = 0.5 * (iPtB.GetX() + iPtA.GetX());
	double cy = 0.5 * (iPtB.GetY() + iPtA.GetY());
	if (idR * idR / (dx * dx + dy * dy) - 0.25 < 0)
	{
		return FALSE;
	}
	double dSqrt = sqrt(idR * idR / (dx * dx + dy * dy) - 0.25);
	oCenter.SetCoord(cx + dy * dSqrt, cy - dx * dSqrt);

	return TRUE;
}

CATBoolean TestEnvelopeCmd::HasPointsInCircle(vector<CATMathPoint2D> ilstPt,vector<int> ilstIndex,CATMathPoint2D iptCenter,double idR,int adjIndex)
{
	for (int k = 0; k < ilstIndex.size(); k++)
	{
		if (ilstIndex[k] != adjIndex)
		{
			CATMathPoint2D pt=ilstPt[ilstIndex[k]];
			if (pt.DistanceTo(iptCenter)<idR)
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

HRESULT TestEnvelopeCmd::GetTransformationBody(CATBody_var ispBody,CATMathTransformation itrans,CATBody_var& ospResultBody)
{
	HRESULT rc = S_OK;
	ospResultBody = NULL_var;
	if(NULL_var == ispBody)
	{
		return E_FAIL;
	}
	CATGeoFactory_var spGeoFac=ispBody->GetContainer();
	if (spGeoFac==NULL_var)
	{
		return E_FAIL;
	}

	//先把Body也坐标变换到father一级
	CATTransfoManager * pTransfoManager = new CATTransfoManager(itrans,spGeoFac,CATTransfoManager::FullDuplicate  , NULL); 		
	if (NULL==pTransfoManager)
	{
		return E_FAIL;
	}

	pTransfoManager->Add(ispBody);
	pTransfoManager->Run();

	CATBody * piTransBody = (CATBody *)(pTransfoManager->ReadImage(ispBody));
	if (piTransBody==NULL)
	{
		return E_FAIL;
	}

	ospResultBody = piTransBody;
	delete pTransfoManager;
	pTransfoManager = NULL;

	return S_OK;
}

CATBody*TestEnvelopeCmd::CreateTopAssembly(CATGeoFactory* ipGeoFactory,CATTopData* itopdata,CATLISTP(CATBody) ListOfBodyLst)
{
	if(NULL == ipGeoFactory || NULL == itopdata || ListOfBodyLst.Size()<=0)
	{
		return NULL;
	}

	ListPOfCATBody * HListOfSurface=&ListOfBodyLst;
	CATHybAssemble * pSurfaceHybAssemble=CATCreateTopAssemble(ipGeoFactory,itopdata,HListOfSurface);
	if (pSurfaceHybAssemble==NULL)
		return NULL;

	pSurfaceHybAssemble->Run();
	CATBody*pSurfaceBody= pSurfaceHybAssemble->GetResult();
	if (pSurfaceBody==NULL)
		return NULL;

	delete pSurfaceHybAssemble; 
	pSurfaceHybAssemble = NULL;

	return pSurfaceBody;
}

CATBody* TestEnvelopeCmd::CreateTopIntersect( CATGeoFactory* ipGeoFactory, CATTopData* itopdata,CATBody*iBody1,CATBody*iBody2 )
{
	CATBody*pBody=NULL;

	CATHybIntersect * ipHybIntersect=CATCreateTopIntersect( ipGeoFactory, itopdata, iBody1, iBody2);
	if (ipHybIntersect==NULL)
		return pBody;

	ipHybIntersect->Run(); 
	pBody=ipHybIntersect->GetResult();

	delete ipHybIntersect; 
	ipHybIntersect = NULL;
	return pBody;
}

CATBoolean TestEnvelopeCmd::CreatePlaneBody( CATGeoFactory_var spGeoFactory,CATTopData * topdata, CATMathPlane iMathPlane,CATBody_var &ospPlaneBody )
{
	HRESULT hr=E_FAIL;

	if (spGeoFactory==NULL_var)
		return FALSE;

	CATPlane *piNewPlane=NULL;
	piNewPlane=spGeoFactory->CreatePlane(iMathPlane);
	if (piNewPlane==NULL)
	{
		cout<<"CreatePlane Failed"<<endl;
		return FALSE;
	}

	CATSurface *iNewSurface = NULL;
	hr = piNewPlane->QueryInterface(IID_CATSurface,(void**)&iNewSurface);
	if(FAILED(hr) || iNewSurface == NULL)
	{
		cout<<"QI to IID_CATSurface is failed!"<<endl;
		return FALSE;
	}

	CATSurLimits surMaxLimits;
	iNewSurface->GetLimits(surMaxLimits) ;

	CATTopSkin * TopSkin =CATCreateTopSkin(spGeoFactory,topdata,iNewSurface,&surMaxLimits);
	//CATICGMTopSkin * TopSkin =CATCGMCreateTopSkin(pGeoFactory,topdata,iNewSurface,&surMaxLimits);
	if (TopSkin==NULL)
	{
		cout<<"CATCGMCreateTopSkin Failed"<<endl;
		return FALSE;
	}

	TopSkin->Run();

	CATBody*pTopPlaneBody=NULL;
	pTopPlaneBody = TopSkin->GetResult();
	if (pTopPlaneBody==NULL)
	{
		cout<<"pTopPlaneBody==NULL"<<endl;
		return FALSE;
	}

	if (TopSkin!=NULL)
	{
		delete TopSkin;
		TopSkin = NULL;
	}

	ospPlaneBody=pTopPlaneBody;

	return TRUE;
}

HRESULT TestEnvelopeCmd::GetBodyFromBodyCells(CATBody_var ispBody,CATGeoFactory *ipGeoFact,int iDimension,CATBody *&opBody)
{
	HRESULT rc=S_OK;
	//
	if (ispBody==NULL_var||ipGeoFact==NULL)
	{
		return E_FAIL;
	}
	//
	CATLISTP(CATCell) lstCell;
	ispBody->GetAllCells(lstCell,iDimension);
	if (lstCell.Size()==0)
	{
		return E_FAIL;
	}
	//
	CATBody *pBody = ipGeoFact->CreateBody();
	CATDomain *pDomain = pBody->CreateDomain(iDimension);
	for (int i=1;i<=lstCell.Size();i++)
	{
		pDomain->AddCell(lstCell[i]);
	}
	pBody->AddDomain(pDomain);
	if (pBody==NULL)
	{
		return E_FAIL;
	}
	opBody=pBody;
	return rc;
}

HRESULT TestEnvelopeCmd::CreateCircle( CATGeoFactory_var spGeoFactory,CATTopData * topdata,CATMathPlane iMathPlane,double Radius,CATBody_var &ospBody )
{
	HRESULT hr=E_FAIL;

	CATCircle * pCircle=spGeoFactory->CreateCircle(Radius,iMathPlane);
	if (pCircle==NULL)
	{
		cout<<"CreateCircle Failed"<<endl;
		return E_FAIL;
	}

	CATCurve *piCurve = NULL;
	hr = pCircle->QueryInterface(IID_CATCurve,(void**)&piCurve);
	if(FAILED(hr) || piCurve == NULL)
	{
		cout<<"QI to IID_CATCurve is failed!"<<endl;
		return E_FAIL;
	}

	int iNum = 1;
	CATCurve ** ListOfCurves = new CATCurve * [iNum];
	CATCrvLimits * curLimits = new CATCrvLimits[iNum];
	short * wireOrientations = new short[iNum];
	ListOfCurves[0] = piCurve;

	for (int i = 0; i <iNum ; i++)
	{
		CATCurve * pLocalCurve = ListOfCurves[i];
		if (pLocalCurve != NULL)
			pLocalCurve->GetLimits(curLimits[i]);
		wireOrientations[i]=short(1);
	}

	CATTopWire * pWire = ::CATCreateTopWire(spGeoFactory, 
		topdata,
		iNum,
		ListOfCurves,
		curLimits,
		wireOrientations);

	pWire->ForceWireClosure();
	pWire->Run();

	ospBody = pWire->GetResult();

	if (pCircle!=NULL)
	{
		spGeoFactory->Remove(pCircle);
		pCircle=NULL;
	}

	if (pWire!=NULL)
	{
		delete pWire;
		pWire = NULL;
	}

	if (ListOfCurves!=NULL)
	{
		delete ListOfCurves; 
		ListOfCurves = NULL;
	}

	if (curLimits!=NULL)
	{
		delete curLimits;
		curLimits = NULL;
	}

	if (wireOrientations!=NULL)
	{
		delete wireOrientations; 
		wireOrientations = NULL;
	}


	return S_OK;
}

CATBody* TestEnvelopeCmd::CreateBodyFromDomain(CATGeoFactory *ipGeoFactory, CATDomain *ipDomain, int iDimension)
{
	CATBody *pBody = NULL;
	if (ipDomain==NULL||ipGeoFactory==NULL)
	{
		return NULL;
	}
	CATLISTP(CATCell) lstCell;
	ipDomain->GetAllCells(lstCell,iDimension);
	pBody = ipGeoFactory->CreateBody();
	CATDomain *pDomainCurr = pBody->CreateDomain(iDimension);
	for (int j=1;j<=lstCell.Size();j++)
	{
		pDomainCurr->AddCell(lstCell[j]);
	}
	pBody->AddDomain(pDomainCurr);

	return pBody;
}

//////////////////////////////////////////////////////////////////////////
///////////////////////////Map 方式改写点云算法
//////////////////////////////////////////////////////////////////////////
HRESULT TestEnvelopeCmd::CreateSurfaceTessellation(CATBaseUnknown_var ispBUElement,
												   map<int,map<int,vector<CATMathPoint>>> &iomapXY,
												   map<int,map<int,vector<CATMathPoint>>> &iomapXZ,
												   map<int,map<int,vector<CATMathPoint>>> &iomapYZ)
{
	HRESULT rc = S_OK;
	//
	if (ispBUElement==NULL_var)
	{
		return E_FAIL;
	}
	CATBody_var spBody = _pGeneralCls->GetBodyFromFeature(ispBUElement);
	if (spBody==NULL_var)
	{
		return E_FAIL;
	}
	CAT3DBagRep* pBagRep = new CAT3DBagRep();
	//Tessellate the body
	double iStep   = 1;
	double sag=	10;
	//CATBodyTessellator * pTessellator = new CATBodyTessellator(spBody,sag);
	CATCellTessellator * pTessellator = new CATCellTessellator(sag);
	if( NULL == pTessellator ) 
	{
		cout << "==> Create CATCellTessellator error !" << endl;
		return E_FAIL;
	}
	//Set the step to the CATCellTessellator.
	pTessellator->SetStep(iStep);
	cout << "==> The step is: " << iStep << endl;

	//Add face to the CATCellTessellator.
	CATLISTP(CATCell) cells;
	spBody->GetAllCells( cells,2); 
	int numberOfCells = cells.Size();
	cout <<"==> Number of face: " << numberOfCells << endl;
	for (int ifa=1 ; ifa<=numberOfCells ; ifa++)
	{
		pTessellator->AddFace((CATFace *)(cells[ifa]));
	}
	//Run the CATCellTessellator
	pTessellator->Run();



	//CATISpecObject_var spLine;
	// For every face.
	for(int i=1;i<=numberOfCells;i++) 
	{
		cout << "==> Face: " << i << endl;
		// for each face, retrieve the tessellation results.
		CATFace * piFace = (CATFace*) cells[i];
		if( NULL == piFace )
		{
			return E_FAIL;
		}
		//Get the result.
		CATBoolean isPlanar;
		CATTessPointIter *    pVertices  = NULL;
		CATTessStripeIter *   pStrips    = NULL;
		CATTessFanIter *      pFans      = NULL;
		CATTessPolyIter *     pPolygons  = NULL;
		CATTessTrianIter *    pTriangles = NULL;
		short side;
		pTessellator->GetFace(piFace,isPlanar,&pVertices,&pStrips,&pFans,&pPolygons,&pTriangles,&side);		//获得的点都是局部坐标，按需转成全局

		if (NULL==pVertices)
		{
			continue;
		}

		//获取所有点和法向的基础信息
		float  (* aCoord)[3] = NULL;
		float  (* aNormal)[3] = NULL;
		int     * aNuPts     = NULL;
		CATLONG32 nbp = 0;

		nbp=pVertices->GetNbPoint();
		aCoord = new float[nbp][3];
		aNormal = new float[nbp][3];
		pVertices->GetPointXyzAll(aCoord);	//获得所有的离散点
		pVertices->GetPointNorAll(aNormal);	//获得每个离散点处的法向

		//2维列表变成1维列表
		int verticesArraySize=3*nbp;
		int normalsArraySize=3*nbp;

		cout << "  ==> Total point: " << nbp << endl;

		float *vertices=new float[verticesArraySize];
		float *normals=new float[normalsArraySize];
		for(int j=0;j<nbp;j++) {
			for(int k=0;k<3;k++) {
				vertices[3*j+k] = aCoord[j][k];
				normals[3*j+k] = aNormal[j][k];
			}
		}

		//   循环画点
		int iNum = 0;
		while (0 == (pVertices->IsExhausted()))
		{
			const double *aCoord = pVertices->GetPointXyz();
			////模型上画出虚拟点，CATISO高亮
			//DumITempPoint *piTempPoint = NULL;
			//HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
			//if (SUCCEEDED(rc) && piTempPoint != NULL)
			//{
			//	piTempPoint->SetDatas(&CATMathPoint(*aCoord,*(aCoord+1),*(aCoord+2)));
			//	_pISO->AddElement(piTempPoint);
			//}
			double dX=*aCoord;
			double dY=*(aCoord+1);
			double dZ=*(aCoord+2);
			CATMathPoint pt(dX,dY,dZ);
			int iX=(int)dX;
			int iY=(int)dY;
			int iZ=(int)dZ;

			if (dX<0) iX--;
			if (dY<0) iY--;
			if (dZ<0) iZ--;
			
			//XY
			IsMaxOrMinPoint(pt,iomapXY[iX][iY],2);

			//XZ
			IsMaxOrMinPoint(pt,iomapXZ[iX][iZ],1);

			//YZ
			IsMaxOrMinPoint(pt,iomapYZ[iY][iZ],0);

			pVertices->GoToNext();
			iNum++;
		}

		cout<<"==> Vertex number: "<<iNum<<endl;


		if (NULL!=aCoord)
		{
			delete []aCoord;
		}
		if (NULL!=aNormal)
		{
			delete []aNormal;
		}
	}
	delete pTessellator;   pTessellator = NULL;

	return rc;
}

//判断输入点在某个方向上是不是最大或者最小的极值点，是的话就加入列表，并更新原来的列表，使得最多只有2个点
//每个列表中，极小值在前，极大值在后
//iDir,2表示Z向，1表示Y向，0表示X向
CATBoolean TestEnvelopeCmd::IsMaxOrMinPoint(CATMathPoint iPt,vector<CATMathPoint> &iolstPt,int iDir)
{
	int iIndexCompare=iDir;
	double arrPt[3]={iPt.GetX(),iPt.GetY(),iPt.GetZ()};
	double dValueComp=arrPt[iIndexCompare];
	//
	if (iolstPt.size()==0)
	{
		iolstPt.push_back(iPt);
		return TRUE;
	}
	else if (iolstPt.size()==1)
	{
		CATMathPoint ptA=iolstPt[0];
		double arrPtA[3]={ptA.GetX(),ptA.GetY(),ptA.GetZ()};
		double dValueA=arrPtA[iIndexCompare];

		if (dValueComp-dValueA>0.001)
		{
			iolstPt.push_back(iPt);
			return TRUE;
		}
		else if (dValueComp-dValueA<-0.001)
		{
			iolstPt.insert(iolstPt.begin(),iPt);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		CATMathPoint ptA=iolstPt[0];
		double arrPtA[3]={ptA.GetX(),ptA.GetY(),ptA.GetZ()};
		double dValueA=arrPtA[iIndexCompare];

		CATMathPoint ptB=iolstPt[1];
		double arrPtB[3]={ptB.GetX(),ptB.GetY(),ptB.GetZ()};
		double dValueB=arrPtB[iIndexCompare];

		if (dValueComp-dValueA<-0.001)	//输入比原来的小，则代替并删掉原来的
		{
			iolstPt.erase(iolstPt.begin());
			iolstPt.insert(iolstPt.begin(),iPt);
			return TRUE;
		}
		else if (dValueComp-dValueB>0.001)	//输入的比原来大的大，则代替并删掉原来的
		{
			iolstPt.pop_back();
			iolstPt.push_back(iPt);
			return TRUE;
		}
		else
		{
			return FALSE;
		}

	}

}

HRESULT TestEnvelopeCmd::CreateTranslateTransformation(double iDistance,CATMathVector iDir,double iStep,
													   map<int,map<int,vector<CATMathPoint>>> &iomapPt,
													   int iIndexDir)
{
	HRESULT rc=S_OK;

	iDir.Normalize();

	//
	vector<vector<CATMathPoint>> vecLstPtTrans;

	int iRepeatNum=iDistance/iStep;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*iStep*iDir);
		vector<CATMathPoint> lstPtTrans;
		
		map<int,map<int,vector<CATMathPoint>>>::iterator itrOuter;
		map<int,vector<CATMathPoint>>::iterator itrInner;
		for (itrOuter=iomapPt.begin();itrOuter!=iomapPt.end();itrOuter++)
		{
			for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
			{
				vector<CATMathPoint> lstPt = itrInner->second;
				for (int j=0;j<lstPt.size();j++)
				{
					CATMathPoint pt=lstPt[j];
					pt=trans*pt;
					lstPtTrans.push_back(pt);
				}
			}
		}
		vecLstPtTrans.push_back(lstPtTrans);
	}

	double iRepeatLast=fmod(iDistance,iStep);
	if (iRepeatLast>0.01)
	{
		CATMathTransformation trans(iDistance*iDir);

		vector<CATMathPoint> lstPtTrans;

		map<int,map<int,vector<CATMathPoint>>>::iterator itrOuter;
		map<int,vector<CATMathPoint>>::iterator itrInner;
		for (itrOuter=iomapPt.begin();itrOuter!=iomapPt.end();itrOuter++)
		{
			for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
			{
				vector<CATMathPoint> lstPt = itrInner->second;
				for (int j=0;j<lstPt.size();j++)
				{
					CATMathPoint pt=lstPt[j];
					pt=trans*pt;
					lstPtTrans.push_back(pt);
				}
			}
		}
		vecLstPtTrans.push_back(lstPtTrans);
	}

	//
	for (int i=0;i<vecLstPtTrans.size();i++)
	{
		for (int j=0;j<vecLstPtTrans[i].size();j++)
		{
			CATMathPoint pt=vecLstPtTrans[i][j];
			double dX=pt.GetX();
			double dY=pt.GetY();
			double dZ=pt.GetZ();

			int iX=(int)(dX);
			int iY=(int)(dY);
			int iZ=(int)(dZ);

			if (dX<0) iX--;
			if (dY<0) iY--;
			if (dZ<0) iZ--;

			int iIndexOuter,iIndexInner;
			if (iIndexDir==2)
			{
				iIndexOuter=iX;
				iIndexInner=iY;
			}
			else if (iIndexDir==1)
			{
				iIndexOuter=iX;
				iIndexInner=iZ;
			}
			else
			{
				iIndexOuter=iY;
				iIndexInner=iZ;
			}
			IsMaxOrMinPoint(pt,iomapPt[iIndexOuter][iIndexInner],iIndexDir);
		}
	}

	return rc;
}

void TestEnvelopeCmd::DrawTempPoints(map<int,map<int,vector<CATMathPoint>>> imapPt)
{
	map<int,map<int,vector<CATMathPoint>>>::iterator itrOuter;
	map<int,vector<CATMathPoint>>::iterator itrInner;
	for (itrOuter=imapPt.begin();itrOuter!=imapPt.end();itrOuter++)
	{
		for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
		{
			vector<CATMathPoint> lstPt = itrInner->second;
			for (int j=0;j<lstPt.size();j++)
			{
				CATMathPoint pt=lstPt[j];

				DumITempPoint *piTempPoint = NULL;
				HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
				if (SUCCEEDED(rc) && piTempPoint != NULL)
				{
					piTempPoint->SetDatas(&pt);
					_pISO->AddElement(piTempPoint);
				}
			}
		}
	}
}

HRESULT TestEnvelopeCmd::PointsSaveAsCgr(map<int,map<int,vector<CATMathPoint>>> imapPtXY,
										 map<int,map<int,vector<CATMathPoint>>> imapPtXZ,
										 map<int,map<int,vector<CATMathPoint>>> imapPtYZ,
										 CATUnicodeString istrSavePath)
{
	HRESULT rc=S_OK;

	//
	CATDocument *pDocNew=NULL;
	rc=CATDocumentServices::New("Part",pDocNew);
	if (FAILED(rc)||pDocNew==NULL)
	{
		return E_FAIL;
	}
	CATIProduct_var spiProdNew=NULL_var;
	spiProdNew=GetRootProductFromDoc(pDocNew);
	if (spiProdNew==NULL_var)
	{
		return E_FAIL;
	}

	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(spiProdNew,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}

	//挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(spiProdNew,"Test",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}

	CATTime iStartTime = CATTime::GetCurrentLocalTime();


	int iCount=0;
	map<int,map<int,vector<CATMathPoint>>>::iterator itrOuter;
	map<int,vector<CATMathPoint>>::iterator itrInner;
	for (itrOuter=imapPtXY.begin();itrOuter!=imapPtXY.end();itrOuter++)
	{
		for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
		{
			vector<CATMathPoint> lstPt = itrInner->second;
			for (int j=0;j<lstPt.size();j++)
			{
				CATMathPoint pt=lstPt[j];
				CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,pt.GetX(),pt.GetY(),pt.GetZ());
				if (pBodyPt==NULL)
				{
					continue;
				}
				CATISpecObject_var spiSpecObj=NULL_var;
				_pGeneralCls->InsertObjOnTree(spiProdNew,spiGeoSet,"Point",pBodyPt,spiSpecObj);
				iCount++;
			}
		}
	}

	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> MaxXY Points Count: "<<iCount<<"  ======> MapXY Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;


	iCount=0;
	for (itrOuter=imapPtXZ.begin();itrOuter!=imapPtXZ.end();itrOuter++)
	{
		for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
		{
			vector<CATMathPoint> lstPt = itrInner->second;
			for (int j=0;j<lstPt.size();j++)
			{
				CATMathPoint pt=lstPt[j];
				CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,pt.GetX(),pt.GetY(),pt.GetZ());
				if (pBodyPt==NULL)
				{
					continue;
				}
				CATISpecObject_var spiSpecObj=NULL_var;
				_pGeneralCls->InsertObjOnTree(spiProdNew,spiGeoSet,"Point",pBodyPt,spiSpecObj);
				iCount++;
			}
		}
	}

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();
	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> MaxXZ Points Count: "<<iCount<<"  ======> MapXZ Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;

	iCount=0;
	for (itrOuter=imapPtYZ.begin();itrOuter!=imapPtYZ.end();itrOuter++)
	{
		for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
		{
			vector<CATMathPoint> lstPt = itrInner->second;
			for (int j=0;j<lstPt.size();j++)
			{
				CATMathPoint pt=lstPt[j];
				CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,pt.GetX(),pt.GetY(),pt.GetZ());
				if (pBodyPt==NULL)
				{
					continue;
				}
				CATISpecObject_var spiSpecObj=NULL_var;
				_pGeneralCls->InsertObjOnTree(spiProdNew,spiGeoSet,"Point",pBodyPt,spiSpecObj);
				iCount++;
			}
		}
	}

	CATTime iEndTime3 = CATTime::GetCurrentLocalTime();
	iTimeSpan=iEndTime3-iEndTime2;
	cout<<"======> MaxYZ Points Count: "<<iCount<<"  ======> MapYZ Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;

	spiGeoSet->Update();

	//另存为cgr
	rc=CATDocumentServices::SaveAs(*pDocNew,istrSavePath);

	if (FAILED(rc))
	{
		return E_FAIL;
	}

	return rc;
}

CATIProduct_var TestEnvelopeCmd::GetRootProductFromDoc( CATDocument * ipDocument )
{
	HRESULT rc = E_FAIL;
	CATIProduct_var spRootProduct = NULL_var;
	if ( NULL != ipDocument)
	{
		//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
		CATIDocRoots *piDocRootsOnDoc = NULL;
		HRESULT rc = ipDocument->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
		if (FAILED(rc))
		{
			return NULL_var;
		}
		CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
		CATIProduct_var spRootProduct = NULL_var;
		if (pRootProducts->Size())
		{
			spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
		}

		piDocRootsOnDoc->Release();

		return spRootProduct;
	}
	return NULL_var;
}

void TestEnvelopeCmd::PointsOutputTxt(map<int,map<int,vector<CATMathPoint>>> imapPt,
									  CATUnicodeString istrSavePath)
{
	ofstream outputFile(istrSavePath.ConvertToChar(),ios::app);
	
	map<int,map<int,vector<CATMathPoint>>>::iterator itrOuter;
	map<int,vector<CATMathPoint>>::iterator itrInner;
	for (itrOuter=imapPt.begin();itrOuter!=imapPt.end();itrOuter++)
	{
		for (itrInner=itrOuter->second.begin();itrInner!=itrOuter->second.end();itrInner++)
		{
			vector<CATMathPoint> lstPt = itrInner->second;
			for (int j=0;j<lstPt.size();j++)
			{
				CATMathPoint pt=lstPt[j];
				double dX=pt.GetX();
				double dY=pt.GetY();
				double dZ=pt.GetZ();
				strstream ssX,ssY,ssZ;
				string strX,strY,strZ;
				ssX<<dX;	ssX>>strX;
				ssY<<dY;	ssY>>strY;
				ssZ<<dZ;	ssZ>>strZ;

				string strMsg=strX+","+strY+","+strZ;
				outputFile<<strMsg<<"\n";

			}
		}
	}
	outputFile.close();
}


//////////////////////////////////////////////////////////////////////////
/////////////////使用DMU创建包络///////////////
//////////////////////////////////////////////////////////////////////////
HRESULT TestEnvelopeCmd::CreateMechanism(vector<CATIProduct_var> ilstProd,CATBaseUnknown_var ispBUSel1,CATIProduct_var ispiProdSel1,CATBaseUnknown_var ispBUSel2,CATIProduct_var ispiProdSel2)
{
	HRESULT rc=S_OK;
	//
	if (ispBUSel1==NULL_var)
	{
		return E_FAIL;
	}
	CATISpecObject_var spiSpecSel1=NULL_var;
	CATISpecObject_var spiSpecSel2=NULL_var;
	spiSpecSel1=_pGeneralCls->GetSpecFromBaseUnknownFunc(ispBUSel1);
	if (spiSpecSel1==NULL_var)
	{
		return E_FAIL;
	}
	//
	int iType=-1;	//旋转或者移动
	if (ispBUSel2==NULL_var)
	{
		iType=0;	//旋转
	}
	else	
	{
		iType=1;	//移动

		spiSpecSel2=_pGeneralCls->GetSpecFromBaseUnknownFunc(ispBUSel2);
		if (spiSpecSel2==NULL_var)
		{
			return E_FAIL;
		}
	}


	//把所选元素拷贝到两个新建的part内

	
	return rc;
}

CATIProduct_var TestEnvelopeCmd::CreateNewPart()
{
	CATDocument *pDocNew=NULL;
	HRESULT rc=CATDocumentServices::New("Part",pDocNew);
	if (FAILED(rc)||pDocNew==NULL)
	{
		return NULL_var;
	}
	CATIProduct_var spiProdNew=NULL_var;
	spiProdNew=GetRootProductFromDoc(pDocNew);
	
	return spiProdNew;
}
//刷新视图和模型树
void TestEnvelopeCmd::RefreshViewTree(const CATISpecObject_var spObject)
{
	if(spObject==NULL_var)
		return;
	//Update the 3D view
	CATModify ModifyEvent(spObject);
	CATIModelEvents_var spEvents = spObject;
	if(spEvents!=NULL_var)
		spEvents -> Dispatch (ModifyEvent);

	//Update the graph view tree
	CATIRedrawEvent_var spRedraw = spObject;
	if(spRedraw!=NULL_var)
		spRedraw -> Redraw();
}


CATISpecObject_var TestEnvelopeCmd::CopyAndPasteSpecObj(CATIProduct_var spPrdSrc, CATISpecObject_var spiSpecSrc, CATIProduct_var spPrdTgt, CATISpecObject_var spSpecTgt, CATBoolean bLink)
{
	CATMmrInterPartCopy* ptCATMmrInterPartCopy = NULL;
	ptCATMmrInterPartCopy = new CATMmrInterPartCopy (spiSpecSrc, spSpecTgt);
	ptCATMmrInterPartCopy->SetSourceInstance(spPrdSrc);
	ptCATMmrInterPartCopy->SetTargetInstance(spPrdTgt);
	//ptCATMmrInterPartCopy->SetImportApplicativeId(guidApplicative);
	ptCATMmrInterPartCopy->SetLinkMode(bLink);

	//int iMode=0; // Copy attribute and color
	//ptCATMmrInterPartCopy->SetAttributeMode(iMode);

	CATUnicodeString ErrorMsg;
	HRESULT rc = ptCATMmrInterPartCopy->Run(&ErrorMsg);
	if ( FAILED(rc) ){
		cout <<"  CopyWithLink: " << ErrorMsg.CastToCharPtr() << endl;
		return NULL_var;
	}

	CATISpecObject_var spCopyResult = NULL_var;
	rc = ptCATMmrInterPartCopy->GetResult(spCopyResult);
	if ( FAILED(rc) || (NULL_var == spCopyResult) )
		return NULL_var;

	delete ptCATMmrInterPartCopy;
	ptCATMmrInterPartCopy = NULL;

	return spCopyResult;
}

HRESULT TestEnvelopeCmd::CreateNewPartForMechanism(CATIProduct_var ispiProdRoot,
												   CATBaseUnknown_var ispBUSel1,
												   CATIProduct_var ispiProdSel1,
												   CATBaseUnknown_var ispBUSel2,
												   CATIProduct_var ispiProdSel2,
												   CATIProduct_var &ospiProdInstNew,
												   CATISpecObject_var &ospiSpecLine,
												   CATISpecObject_var &ospiSpecPlane)
{
	HRESULT rc=S_OK;
	//新建空的part，挂在root下
	CATIProduct_var spiProdNew=CreateNewPart();
	if (spiProdNew==NULL_var)
	{
		return E_FAIL;
	}
	CATIProduct_var spiProdInstNew=ispiProdRoot->AddProduct(spiProdNew);
	if (spiProdInstNew==NULL_var)
	{
		return E_FAIL;
	}
	RefreshViewTree(ispiProdRoot);

	//创建工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(spiProdInstNew,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return E_FAIL;
	}

	//创建GeoSet
	CATISpecObject_var spiSpecGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(spiProdInstNew,"Mechanism",spiSpecGeoSet);
	if (FAILED(rc)||spiSpecGeoSet==NULL_var)
	{
		return E_FAIL;
	}
	
	//
	CATISpecObject_var spiSpecLine=NULL_var;
	CATISpecObject_var spiSpecPlane=NULL_var;

	if (ispBUSel2==NULL_var)	//只有一个元素，说明是选的轴线，旋转操作
	{
		CATIMeasurableLine_var spiMeasurableLine=ispBUSel1;
		if (spiMeasurableLine==NULL_var)
		{
			return E_FAIL;
		}
		CATMathPoint ptOrigin;
		CATMathVector dirLine;
		rc=spiMeasurableLine->GetOrigin(ptOrigin);
		if (FAILED(rc))
		{
			return E_FAIL;
		}
		rc=spiMeasurableLine->GetDirection(dirLine);
		if (FAILED(rc))
		{
			return E_FAIL;
		}
		//
		CATMathTransformation transAbs=_pGeneralCls->GetAbsTransformation(ispiProdSel1);
		ptOrigin=transAbs*ptOrigin;
		dirLine=transAbs*dirLine;
		CATMathPlane mathPlane(ptOrigin,dirLine);

		//
		CATBody *pBodyPt=CATCreateTopPointXYZ(pGeoFactory,topdata,ptOrigin.GetX(),ptOrigin.GetY(),ptOrigin.GetZ());
		if (pBodyPt==NULL)
		{
			return E_FAIL;
		}
		CATBody *pBodyLine=CATCreateTopLineFromDirection(pGeoFactory,topdata,pBodyPt,dirLine,20);
		if (pBodyLine==NULL)
		{
			return E_FAIL;
		}
		CATBody *pBodyPlane=NULL;
		CreatePlaneBody(pGeoFactory,topdata,mathPlane,pBodyPlane);
		if (pBodyPlane==NULL)
		{
			return E_FAIL;
		}
		//
		rc=_pGeneralCls->InsertObjOnTree(spiProdInstNew,spiSpecGeoSet,"Line",pBodyLine,spiSpecLine);
		rc=_pGeneralCls->InsertObjOnTree(spiProdInstNew,spiSpecGeoSet,"Plane",pBodyPlane,spiSpecPlane);
		if (spiSpecLine==NULL_var||spiSpecPlane==NULL_var)
		{
			return E_FAIL;
		}
		//
	}
	else
	{
		CATIMeasurablePoint_var spiMeasurablePt1=ispBUSel1;
		CATIMeasurablePoint_var spiMeasurablePt2=ispBUSel2;
		if (spiMeasurablePt1==NULL_var||spiMeasurablePt2==NULL_var)
		{
			return E_FAIL;
		}
		CATMathPoint pt1,pt2;
		rc=spiMeasurablePt1->GetPoint(pt1);
		if (FAILED(rc))
		{
			return E_FAIL;
		}
		rc=spiMeasurablePt2->GetPoint(pt2);
		if (FAILED(rc))
		{
			return E_FAIL;
		}
		//
		CATMathTransformation transAbs1=_pGeneralCls->GetAbsTransformation(ispiProdSel1);
		CATMathTransformation transAbs2=_pGeneralCls->GetAbsTransformation(ispiProdSel2);
		pt1=transAbs1*pt1;
		pt2=transAbs2*pt2;
		if (pt1.DistanceTo(pt2)<=0.001)
		{
			return E_FAIL;
		}
		CATMathVector dirLine=pt2-pt1;
		CATMathPlane mathPlane(pt1,dirLine);
		//
		CATBody *pBodyPt=CATCreateTopPointXYZ(pGeoFactory,topdata,pt1.GetX(),pt1.GetY(),pt1.GetZ());
		if (pBodyPt==NULL)
		{
			return E_FAIL;
		}
		CATBody *pBodyLine=CATCreateTopLineFromDirection(pGeoFactory,topdata,pBodyPt,dirLine,20);
		if (pBodyLine==NULL)
		{
			return E_FAIL;
		}

	}

	//
	ospiSpecLine=spiSpecLine;
	ospiSpecPlane=spiSpecPlane;

	return rc;
}