// COPYRIGHT Dassault Systemes 2020
//===================================================================
//
// TestEnvelopeCmd.cpp
// The state chart based command: TestEnvelopeCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  May 2020  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestEnvelopeCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( TestEnvelopeCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestEnvelopeCmd::TestEnvelopeCmd() :
  CATStateCommand ("TestEnvelopeCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
,_pGeneralCls(NULL)
,_pEditor(NULL)
,_pHSO(NULL)
,_pISO(NULL)
{
	_pDlg = NULL;
	_pDlg = new TestEnvelopeDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

	_pSelAAgent = NULL;
	_pSelBAgent = NULL;
	_pSelAFieldAgent = NULL;
	_pSelBFieldAgent = NULL;

	_pGeneralCls = new GeneralClass();

	_pEditor = CATFrmEditor::GetCurrentEditor();

	if (NULL!=_pEditor)
	{
		_pHSO = _pEditor->GetHSO();
		_pISO = _pEditor->GetISO();
	}
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestEnvelopeCmd::~TestEnvelopeCmd()
{
	if (_pDlg != NULL)
	{
		_pDlg->RequestDelayedDestruction();
		_pDlg = NULL;
	}

	if (_pGeneralCls != NULL)
	{
		delete _pGeneralCls;
		_pGeneralCls = NULL;
	}

	_pEditor = NULL;

	_pHSO->Empty();
	_pHSO = NULL;

	_pISO->Empty();
	_pISO = NULL;

	if (_pSelAAgent != NULL)
	{
		_pSelAAgent->RequestDelayedDestruction();
		_pSelAAgent = NULL;
	}

	if (_pSelAFieldAgent != NULL)
	{
		_pSelAFieldAgent->RequestDelayedDestruction();
		_pSelAFieldAgent = NULL;
	}

	if (_pSelBAgent != NULL)
	{
		_pSelBAgent->RequestDelayedDestruction();
		_pSelBAgent = NULL;
	}

	if (_pSelBFieldAgent != NULL)
	{
		_pSelBFieldAgent->RequestDelayedDestruction();
		_pSelBFieldAgent = NULL;
	}
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestEnvelopeCmd::BuildGraph()
{
	//对话框
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionOK4,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaAPPLYNotification(),
		(CATCommandMethod)&TestEnvelopeCmd::ActionOK3,
		NULL);
	//
	_pSelAFieldAgent = new CATDialogAgent("Select A");
	_pSelAFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjA(),
		_pDlg->GetSelectorListObjA()->GetListSelectNotification());
	//
	_pSelBFieldAgent = new CATDialogAgent("Select B");
	_pSelBFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjB(),
		_pDlg->GetSelectorListObjB()->GetListSelectNotification());
	//选择Point
	_pSelAAgent = new CATFeatureImportAgent("Select A");
	//_pPointAgent->AddElementType("CATIGSMPoint");
	_pSelAAgent->AddElementType("CATIMechanicalTool");
	_pSelAAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//选择Solid
	//_pSelBAgent = new CATFeatureImportAgent("Select B");
	_pSelBAgent = new CATPathElementAgent("Select B");
	//_pSelBAgent->AddElementType("CATRep");
	//_pSelBAgent->AddElementType("CATIMfMonoDimResult");
	//_pSolidAgent->AddElementType("CATSurface");
	//_pSolidAgent->AddElementType("CATIMechanicalTool");
	//_pSolidAgent->AddElementType("CATIMfBiDimResult");
	_pSelBAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//
	CATDialogState *pSelAState = GetInitialState("Select A");
	pSelAState->AddDialogAgent(_pSelAAgent);
	pSelAState->AddDialogAgent(_pSelAFieldAgent);
	pSelAState->AddDialogAgent(_pSelBFieldAgent);

	CATDialogState *pSelBState = AddDialogState("Select B");
	pSelBState->AddDialogAgent(_pSelBAgent);
	pSelBState->AddDialogAgent(_pSelAFieldAgent);
	pSelBState->AddDialogAgent(_pSelBFieldAgent);

	//
	AddTransition(pSelAState,pSelAState,
		IsOutputSetCondition(_pSelAAgent),
		Action((ActionMethod)& TestEnvelopeCmd::selectObjAFunc));

	AddTransition(pSelBState,pSelBState,
		IsOutputSetCondition(_pSelBAgent),
		Action((ActionMethod)& TestEnvelopeCmd::selectObjBFunc));

	AddTransition(pSelAState,pSelBState,
		IsOutputSetCondition(_pSelBFieldAgent),
		Action((ActionMethod)& TestEnvelopeCmd::TransToSelectB));

	AddTransition(pSelBState,pSelAState,
		IsOutputSetCondition(_pSelAFieldAgent),
		Action((ActionMethod)& TestEnvelopeCmd::TransToSelectA));
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestEnvelopeCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}
CATBoolean TestEnvelopeCmd::ActionExit(void * data)
{
	RequestDelayedDestruction();
	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK(void * data)
{
	/*
	HRESULT rc=this->CreateEnvelope(_spBUSelectA,_spBUSelectB);
	if (FAILED(rc))
	{
		return FALSE;
	}
	*/

	HRESULT rc=this->TestCgr();

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK2(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();
	
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}

	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	CATMathLine mathAxis(pt1,pt2);

	vector<CATMathPoint> lstVerticesAll;
	rc = this->CreateRotationTransformation(lstVertices,30,mathAxis,0.5,lstVerticesAll);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesAll Size: "<<lstVerticesAll.size()<<endl;

	//
	vector<CATMathPoint> lstVerticesOuter;
	rc=this->CalculateOuterPoints(lstVerticesAll,1);
	if (FAILED(rc))
	{
		return FALSE;
	}
	lstVerticesOuter.swap(lstVerticesAll);
	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	//
	//模型上画出虚拟点，CATISO高亮
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		DumITempPoint *piTempPoint = NULL;
		HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
		if (SUCCEEDED(rc) && piTempPoint != NULL)
		{
			piTempPoint->SetDatas(&mathPt);
			_pISO->AddElement(piTempPoint);
		}
	}

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK3(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}
	cout<<"lstVertices Size: "<<lstVertices.size()<<endl;

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"TestOG",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVertices.size();i++)
	{
		CATMathPoint mathPt=lstVertices[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	this->CalculateOuterPoints(lstVertices,0.5);
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"TestOGFilter",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	for (int i=0;i<lstVertices.size();i++)
	{
		CATMathPoint mathPt=lstVertices[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	/*
	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	CATMathLine mathAxis(pt1,pt2);

	vector<CATMathPoint> lstVerticesOuter;
	rc = this->CreateRotationTransformationUpdate(lstVertices,30,mathAxis,0.5,lstVerticesOuter);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	////模型上画出虚拟点，CATISO高亮
	//for (int i=0;i<lstVerticesOuter.size();i++)
	//{
	//	CATMathPoint mathPt=lstVerticesOuter[i];
	//	DumITempPoint *piTempPoint = NULL;
	//	HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
	//	if (SUCCEEDED(rc) && piTempPoint != NULL)
	//	{
	//		piTempPoint->SetDatas(&mathPt);
	//		_pISO->AddElement(piTempPoint);
	//	}
	//}

	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Rotate Calculate Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	*/

	return TRUE;
}

CATBoolean TestEnvelopeCmd::ActionOK4(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	if (NULL!=_pISO) _pISO->Empty();

	CATTime iStartTime = CATTime::GetCurrentLocalTime();
	//
	vector<CATMathPoint> lstVertices;
	HRESULT rc=this->CreateTessellation(_spBUSelectA,lstVertices);
	if (FAILED(rc))
	{
		return FALSE;
	}
	cout<<"lstVertices Size: "<<lstVertices.size()<<endl;

	//
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(_spBUSelectB,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return FALSE;
	}
	//CATMathLine mathAxis(pt1,pt2);
	CATMathVector mathDir=pt1-pt2;

	vector<CATMathPoint> lstVerticesOuter;
	rc = this->CreateTranslateTransformation(lstVertices,30,mathDir,0.5,lstVerticesOuter);
	if (FAILED(rc))
	{
		return FALSE;
	}

	cout<<"lstVerticesOuter Size: "<<lstVerticesOuter.size()<<endl;

	////模型上画出虚拟点，CATISO高亮
	//for (int i=0;i<lstVerticesOuter.size();i++)
	//{
	//	CATMathPoint mathPt=lstVerticesOuter[i];
	//	DumITempPoint *piTempPoint = NULL;
	//	HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
	//	if (SUCCEEDED(rc) && piTempPoint != NULL)
	//	{
	//		piTempPoint->SetDatas(&mathPt);
	//		_pISO->AddElement(piTempPoint);
	//	}
	//}

	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> Translate Calculation Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	//点挂模型树
	CATISpecObject_var spiGeoSet=NULL_var;
	rc=_pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test",spiGeoSet);
	if (FAILED(rc)||spiGeoSet==NULL_var)
	{
		return FALSE;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	for (int i=0;i<lstVerticesOuter.size();i++)
	{
		CATMathPoint mathPt=lstVerticesOuter[i];
		CATBody *pBodyPt =::CATCreateTopPointXYZ( pGeoFactory,topdata,mathPt.GetX(),mathPt.GetY(),mathPt.GetZ());
		if (pBodyPt==NULL)
		{
			continue;
		}
		CATISpecObject_var spiSpecObj=NULL_var;
		_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiGeoSet,"pt",pBodyPt,spiSpecObj);
	}
	spiGeoSet->Update();

	CATTime iEndTime2 = CATTime::GetCurrentLocalTime();

	iTimeSpan=iEndTime2-iEndTime;
	cout<<"======> SpecObj Run Time: "<<iTimeSpan.ConvertToString("%M:%S");

	return TRUE;
}

void TestEnvelopeCmd::selectObjAFunc(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	_pGeneralCls->TransferSelectToBU(_pSelAAgent,pBUSelect,spiProdSelect);
	if (pBUSelect == NULL || spiProdSelect == NULL_var)
	{
		_pSelAAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjA()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjA()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjA()->SetSelect(&iTabRow,1);
	//
	_spBUSelectA = pBUSelect;
	_spiProdSelA = spiProdSelect;

	_pGeneralCls->SetHighlight(pBUSelect);
	//
	_pSelAAgent->InitializeAcquisition();
}

void TestEnvelopeCmd::selectObjBFunc(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	//_pGeneralCls->TransferSelectToBU(_pSelBAgent,pBUSelect,spiProdSelect);

	pBUSelect = _pSelBAgent->GetElementValue();
	if (pBUSelect == NULL /*|| spiProdSelect == NULL_var*/)
	{
		_pSelBAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjB()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjB()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjB()->SetSelect(&iTabRow,1);

	//
	_spBUSelectB = pBUSelect;
	_spiProdSelB = spiProdSelect;

	_pGeneralCls->SetHighlight(pBUSelect);
	//
	_pSelBAgent->InitializeAcquisition();
}

void TestEnvelopeCmd::TransToSelectA(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjB()->ClearSelect();
}

void TestEnvelopeCmd::TransToSelectB(void * data)
{
	if (_pHSO!=NULL)
	{
		_pHSO->Empty();
	}
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjA()->ClearSelect();
}

HRESULT TestEnvelopeCmd::CreateEnvelope(CATBaseUnknown_var ispBUObj,CATBaseUnknown_var ispBUCurve)
{
	HRESULT rc=S_OK;
	//
	if (ispBUObj==NULL_var||ispBUCurve==NULL_var)
	{
		return E_FAIL;
	}
	//获取工厂
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata
	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=_pGeneralCls->GetProductGeoFactoryAndPrtCont(_spiProdSelA,ospiCont);
	if (topdata == NULL || pGeoFactory == NULL)
	{
		return FALSE;
	}
	//
	CATBody_var spBodyOrigin = _pGeneralCls->GetBodyFromFeature(ispBUObj);
	if (spBodyOrigin==NULL_var)
	{
		return E_FAIL;
	}
	CATMathPoint pt1,pt2;
	_pGeneralCls->GetPointFromCurve(ispBUCurve,pt1,pt2);
	if (pt1.DistanceTo(pt2)<=0.01)
	{
		return E_FAIL;
	}
	CATMathLine mathAxis(pt1,pt2);

	//包络实体
	CATBody_var spBodyAssy=spBodyOrigin;
	for (int i=1;i<=10;i++)
	{
		//旋转
		CATDynTransformation *pDynTranf = CATCreateDynTransformation(pGeoFactory,topdata,spBodyOrigin);
		if (pDynTranf==NULL)
		{
			continue;
		}
		CATAngle angleRotate = i*CATPI/9;
		pDynTranf->SetRotation(angleRotate,mathAxis);
		CATTry
		{
			pDynTranf->Run();
		}
		CATCatch(CATMfErrUpdate , pUpdateError)
		{
			continue;
		}
		CATCatch(CATError , error)
		{
			delete pDynTranf;
			pDynTranf = NULL;
			CATReturnError(error);
			continue;
		}
		CATEndTry;

		CATBody *pBodyTransfResult = pDynTranf->GetResult();
		delete pDynTranf;
		pDynTranf = NULL;
		if (pBodyTransfResult == NULL)
		{
			continue;
		}
		
		//布尔合并
		CATDynBoolean *pDynBool=CATCreateDynBoolean(pGeoFactory,topdata,CATBoolUnion,spBodyAssy,pBodyTransfResult);
		if (pDynBool==NULL)
		{
			continue;
		}
		CATTry
		{
			pDynBool->Run();
		}
		CATCatch(CATMfErrUpdate , pUpdateError)
		{
			continue;
		}
		CATCatch(CATError , error)
		{
			delete pDynBool;
			pDynBool = NULL;
			CATReturnError(error);
			continue;
		}
		CATEndTry;

		CATBody *pBodyResult = pDynBool->GetResult();
		delete pDynBool;
		pDynBool = NULL;
		if (pBodyResult == NULL)
		{
			continue;
		}
		spBodyAssy=pBodyResult;
	}

	//
	CATLISTP(CATCell) lstCells;
	spBodyAssy->GetAllCells(lstCells,2);
	CATLISTP(CATBody) lstBody;
	for (int i=1;i<=lstCells.Size();i++)
	{
		CATCell_var spCell=lstCells[i];
		if (spCell==NULL_var)
		{
			continue;
		}
		CATBody *pBodyCell=NULL;
		pBodyCell=_pGeneralCls->CreateBodyFromCell(pGeoFactory,spCell,2);
		if (pBodyCell!=NULL)
		{
			lstBody.Append(pBodyCell);
		}
	}

	if (lstBody.Size()>0)
	{
		//把这些body组合起来
		ListPOfCATBody * HListOfCurve=&lstBody;
		CATHybAssemble * pHybAssemble=CATCreateTopAssemble(pGeoFactory, topdata, HListOfCurve);
		if (pHybAssemble==NULL)
		{
			return FALSE;
		}
		//
		pHybAssemble->Run();
		CATBody*pResultBody= pHybAssemble->GetResult();
		delete pHybAssemble; 
		pHybAssemble = NULL;

		if (pResultBody==NULL)
		{
			return E_FAIL;
		}

		//挂模型树
		CATISpecObject_var spiSpecGeoSet=NULL_var;
		rc = _pGeneralCls->CreateNewGeoSet(_spiProdSelA,"Test_Envelope",spiSpecGeoSet);
		if (FAILED(rc)||spiSpecGeoSet==NULL_var)
		{
			return E_FAIL;
		}
		CATISpecObject_var spiSpecEnvelope=NULL_var;
		rc=_pGeneralCls->InsertObjOnTree(_spiProdSelA,spiSpecGeoSet,"Envelope",pResultBody,spiSpecEnvelope);
		if (FAILED(rc)||spiSpecEnvelope==NULL_var)
		{
			return E_FAIL;
		}
		spiSpecEnvelope->Update();
	}
	

	return rc;
}

HRESULT TestEnvelopeCmd::TestCgr()
{
	HRESULT rc=S_OK;

	//
	//CATRep *pRep=NULL;
	//CATFrmEditor *pEditor=CATFrmEditor::GetCurrentEditor();
	//CATRepPath repPath;
	//rc=this->GetRepFromBU(_spBUSelectB,pEditor,&pRep,repPath);
	//if (FAILED(rc))
	//{
	//	return E_FAIL;
	//}

	//
	/*
	CATI3DGeoVisu_var spGeoVis = _spBUSelectB;
	if (spGeoVis==NULL_var)
	{
		return E_FAIL;
	}
	CATRep *pRep=spGeoVis->BuildRep();
	if( pRep == NULL ) {
		cout << "==> Get CATRep error !" << endl;
		return E_FAIL;
	}
	//CAT3DRep *p3DRep = (CAT3DRep*)pRep;
	//if (p3DRep==NULL)
	//{
	//	return E_FAIL;
	//}
	CAT3DBagRep *p3DBagRep = new CAT3DBagRep();
	p3DBagRep->AddChild(*pRep);
	const CAT4x4Matrix *pMatrix=p3DBagRep->GetMatrix();
	CATMathVectorf oU,oV,oW;
	CATMathPointf oT;
	pMatrix->GetComponents(oU,oV,oW,oT);
	*/

	//CATIMeasurableCurve_var spiMeasurableCrv=_spBUSelectB;	//该接口只能适用于没有坐标变换过的对象
	//if (spiMeasurableCrv==NULL_var)
	//{
	//	return E_FAIL;
	//}
	CATIMeasurableInContext_var spiMeasurableInContext=_spBUSelectB;	//必须用context来获取点，这样可以包含坐标变换
	if (spiMeasurableInContext==NULL_var)
	{
		return E_FAIL;
	}

	CATMathPoint ptStart,ptMid,ptEnd;
	rc=spiMeasurableInContext->GetPointsOnCurve(ptStart,ptMid,ptEnd);

	return rc;
}

HRESULT TestEnvelopeCmd::GetRepFromBU(CATBaseUnknown_var ispBU,CATRep **opRep)
{
	HRESULT rc = S_OK;
	//特征化
	CATISpecObject_var spiSpecObj = _pGeneralCls->GetSpecFromBaseUnknownFunc(ispBU);
	if (spiSpecObj==NULL_var)
	{
		return E_FAIL;
	}
	//CATVisManager * pVisuManager = CATVisManager::GetVisManager();
	//CATModelIdentificator Ident(spiSpecObj);
	//CAT3DRep * pRepChild = (CAT3DRep *) pVisuManager->BuildRep(Ident);

	//CATIVisu *piVisu = NULL;
	//rc = spiSpecObj->QueryInterface(IID_CATIVisu,(void**)&piVisu);
	//if (FAILED(rc)||piVisu==NULL)
	//{
	//	return E_FAIL;
	//}
	//CATRep *pRep = piVisu->BuildRep();

	CATI3DGeoVisu *pi3DGeoVisu = NULL;
	rc = spiSpecObj->QueryInterface(IID_CATI3DGeoVisu,(void**)&pi3DGeoVisu);
	if (FAILED(rc)||pi3DGeoVisu==NULL)
	{
		return E_FAIL;
	}
	CATRep *pRep = pi3DGeoVisu->GiveRep();

	*opRep = pRep;
	//
	return E_FAIL;
}

HRESULT TestEnvelopeCmd::Get3DRep(CATPathElement *iObject, CAT3DRep ** oRep,CATRepPath &oRepPath)
{
	HRESULT rc = E_FAIL ;

	if ( NULL == oRep ) return rc ;

	CATVisManager * pVisManager = CATVisManager::GetVisManager();

	if ( NULL != pVisManager )
	{
		CATViewpoint *pViewpoint=NULL;
		CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
		if ( NULL !=  pLayout )
		{
			CATFrmWindow * pWindow = pLayout->GetCurrentWindow();
			if ( NULL !=  pWindow )
			{
				CATViewer * pViewer = pWindow->GetViewer();

				if ( NULL != pViewer )
				{
					CAT3DViewpoint & Main3DViewpoint = pViewer->GetMain3DViewpoint();
					pViewpoint = (CATViewpoint*)(& Main3DViewpoint);
				}
			}
		}

		// Generation of the rep
		pVisManager->GenerateRepPathFromPathElement(*iObject,pViewpoint,oRepPath);

		if ( oRepPath.Size() >= 1 )
		{                   
			//*oRep = (CAT3DRep*) oRepPath[oRepPath.Size()-1];
			*oRep = (CAT3DRep*) oRepPath[0];
			if ( NULL != *oRep )
			{
				rc = S_OK ;
			}
		}
	}
	return rc ;
}

HRESULT TestEnvelopeCmd::GetRepFromBU(CATBaseUnknown *ipBU, CATFrmEditor *ipEditor,CATRep ** oRep,CATRepPath &oRepPath)
{
	HRESULT rc = E_FAIL ;

	if ( NULL == oRep ) return rc ;

	CATVisManager * pVisManager = CATVisManager::GetVisManager();

	if ( NULL != pVisManager )
	{
		CATViewpoint *pViewpoint=NULL;
		CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
		if ( NULL !=  pLayout )
		{
			CATFrmWindow * pWindow = pLayout->GetCurrentWindow();
			if ( NULL !=  pWindow )
			{
				CATViewer * pViewer = pWindow->GetViewer();

				if ( NULL != pViewer )
				{
					CAT3DViewpoint & Main3DViewpoint = pViewer->GetMain3DViewpoint();
					pViewpoint = (CATViewpoint*)(& Main3DViewpoint);
				}
			}
		}

		CATPathElement *iObject = NULL;
		rc = GetPathElemFromBU(ipBU,ipEditor,iObject);
		if (FAILED(rc)||iObject==NULL)
		{
			return E_FAIL;
		}

		CATUnicodeString strPathElem = "";
		_pGeneralCls->PathElementString(iObject,strPathElem);
		cout<<"==> PathElement: "<<strPathElem<<endl;
		cout<<"==> PathElement Num: "<<iObject->GetSize()<<endl;

		// Generation of the rep
		pVisManager->GenerateRepPathFromPathElement(*iObject,pViewpoint,oRepPath);

		if ( oRepPath.Size() >= 1 )
		{                   
			CATUnicodeString strPathName = "";
			int NumOfPath = oRepPath.Size();
			for(int i=0;i<NumOfPath;i++)  
			{
				CATRep *pRep =(CATRep*)(oRepPath)[i];
				if (pRep == NULL)
				{
					continue;
				}
				CATBaseUnknown *pElt = NULL; 
				rc = pRep->QueryInterface(IID_CATBaseUnknown,(void**)&pElt);
				if(pElt != NULL) 
				{
					CATIAlias *piAlias = NULL;
					rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
					if(SUCCEEDED(rc) && piAlias!=NULL)
					{
						CATUnicodeString Name = piAlias->GetAlias();
						strPathName.Append(Name) ;
						if(i<=(NumOfPath-2)) 
						{
							strPathName.Append("/");
						}
						piAlias->Release(); piAlias = NULL;
					}
				}
				if (pElt == ipBU)
				{
					*oRep = (CATRep*) oRepPath[i];
				}
			}

			cout<<"==> RepPath: "<<strPathName<<endl;
			
			//*oRep = (CAT3DRep*) oRepPath[oRepPath.Size()-1];
			//*oRep = (CAT3DRep*) oRepPath[0];
			if ( NULL != *oRep )
			{
				rc = S_OK ;
			}
		}
	}
	return rc ;
}

HRESULT TestEnvelopeCmd::GetPathElemFromBU(CATBaseUnknown_var ispBU,CATFrmEditor *ipEditor,CATPathElement *&opPathElem)
{

	CATIBuildPath *piBuildPath = NULL;
	HRESULT rc = ispBU->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
	if (SUCCEEDED(rc))
	{
		CATPathElement context = ipEditor->GetUIActiveObject();
		CATPathElement *pPathElement = NULL;

		rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
		if (pPathElement != NULL)
		{
			opPathElem = pPathElement;
			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT TestEnvelopeCmd::CreateTessellation(CATBaseUnknown_var ispBUElement,vector<CATMathPoint> &olstVertices)
{
	HRESULT rc = S_OK;
	//
	if (ispBUElement==NULL_var)
	{
		return E_FAIL;
	}
	CATBody_var spBody = _pGeneralCls->GetBodyFromFeature(ispBUElement);
	if (spBody==NULL_var)
	{
		return E_FAIL;
	}
	CAT3DBagRep* pBagRep = new CAT3DBagRep();
	//Tessellate the body
	double iStep   = 1;
	double sag=	10;
	//CATBodyTessellator * pTessellator = new CATBodyTessellator(spBody,sag);
	CATCellTessellator * pTessellator = new CATCellTessellator(sag);
	if( NULL == pTessellator ) 
	{
		cout << "==> Create CATCellTessellator error !" << endl;
		return E_FAIL;
	}
	//Set the step to the CATCellTessellator.
	pTessellator->SetStep(iStep);
	cout << "==> The step is: " << iStep << endl;

	//Add face to the CATCellTessellator.
	CATLISTP(CATCell) cells;
	spBody->GetAllCells( cells,2); 
	int numberOfCells = cells.Size();
	cout <<"==> Number of face: " << numberOfCells << endl;
	for (int ifa=1 ; ifa<=numberOfCells ; ifa++)
	{
		pTessellator->AddFace((CATFace *)(cells[ifa]));
	}
	//Run the CATCellTessellator
	pTessellator->Run();



	//CATISpecObject_var spLine;
	// For every face.
	for(int i=1;i<=numberOfCells;i++) 
	{
		cout << "==> Face: " << i << endl;
		// for each face, retrieve the tessellation results.
		CATFace * piFace = (CATFace*) cells[i];
		if( NULL == piFace )
		{
			return E_FAIL;
		}
		//Get the result.
		CATBoolean isPlanar;
		CATTessPointIter *    pVertices  = NULL;
		CATTessStripeIter *   pStrips    = NULL;
		CATTessFanIter *      pFans      = NULL;
		CATTessPolyIter *     pPolygons  = NULL;
		CATTessTrianIter *    pTriangles = NULL;
		short side;
		pTessellator->GetFace(piFace,isPlanar,&pVertices,&pStrips,&pFans,&pPolygons,&pTriangles,&side);		//获得的点都是局部坐标，按需转成全局

		if (NULL==pVertices)
		{
			continue;
		}

		//获取所有点和法向的基础信息
		float  (* aCoord)[3] = NULL;
		float  (* aNormal)[3] = NULL;
		int     * aNuPts     = NULL;
		CATLONG32 nbp = 0;

		nbp=pVertices->GetNbPoint();
		aCoord = new float[nbp][3];
		aNormal = new float[nbp][3];
		pVertices->GetPointXyzAll(aCoord);	//获得所有的离散点
		pVertices->GetPointNorAll(aNormal);	//获得每个离散点处的法向

		//2维列表变成1维列表
		int verticesArraySize=3*nbp;
		int normalsArraySize=3*nbp;

		cout << "  ==> Total point: " << nbp << endl;

		float *vertices=new float[verticesArraySize];
		float *normals=new float[normalsArraySize];
		for(int j=0;j<nbp;j++) {
			for(int k=0;k<3;k++) {
				vertices[3*j+k] = aCoord[j][k];
				normals[3*j+k] = aNormal[j][k];
			}
		}

		//   循环画点
		int iNum = 0;
		while (0 == (pVertices->IsExhausted()))
		{
			const double *aCoord = pVertices->GetPointXyz();
			////模型上画出虚拟点，CATISO高亮
			//DumITempPoint *piTempPoint = NULL;
			//HRESULT rc = ::CATInstantiateComponent("DumTempPointComp", IID_DumITempPoint, (void**)&piTempPoint);
			//if (SUCCEEDED(rc) && piTempPoint != NULL)
			//{
			//	piTempPoint->SetDatas(&CATMathPoint(*aCoord,*(aCoord+1),*(aCoord+2)));
			//	_pISO->AddElement(piTempPoint);
			//}

			olstVertices.push_back(CATMathPoint(*aCoord,*(aCoord+1),*(aCoord+2)));

			pVertices->GoToNext();
			iNum++;
		}

		cout<<"==> Vertex number: "<<iNum<<endl;
		

		if (NULL!=aCoord)
		{
			delete []aCoord;
		}
		if (NULL!=aNormal)
		{
			delete []aNormal;
		}
	}
	delete pTessellator;   pTessellator = NULL;

	return rc;
}

HRESULT TestEnvelopeCmd::CreateRotationTransformation(vector<CATMathPoint> ilstVertices,double iDeg,CATMathLine iAxis,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDeg/iStep;
	CATAngle angleStep=iStep*CATPI/180;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*angleStep,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
	}

	double iRepeatLast=fmod(iDeg,iStep);
	if (iRepeatLast>0.01)
	{
		CATAngle angleLast=iDeg*CATPI/180;
		CATMathTransformation trans(angleLast,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
	}

	return rc;
}

HRESULT TestEnvelopeCmd::CreateRotationTransformationUpdate(vector<CATMathPoint> ilstVertices,double iDeg,CATMathLine iAxis,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	//先把输入点集过滤一下
	this->CalculateOuterPoints(ilstVertices,1);

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDeg/iStep;
	CATAngle angleStep=iStep*CATPI/180;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*angleStep,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,1);
	}

	double iRepeatLast=fmod(iDeg,iStep);
	if (iRepeatLast>0.01)
	{
		CATAngle angleLast=iDeg*CATPI/180;
		CATMathTransformation trans(angleLast,iAxis);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,1);
	}

	return rc;
}

HRESULT TestEnvelopeCmd::CreateTranslateTransformation(vector<CATMathPoint> ilstVertices,double iDistance,CATMathVector iDir,double iStep,vector<CATMathPoint> &olstVerticesAll)
{
	HRESULT rc=S_OK;

	iDir.Normalize();

	//先把输入点集过滤一下
	this->CalculateOuterPoints(ilstVertices,0.4);

	olstVerticesAll.insert(olstVerticesAll.end(),ilstVertices.begin(),ilstVertices.end());
	//
	int iRepeatNum=iDistance/iStep;
	for (int i=1;i<=iRepeatNum;i++)
	{
		CATMathTransformation trans(i*iStep*iDir);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,0.4);
	}

	double iRepeatLast=fmod(iDistance,iStep);
	if (iRepeatLast>0.01)
	{
		CATMathTransformation trans(iDistance*iDir);
		for (int j=0;j<ilstVertices.size();j++)
		{
			CATMathPoint ptOrigin=ilstVertices[j];
			CATMathPoint ptTrans=trans*ptOrigin;
			olstVerticesAll.push_back(ptTrans);
		}
		this->CalculateOuterPoints(olstVerticesAll,0.4);
	}

	return rc;
}

HRESULT TestEnvelopeCmd::CalculateOuterPoints(vector<CATMathPoint> &iolstVerticesAll,double iStep)
{
	HRESULT rc=S_OK;

	vector<CATMathPoint> lstPtOuter;
	//
	CATMathBox mathBox;
	for (int i=0;i<iolstVerticesAll.size();i++)
	{
		CATMathPoint pt=iolstVerticesAll[i];
		mathBox.AddInside(pt);
	}
	double oXMin,oXMax,oYMin,oYMax,oZMin,oZMax;
	mathBox.GetExtremities(oXMin,oXMax,oYMin,oYMax,oZMin,oZMax);

	//
	int iNumRepeatX=(oXMax-oXMin)/iStep;
	int iNumRepeatY=(oYMax-oYMin)/iStep;
	int iNumRepeatZ=(oZMax-oZMin)/iStep;

	double iStepX=(oXMax-oXMin)/iNumRepeatX;
	double iStepY=(oYMax-oYMin)/iNumRepeatY;
	double iStepZ=(oZMax-oZMin)/iNumRepeatZ;

	vector<CATMathPoint> lstPtFilter;
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());
	//XY面内判断Z向极值
	vector<CATMathPoint> lstPtAll;
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());
	for (int i=1;i<=iNumRepeatX;i++)
	{
		double dblFirstDirMin=oXMin+((i-1)*iStepX);
		double dblFirstDirMax=oXMin+(i*iStepX);
		if (i==1)			dblFirstDirMin=oXMin-0.5;
		if (i==iNumRepeatX) dblFirstDirMax=oXMax+0.5;

		for (int j=1;j<=iNumRepeatY;j++)
		{
			double dblSecondDirMin=oYMin+((j-1)*iStepY);
			double dblSecondDirMax=oYMin+(j*iStepY);
			if (j==1)			dblSecondDirMin=oYMin-0.5;
			if (j==iNumRepeatY) dblSecondDirMax=oYMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"Z",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);
			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}

	//int iFinish=0;
	//int iRepeatFirst=1;
	//int iRepeatSecond=1;
	//while(iFinish==0)
	//{
	//	
	//}

	//XZ面内判断Y向极值
	lstPtAll.swap(vector<CATMathPoint>());
	//lstPtAll.insert(lstPtAll.end(),lstPtFilter.begin(),lstPtFilter.end());
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	lstPtFilter.swap(vector<CATMathPoint>());
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	for (int i=1;i<=iNumRepeatX;i++)
	{
		double dblFirstDirMin=oXMin+((i-1)*iStepX);
		double dblFirstDirMax=oXMin+(i*iStepX);
		if (i==1)			dblFirstDirMin=oXMin-0.5;
		if (i==iNumRepeatX) dblFirstDirMax=oXMax+0.5;
		
		for (int j=1;j<=iNumRepeatZ;j++)
		{
			double dblSecondDirMin=oZMin+((j-1)*iStepZ);
			double dblSecondDirMax=oZMin+(j*iStepZ);
			if (j==1)			dblSecondDirMin=oZMin-0.5;
			if (j==iNumRepeatZ) dblSecondDirMax=oZMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"Y",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);

			//if (FALSE==this->IsOccur(oPtMin,lstPtOuter))	olstVerticesOuter.push_back(oPtMin);
			//if (FALSE==this->IsOccur(oPtMax,lstPtOuter))	olstVerticesOuter.push_back(oPtMax);

			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}
	//YZ面内判断X向极值
	lstPtAll.swap(vector<CATMathPoint>());
	//lstPtAll.insert(lstPtAll.end(),lstPtFilter.begin(),lstPtFilter.end());
	lstPtAll.insert(lstPtAll.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	lstPtFilter.swap(vector<CATMathPoint>());
	lstPtFilter.insert(lstPtFilter.end(),iolstVerticesAll.begin(),iolstVerticesAll.end());

	for (int i=1;i<=iNumRepeatY;i++)
	{
		double dblFirstDirMin=oYMin+((i-1)*iStepY);
		double dblFirstDirMax=oYMin+(i*iStepY);
		if (i==1)			dblFirstDirMin=oYMin-0.5;
		if (i==iNumRepeatY) dblFirstDirMax=oYMax+0.5;
		
		for (int j=1;j<=iNumRepeatZ;j++)
		{

			double dblSecondDirMin=oZMin+((j-1)*iStepZ);
			double dblSecondDirMax=oZMin+(j*iStepZ);
			if (j==1)			dblSecondDirMin=oZMin-0.5;
			if (j==iNumRepeatZ) dblSecondDirMax=oZMax+0.5;

			CATMathPoint oPtMin,oPtMax;
			CATBoolean bFindMin,bFindMax;
			this->GetExtremePointsInEachArea(lstPtAll,dblFirstDirMin,dblFirstDirMax,dblSecondDirMin,dblSecondDirMax,"X",oPtMin,oPtMax,bFindMin,bFindMax,lstPtFilter);

			//if (FALSE==this->IsOccur(oPtMin,olstVerticesOuter))	olstVerticesOuter.push_back(oPtMin);
			//if (FALSE==this->IsOccur(oPtMax,olstVerticesOuter)) olstVerticesOuter.push_back(oPtMax);

			if (bFindMin) lstPtOuter.push_back(oPtMin);
			if (bFindMax) lstPtOuter.push_back(oPtMax);
		}
	}

	//
	iolstVerticesAll.swap(lstPtOuter);

	return rc;
}

void TestEnvelopeCmd::GetExtremePointsInEachArea(vector<CATMathPoint> &iolstPt,double iFirstDirMin,double iFirstDirMax,double iSecondDirMin,double iSecondDirMax,
												 CATUnicodeString istrThirdDir,CATMathPoint &oPtMin,CATMathPoint &oPtMax,CATBoolean &obFindMin,CATBoolean &obFindMax,
												 vector<CATMathPoint> &iolstPtFilter)
{
	int iFirst,iSecond,iThird;
	if (istrThirdDir=="Z")
	{
		iFirst=0;
		iSecond=1;
		iThird=2;
	}
	else if (istrThirdDir=="Y")
	{
		iFirst=0;
		iSecond=2;
		iThird=1;
	}
	else
	{
		iFirst=1;
		iSecond=2;
		iThird=0;
	}
	//
	double dblMax=-DBL_MAX;
	double dblMin=DBL_MAX;
	obFindMin=FALSE;
	obFindMax=FALSE;
	int iIndexMin=0;
	int iIndexMax=0;
	for (int i=0;i<iolstPt.size();i++)
	{
		CATMathPoint ptCurrent=iolstPt[i];
		double arrPt[3]={ptCurrent.GetX(),ptCurrent.GetY(),ptCurrent.GetZ()};

		double dFirstDir=arrPt[iFirst];
		double dSecondDir=arrPt[iSecond];
		double dThirdDir=arrPt[iThird];
		if (dFirstDir<iFirstDirMin||dFirstDir>iFirstDirMax||dSecondDir<iSecondDirMin||dSecondDir>iSecondDirMax)	//点没在范围内，直接判断下一个
		{
			continue;
		}
		if (dThirdDir>dblMax)
		{
			dblMax=dThirdDir;
			oPtMax=ptCurrent;
			obFindMax=TRUE;
			iIndexMax=i;
		}
		if (dThirdDir<dblMin)
		{
			dblMin=dThirdDir;
			oPtMin=ptCurrent;
			obFindMin=TRUE;
			iIndexMin=i;
		}
		//把在当前范围内的点从列表中删除，这样在下次计算别的范围时，这些点就不会包含进去了，减少循环量
		iolstPt.erase(iolstPt.begin()+i);
		i--;

	}

	//如果有极值点，则在输出的列表中删除该极值点，用该列表传给下个方向求极值
	if (TRUE==obFindMax)
	{
		if (iIndexMax==iIndexMin)
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
		} 
		else if (iIndexMax>iIndexMin)
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMin);
		}
		else
		{
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMin);
			iolstPtFilter.erase(iolstPtFilter.begin()+iIndexMax);
		}

	}
}

CATBoolean TestEnvelopeCmd::IsOccur(CATMathPoint iPt,vector<CATMathPoint> ilstPt)
{
	for (int i=0;i<ilstPt.size();i++)
	{
		CATMathPoint iPtTemp=ilstPt[i];
		if (iPt.DistanceTo(iPtTemp)<=0.001)
		{
			return TRUE;
		}
	}
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

HRESULT TestEnvelopeCmd::CreateEdgeTessellation(CATBody *ipBodyCurve,vector<CATMathPoint> &olstVertices)
{
	HRESULT rc = S_OK;
	//
	if (ipBodyCurve==NULL)
	{
		return E_FAIL;
	}
	//Tessellate the body
	double iStep   = 1;
	double sag=	10;
	//CATBodyTessellator * pTessellator = new CATBodyTessellator(spBody,sag);
	CATCellTessellator * pTessellator = new CATCellTessellator(sag);
	if( NULL == pTessellator ) 
	{
		cout << "==> Create CATCellTessellator error !" << endl;
		return E_FAIL;
	}
	//Set the step to the CATCellTessellator.
	pTessellator->SetStep(iStep);
	cout << "==> The step is: " << iStep << endl;

	//Add face to the CATCellTessellator.
	CATLISTP(CATCell) cells;
	ipBodyCurve->GetAllCells( cells,1); 
	int numberOfCells = cells.Size();
	cout <<"==> Number of edge: " << numberOfCells << endl;
	for (int ifa=1 ; ifa<=numberOfCells ; ifa++)
	{
		pTessellator->AddEdge((CATEdge *)(cells[ifa]));
	}
	//Run the CATCellTessellator
	pTessellator->Run();



	//CATISpecObject_var spLine;
	// For every face.
	for(int i=1;i<=numberOfCells;i++) 
	{
		cout << "==> Edge: " << i << endl;
		// for each face, retrieve the tessellation results.
		CATEdge * pEdge = (CATEdge*) cells[i];
		if( NULL == pEdge )
		{
			return E_FAIL;
		}
		//Get the result.
		CATLONG32 oNumberOfPoints;
		double *oPointData=NULL;
		pTessellator->GetEdge(pEdge,oNumberOfPoints,&oPointData);		//获得的点都是局部坐标，按需转成全局

		if (NULL==oPointData||oNumberOfPoints==0)
		{
			continue;
		}
		cout << "  ==> Total point: " << oNumberOfPoints << endl;

		//   循环画点

		for (int i=1;i<=oNumberOfPoints;i++)
		{
			double dX=oPointData[3*(i-1)];
			double dY=oPointData[3*(i-1)+1];
			double dZ=oPointData[3*(i-1)+2];

			olstVertices.push_back(CATMathPoint(dX,dY,dZ));
		}

		cout<<"==> Vertex number: "<<oNumberOfPoints<<endl;
	}
	delete pTessellator;   pTessellator = NULL;

	return rc;
}

//滚球法求点集最外轮廓，考虑凹包，在平行于XY的平面内计算
HRESULT TestEnvelopeCmd::CalculateOuterHull(vector<CATMathPoint> ilstPtAll, double idR,vector<CATMathPoint> &olstPtConcaveHull)
{
	HRESULT rc=S_OK;

	//删除重复点集
	for (int i=0;i<ilstPtAll.size();i++)
	{
		CATMathPoint ptForward=ilstPtAll[i];
		for (int j=ilstPtAll.size()-1;j>i;j--)
		{
			CATMathPoint ptBackward=ilstPtAll[j];
			if (ptBackward.DistanceTo(ptForward)<=0.001)
			{
				ilstPtAll.erase(ilstPtAll.begin()+j);
			}
		}
	}

	//先找到y值最小的点
	double dYmin = DBL_MAX;
	int iIndexMin = 0;
	for (int i=0;i<ilstPtAll.size();i++)
	{
		CATMathPoint mathPt = ilstPtAll[i];
		double dYcoord = mathPt.GetY();
		if (dYcoord<dYmin)
		{
			dYmin = dYcoord;
			iIndexMin = i;
		}
		else if (dYcoord==dYmin)	//如果y坐标相同，取x坐标小的
		{
			if (mathPt.GetX()<ilstPtAll[iIndexMin].GetX())
			{
				dYmin = dYcoord;
				iIndexMin = i;
			}
		}
	}

	CATMathPoint2D mathPtFirst = ilstPtAll[iIndexMin];
	ilstPtAll.erase(ilstPtAll.begin()+iIndexMin);

	//
	//把该最小点和其他所有点分别做向量，按照和x轴正向的cos值从大到小排列
	vector<double> vecCosValue;
	for (int i=0;i<ilstPtAll.size();i++)	
	{
		CATMathVector dirCurrent = ilstPtAll[i]-mathPtFirst;

		double dCos = dirCurrent.GetX()/(sqrt(dirCurrent.GetX()*dirCurrent.GetX()+dirCurrent.GetY()*dirCurrent.GetY()));

		vecCosValue.push_back(dCos);
	}
	for (int i=0;i<ilstPtAll.size();i++)
	{
		for (int j=0;j<ilstPtAll.size()-1;j++)
		{
			if (i==j)
			{
				continue;
			}
			double dCrossCurrent = vecCosValue[j];
			double dCrossNext = vecCosValue[j+1];
			if (dCrossCurrent<dCrossNext)
			{
				swap(vecCosValue[j],vecCosValue[j+1]);
				swap(ilstPtAll[j],ilstPtAll[j+1]);
			}
		}
	}
	//把头两个点加入列表，从第三个点开始循环判断
	CATMathPoint2D mathPtSecond = ilstPtAll[0];
	olstPtConcaveHull.push_back(mathPtFirst);
	olstPtConcaveHull.push_back(mathPtSecond);
	ilstPtAll.erase(ilstPtAll.begin());

	//
	for ()
	{
	}

	return rc;
}

CATBoolean TestEnvelopeCmd::IsFindNextHullPoint(CATMathPoint iPtCurrent,double idR,vector<CATMathPoint> ilstPtRest,CATMathPoint &oPtNext)
{

}