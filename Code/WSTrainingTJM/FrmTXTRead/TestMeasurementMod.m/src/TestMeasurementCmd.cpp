// COPYRIGHT Dassault Systemes 2020
//===================================================================
//
// TestMeasurementCmd.cpp
// The state chart based command: TestMeasurementCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  May 2020  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestMeasurementCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"

CATCreateClass( TestMeasurementCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestMeasurementCmd::TestMeasurementCmd() :
  CATStateCommand ("TestMeasurementCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
,_pGeneralCls(NULL)
,_pEditor(NULL)
,_pHSO(NULL)
{
	_pDlg = NULL;
	_pDlg = new TestMeasurementDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

	_pSelAAgent = NULL;
	_pSelBAgent = NULL;
	_pSelAFieldAgent = NULL;
	_pSelBFieldAgent = NULL;

	_pGeneralCls = new GeneralClass();

	_pEditor = CATFrmEditor::GetCurrentEditor();

	if (NULL!=_pEditor)
	{
		_pHSO = _pEditor->GetHSO();
	}
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestMeasurementCmd::~TestMeasurementCmd()
{
	if (_pDlg != NULL)
	{
		_pDlg->RequestDelayedDestruction();
		_pDlg = NULL;
	}

	if (_pGeneralCls != NULL)
	{
		delete _pGeneralCls;
		_pGeneralCls = NULL;
	}

	_pEditor = NULL;

	_pHSO->Empty();
	_pHSO = NULL;

	if (_pSelAAgent != NULL)
	{
		_pSelAAgent->RequestDelayedDestruction();
		_pSelAAgent = NULL;
	}

	if (_pSelAFieldAgent != NULL)
	{
		_pSelAFieldAgent->RequestDelayedDestruction();
		_pSelAFieldAgent = NULL;
	}

	if (_pSelBAgent != NULL)
	{
		_pSelBAgent->RequestDelayedDestruction();
		_pSelBAgent = NULL;
	}

	if (_pSelBFieldAgent != NULL)
	{
		_pSelBFieldAgent->RequestDelayedDestruction();
		_pSelBFieldAgent = NULL;
	}
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestMeasurementCmd::BuildGraph()
{
	//对话框
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&TestMeasurementCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&TestMeasurementCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&TestMeasurementCmd::ActionExit,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&TestMeasurementCmd::ActionOK3,
		NULL);
	//
	_pSelAFieldAgent = new CATDialogAgent("Select A");
	_pSelAFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjA(),
		_pDlg->GetSelectorListObjA()->GetListSelectNotification());
	//
	_pSelBFieldAgent = new CATDialogAgent("Select B");
	_pSelBFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListObjB(),
		_pDlg->GetSelectorListObjB()->GetListSelectNotification());
	//选择Point
	_pSelAAgent = new CATFeatureImportAgent("Select A");
	//_pPointAgent->AddElementType("CATIGSMPoint");
	_pSelAAgent->AddElementType("CATIProduct");
	_pSelAAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//选择Solid
	_pSelBAgent = new CATFeatureImportAgent("Select B");
	_pSelBAgent->AddElementType("CATIProduct");
	//_pSolidAgent->AddElementType("CATSurface");
	//_pSolidAgent->AddElementType("CATIMechanicalTool");
	//_pSolidAgent->AddElementType("CATIMfBiDimResult");
	_pSelBAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//
	CATDialogState *pSelAState = GetInitialState("Select A");
	pSelAState->AddDialogAgent(_pSelAAgent);
	pSelAState->AddDialogAgent(_pSelAFieldAgent);
	pSelAState->AddDialogAgent(_pSelBFieldAgent);

	CATDialogState *pSelBState = AddDialogState("Select B");
	pSelBState->AddDialogAgent(_pSelBAgent);
	pSelBState->AddDialogAgent(_pSelAFieldAgent);
	pSelBState->AddDialogAgent(_pSelBFieldAgent);

	//
	AddTransition(pSelAState,pSelAState,
		IsOutputSetCondition(_pSelAAgent),
		Action((ActionMethod)& TestMeasurementCmd::selectObjAFunc));

	AddTransition(pSelBState,pSelBState,
		IsOutputSetCondition(_pSelBAgent),
		Action((ActionMethod)& TestMeasurementCmd::selectObjBFunc));

	AddTransition(pSelAState,pSelBState,
		IsOutputSetCondition(_pSelBFieldAgent),
		Action((ActionMethod)& TestMeasurementCmd::TransToSelectB));

	AddTransition(pSelBState,pSelAState,
		IsOutputSetCondition(_pSelAFieldAgent),
		Action((ActionMethod)& TestMeasurementCmd::TransToSelectA));
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestMeasurementCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}

CATBoolean TestMeasurementCmd::ActionExit(void * data)
{
	RequestDelayedDestruction();
	return TRUE;
}

CATBoolean TestMeasurementCmd::ActionOK(void * data)
{
	CATMathPoint oPt1,oPt2;
	double oDist = 9999;

	HRESULT rc = this->GetMinDistanceByMeasure(_spBUSelectA,_spiProdSelA,_spBUSelectB,_spiProdSelB,oPt1,oPt2,oDist);

	cout<<"Min. Distance: "<<oDist<<endl;
	
	return TRUE;
}

void TestMeasurementCmd::selectObjAFunc(void * data)
{
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	_pGeneralCls->TransferSelectToBU(_pSelAAgent,pBUSelect,spiProdSelect);
	if (pBUSelect == NULL || spiProdSelect == NULL_var)
	{
		_pSelAAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjA()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjA()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjA()->SetSelect(&iTabRow,1);
	//
	_spBUSelectA = pBUSelect;
	_spiProdSelA = spiProdSelect;
	//
	_pSelAAgent->InitializeAcquisition();
}

void TestMeasurementCmd::selectObjBFunc(void * data)
{
	CATBaseUnknown *pBUSelect = NULL;
	CATIProduct_var spiProdSelect = NULL_var;
	_pGeneralCls->TransferSelectToBU(_pSelBAgent,pBUSelect,spiProdSelect);
	if (pBUSelect == NULL || spiProdSelect == NULL_var)
	{
		_pSelBAgent->InitializeAcquisition();
		return;
	}
	_pDlg->GetSelectorListObjB()->ClearLine();
	CATUnicodeString strAlias = _pGeneralCls->GetNameFromBaseUnknownFunc(pBUSelect);
	_pDlg->GetSelectorListObjB()->SetLine(strAlias,-1,CATDlgDataAdd);
	int iTabRow = 0;
	_pDlg->GetSelectorListObjB()->SetSelect(&iTabRow,1);

	//
	_spBUSelectB = pBUSelect;
	_spiProdSelB = spiProdSelect;
	//
	_pSelBAgent->InitializeAcquisition();
}

void TestMeasurementCmd::TransToSelectA(void * data)
{
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjB()->ClearSelect();
}

void TestMeasurementCmd::TransToSelectB(void * data)
{
	_pSelAFieldAgent->InitializeAcquisition();
	_pSelBFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListObjA()->ClearSelect();
}

//使用specobj的测量方法测量，带坐标变换
HRESULT TestMeasurementCmd::GetMinDistanceByMeasure(CATISpecObject_var ispiSpec1,CATIProduct_var ispiProd1,CATISpecObject_var ispiSpec2,CATIProduct_var ispiProd2,CATMathPoint &omathPt1,CATMathPoint &omathPt2,double &oDistance)
{
	CATIMeasurableInContext_var spMeasurableInContext1 = ispiSpec1;
	CATIMeasurableInContext_var spMeasurableInContext2 = ispiSpec2;
	CATIMeasurable_var spMeasurable2 = ispiSpec2;
	if (spMeasurableInContext1 == NULL_var) return E_FAIL;
	if (spMeasurableInContext2 == NULL_var) return E_FAIL;
	if (spMeasurable2 == NULL_var) return E_FAIL;

	CATMathTransformation transAbsObj1 = this->GetAbsTransformation(ispiProd1);
	CATMathTransformation transAbsObj2 = this->GetAbsTransformation(ispiProd2);
	CATMathAxis axisAbsObj1 = transAbsObj1 * CATMathOIJK;
	CATMathAxis axisAbsObj2 = transAbsObj2 * CATMathOIJK;

	CATMathTransformation transObj2ToObj1 = CATMathTransformation(axisAbsObj1,CATMathOIJK) * CATMathTransformation(CATMathOIJK,axisAbsObj2);

	//关键步骤，需要把测量元素1先set到全局坐标系下
	spMeasurableInContext1->SetAxisSystemOnMeasurable(axisAbsObj1);

	CATMathAxis ioAxis;
	double oMinDis = 9999.0;

	ioAxis = transObj2ToObj1 * axisAbsObj1;
	//spMeasurableInContext2->GetAxisSystemFromMeasurable(ioAxis);
	//
	//CATMathTransformation transAxis = this->GetMatrixTransformation(ispiProd2,ispiProd1);		//注意，该处坐标需要从2变换到1内
	//ioAxis = transAxis * ioAxis;

	//该处输入的坐标系是测量元素2的全局坐标系
	spMeasurableInContext1->MinimumDistance(spMeasurable2,axisAbsObj2,oMinDis,omathPt1,omathPt2);	//这里输出的两个点坐标都是在1内的坐标，后续可以按需变换到全局或变换到2
	oDistance = oMinDis;

	return S_OK;
}

CATMathTransformation TestMeasurementCmd::GetMatrixTransformation( CATISpecObject_var spSpecOne, CATISpecObject_var spSpecTwo )
{
	CATIMovable_var spiMovableOne(spSpecOne);
	if(spiMovableOne == NULL_var) 
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATIMovable_var spiMovableTwo(spSpecTwo);
	if(spiMovableTwo == NULL_var) {
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATMathTransformation pMathTrans = spiMovableOne->GetPosition(spiMovableTwo, CATPrd3D, TRUE);

	return pMathTrans;
}

CATMathTransformation TestMeasurementCmd::GetAbsTransformation( CATISpecObject_var ispSpecOne )
{
	CATMathTransformation pMathTrans;

	if(ispSpecOne==NULL_var)
		return pMathTrans;

	CATIMovable_var spiMovableOne(ispSpecOne);
	if(spiMovableOne == NULL_var) 
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	spiMovableOne->GetAbsPosition(pMathTrans);

	return pMathTrans;
}


//////////////////////////////////////////////////////////////////////////
////////////////////Test Clash////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
CATBoolean TestMeasurementCmd::ActionOK2(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	//
	HRESULT rc=CheckClash(_spBUSelectA,_spBUSelectB);
	if (FAILED(rc))
	{
		return FALSE;
	}
	
	return TRUE;
}
//检查干涉
HRESULT TestMeasurementCmd::CheckClash(CATIProduct_var ispiPrd1,CATIProduct_var ispiPrd2)
{
	HRESULT rc=S_OK;

	if (NULL_var==ispiPrd1||NULL_var==ispiPrd2)		return E_FAIL;

	CATFrmEditor * pEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pEditor)	return E_FAIL;

	CATDocument *pDoc = pEditor->GetDocument(); 
	if(NULL==pDoc) return E_FAIL;

	CATIClashFactory* piClashFact = NULL;//干涉factory
	CATIClashResult *piClashResult = NULL;//干涉结果
	CATIClash		*piClash = NULL;//碰撞
	CATListValCATBaseUnknown_var
		listPrd1,//产品集1
		listPrd2;//产品集2
	CATComputationCase modeComputation=CATComputationCaseClashContact;//计算间隙参数
	CATGroupMode modeGroup=CATGroupModeBetweenTwo;//分组类型
	rc=pDoc->QueryInterface(IID_CATIClashFactory,(void**)&piClashFact);//干涉factory赋值
	if (FAILED(rc) || NULL==piClashFact)
	{
		cout << "SJDIIBasic::GetClashFactory ==> QI CATIClashFactory Failed!" << endl;
		return E_FAIL;
	}

	rc=piClashFact->Create(piClash);//创建干涉
	if (FAILED(rc) || NULL==piClash)
	{
		cout << "SJDIIClash::ComputeAndAddToList ==> _piClashFact->Create Failed!" << endl;
		return E_FAIL;
	}

	//干涉设定
	listPrd1.Append(ispiPrd1);
	listPrd2.Append(ispiPrd2);
	rc=piClash->SetGroup(1, listPrd1);//第一组产品赋值
	rc=piClash->SetGroup(2, listPrd2);//第二组产品赋值
	rc=piClash->SetComputationCase(modeComputation);//设定计算间隙参数
	rc=piClash->SetClearance(0);//设定容差
	rc=piClash->SetGroupMode(modeGroup);//设定分组模式
	rc=piClash->Compute();//执行计算

	piClash->GetResult(piClashResult);//获取干涉结果
	if (FAILED(rc) || NULL==piClashResult)
	{
		cout << "SJDIIClash::ComputeAndAddToList ==> piClash->GetResult Failed!" << endl;
		return E_FAIL;
	}

	int iNumOfConflicts=0;//冲突个数
	piClashResult->CountConflicts(iNumOfConflicts);//获取干涉冲突的个数
	cout<<"num:"<<iNumOfConflicts<<endl;
	for (int i=0;i<iNumOfConflicts;i++)//循环获取冲突内信息
	{
		CATIConflict *piConflict = NULL;
		piClashResult->GetConflict(i,piConflict);//获取指定的冲突

		if (piConflict==NULL)	continue;

		CATResultType oResultType;
		piConflict->GetResultType(oResultType);
		if (CATTypeClash==oResultType)
		{
			double dValue;
			piConflict->GetValue(dValue);

			double *arrPt1 = new double[3];
			double *arrPt2 = new double[3];
			piConflict->GetMinOrExtractionVectorCoordinates(arrPt1,arrPt2);

			cout<<"==>"<<i<<" : "<<"Clash Value: "<<dValue<<endl;
			CATMathPoint pt1(arrPt1);
			CATMathPoint pt2(arrPt2);
			pt1.Dump();
			pt2.Dump();
			cout<<"---------------"<<endl;

			delete[]arrPt1; delete[]arrPt2;

		}
		piConflict->Release();piConflict=NULL;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////
///////////////////////二分法 测量干涉////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
CATBoolean TestMeasurementCmd::ActionOK3(void * data)
{
	if (NULL!=_pHSO) _pHSO->Empty();
	
	CATTime iStartTime = CATTime::GetCurrentLocalTime();

	vector<CATIProduct_var> lstProdA,lstProdB;
	lstProdA.push_back(_spiProdSelA);
	lstProdB.push_back(_spiProdSelB);
	CATMathVector dir(0,0,1);
	HRESULT rc=MeasureByDichotomy(lstProdA,lstProdB,dir);
	if (FAILED(rc))
	{
		return FALSE;
	}
	
	CATTime iEndTime = CATTime::GetCurrentLocalTime();

	CATTimeSpan iTimeSpan=iEndTime-iStartTime;
	cout<<"======> MeasureByDichotomy Run Time: "<<iTimeSpan.ConvertToString("%M:%S")<<endl;


	return TRUE;
}
HRESULT TestMeasurementCmd::MeasureByDichotomy(vector<CATIProduct_var> ilstProdA,vector<CATIProduct_var> ilstProdB,CATMathVector iDir)
{
	HRESULT rc=S_OK;

	//
	iDir.Normalize();
	double dValue=1000;	//移动初始值
	double dDistTarget=0.05;
	//先测量第一次
	CATMathPoint ptA,ptB;
	double dDist=-9999;
	MeasureMinDistAmongProducts(ilstProdA,ilstProdB,ptA,ptB,dDist);
	if (dDist>0.001)	//距离大于零，直接输出间隙
	{
		cout<<"====> Min Distance Among Products:  "<<dDist<<" mm"<<endl;
		return rc;
	} 
	else	//距离为零，说明可能是干涉，需要计算干涉值
	{
		int iStatusBefore=-1;		//-1代表干涉，1代表间隙
		CATMathTransformation transOrigin = _pGeneralCls->GetAbsTransformation(ilstProdA[0]);
		vector<CATIProduct_var> lstTransProdA;
		while(dDist<=0.001||dDist>dDistTarget)
		{
			lstTransProdA.swap(vector<CATIProduct_var>());
			for (int i=0;i<ilstProdA.size();i++)
			{
				CATIProduct_var spiProd=ilstProdA[i];
				CATMathTransformation transCurrent=_pGeneralCls->GetAbsTransformation(spiProd);
				CATMathVector posCurrent;
				transCurrent.GetVector(posCurrent);
				CATMathPoint ptMove=CATMathPoint(posCurrent.GetX(),posCurrent.GetY(),posCurrent.GetZ())+dValue*iDir;
				CATMathVector posMove(ptMove.GetX(),ptMove.GetY(),ptMove.GetZ());
				transCurrent.SetVector(posMove);

				CATIMovable_var spiMove=spiProd;
				if (spiMove==NULL_var)
				{
					continue;
				}
				spiMove->SetAbsPosition(transCurrent);

				//
				lstTransProdA.push_back(spiProd);
			}
			
			MeasureMinDistAmongProducts(lstTransProdA,ilstProdB,ptA,ptB,dDist);
			int iStatusCurrent=0;
			if (dDist<=0.001)
			{
				iStatusCurrent=-1;
			} 
			else
			{
				iStatusCurrent=1;
			}

			if (iStatusBefore*iStatusCurrent<0)	//前后2次状态不同，则下一次需要切换方向，同时value减半
			{
				iDir=-1*iDir;
				dValue=0.5*dValue;
			}

			iStatusBefore=iStatusCurrent;
		}

		CATMathTransformation transMove = _pGeneralCls->GetAbsTransformation(lstTransProdA[0]);

		CATMathVector dirOrigin,dirMove;
		transOrigin.GetVector(dirOrigin);
		transMove.GetVector(dirMove);
		CATMathVector dirDist=dirMove-dirOrigin;
		double dClash=sqrt(dirDist.GetX()*dirDist.GetX()+dirDist.GetY()*dirDist.GetY()+dirDist.GetZ()*dirDist.GetZ());

		cout<<"====> Min Clash Among Products:  "<<dClash<<" mm"<<endl;

	}
	
	return rc;
}

HRESULT TestMeasurementCmd::MeasureMinDistAmongProducts(vector<CATIProduct_var> ilstProdA,vector<CATIProduct_var> ilstProdB,CATMathPoint &oPtA,CATMathPoint &oPtB,double &odDistance)
{
	HRESULT rc=S_OK;
	//
	double dDistMin=DBL_MAX;
	for (int i=0;i<ilstProdA.size();i++)
	{
		CATIProduct_var spiProdA=ilstProdA[i];
		for (int j=0;j<ilstProdB.size();j++)
		{
			CATIProduct_var spiProdB=ilstProdB[j];

			//
			CATMathPoint ptA,ptB;
			double dDist=-9999;
			GetMinDistanceByMeasure(spiProdA,spiProdA,spiProdB,spiProdB,ptA,ptB,dDist);
			if (dDist==9999)
			{
				continue;
			}
			if (dDist<=0.001)
			{
				odDistance=0;
				return rc;
			}
			if (dDist<dDistMin)
			{
				dDistMin=dDist;
				odDistance=dDist;
				oPtA=ptA;
				oPtB=ptB;
			}
		}
	}
	return rc;
}