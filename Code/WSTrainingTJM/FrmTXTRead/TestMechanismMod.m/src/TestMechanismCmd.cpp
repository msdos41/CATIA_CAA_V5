// COPYRIGHT Dassault Systemes 2021
//===================================================================
//
// TestMechanismCmd.cpp
// The state chart based command: TestMechanismCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Nov 2021  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestMechanismCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( TestMechanismCmd);

#include "TestMechanismSubCmd.h"


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestMechanismCmd::TestMechanismCmd() :
  CATStateCommand ("TestMechanismCmd", CATDlgEngOneShot, CATCommandModeShared) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
,_pGeneralCls(NULL)
,_pDlg(NULL)
,_iClick(0)
{
	_pDlg = new TestMechanismDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

	_pGeneralCls = new GeneralClass();

	_pGeneralCls->GetRootProductUpdate(_spiProdRoot);
	if (_spiProdRoot==NULL_var)
	{
		RequestDelayedDestruction();
		return;
	}

	if (FAILED(SwitchWorkbench("DMUKinematics")))
	{
		cout<<"SwitchWorkbench failed........"<<endl;
		return;
	}

	//if (FAILED(CreateImportedMechanism()))
	//{
	//	RequestDelayedDestruction();
	//	return;
	//}

	//HANDLE Thread =(HANDLE)CreateThread(NULL,0,CatchCATIAWindow,NULL,0,0);
	//CloseHandle(Thread); 

	//TestMechanismSubCmd *pSubCmd = new TestMechanismSubCmd();
	//pSubCmd->RequestDelayedDestruction();


	//GetMechanisms(_spiProdRoot);

}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestMechanismCmd::~TestMechanismCmd()
{
	if (_pGeneralCls != NULL)
	{
		delete _pGeneralCls;
		_pGeneralCls = NULL;
	}
	
	if (_pDlg != NULL)
	{
		_pDlg->RequestDelayedDestruction();
		_pDlg = NULL;
	}

	//ActionPressEnter();
	//HANDLE Thread =(HANDLE)CreateThread(NULL,0,CatchCATIAWindow,NULL,0,0);
	//CloseHandle(Thread); 
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestMechanismCmd::BuildGraph()
{
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&TestMechanismCmd::ExitCmd,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&TestMechanismCmd::ExitCmd,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&TestMechanismCmd::ExitCmd,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&TestMechanismCmd::ActionOK,
		NULL);
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestMechanismCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}

CATBoolean TestMechanismCmd::ExitCmd(void * data)
{
	this->RequestDelayedDestruction();
	return TRUE;
}

CATBoolean TestMechanismCmd::ActionOK(void * data)
{
	_iClick=1;

	//if (FAILED(CreateImportedMechanism()))
	//{
	//	cout<<"CreateImportedMechanism failed.........."<<endl;
	//	return FALSE;
	//}

	//TestMechanismSubCmd *pSubCmd = new TestMechanismSubCmd();
	//pSubCmd->RequestDelayedDestruction();

	if (FAILED(CreateImportedMechanism()))
	{
		//RequestDelayedDestruction();
		return TRUE;
	}

	HANDLE Thread =(HANDLE)CreateThread(NULL,0,CatchCATIAWindow,NULL,0,0);
	CloseHandle(Thread);
	
	//RequestDelayedDestruction();
	return TRUE;
}

void TestMechanismCmd::ActionPressEnter()
{
	INPUT inputs[2];
	inputs[0].type = INPUT_KEYBOARD;
	inputs[0].ki.wVk = VK_RETURN;  //按下enter
	inputs[1].type = INPUT_KEYBOARD;
	inputs[1].ki.wVk = VK_RETURN;  
	inputs[1].ki.dwFlags = KEYEVENTF_KEYUP;	//释放enter
	UINT uSend = SendInput(sizeof inputs / sizeof(INPUT), inputs, sizeof(INPUT));
	if (uSend!=ARRAYSIZE(inputs))
	{
		cout<<"SendInput failed................"<<endl;
	}
}

CATStatusChangeRC TestMechanismCmd::Activate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
	if (_iClick>0)
	{
		//HANDLE Thread =(HANDLE)CreateThread(NULL,0,CatchCATIAWindow,NULL,0,0);
		//CloseHandle(Thread);
		GetMechanisms(_spiProdRoot);
	}

	return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command loses focus
//
// Deactivates a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC TestMechanismCmd::Desactivate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
	return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command is canceled
//
// Cancel a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC TestMechanismCmd::Cancel( CATCommand * iFromClient, CATNotification * iEvtDat)
{
	//RequestDelayedDestruction();
	return (CATStatusChangeRCCompleted);
}

DWORD WINAPI CatchCATIAWindow(LPVOID)
{
	//设置时间，如果超过时间跳出while循环
	DWORD FunctionStart = GetTickCount();
	while (1) 
	{
		DWORD NowTime=GetTickCount() - FunctionStart;
		if(NowTime > 8000)
			break;

		HWND hwnd = FindWindow(NULL, L"Sub-mechanisms Import Result");
		if(0 == hwnd)
		{
			hwnd = FindWindow(NULL, L"子机械装置导入结果");
		}
		if(0 != hwnd)
		{
			::SendMessage(hwnd, WM_CLOSE, 0, 0);

			//LimitingPositionCmd * pCmd=new LimitingPositionCmd();

			break;
		}
	}
	return 0;
}

HRESULT TestMechanismCmd::GetMechanisms(CATIProduct_var ispiProdRoot)
{
	CATIAProduct* piaCATIAPrd = NULL;
	HRESULT rc = ispiProdRoot ->QueryInterface( IID_CATIAProduct, (void **)&piaCATIAPrd );
	if (FAILED(rc)||piaCATIAPrd==NULL)
	{
		return E_FAIL;
	}
	CATIAMechanisms* piaMechanisms = NULL;
	CATUnicodeString    strname = "Mechanisms";
	CATBSTR BSTR;
	strname.ConvertToBSTR(&BSTR );
	CATBaseDispatch* pBaseDis = NULL;
	piaCATIAPrd->GetTechnologicalObject( BSTR, pBaseDis); //获取Object对象
	rc = pBaseDis->QueryInterface( IID_CATIAMechanisms, (void **)&piaMechanisms);
	if (FAILED(rc)||piaMechanisms==NULL)
	{
		return E_FAIL;
	}

	CATLONG lNum=0;
	if (FAILED(piaMechanisms->get_Count(lNum)))
	{
		return E_FAIL;
	}
	if (lNum<1)
	{
		cout<<"===>No Mechanism..............."<<endl;
	}
	for (int i=1;i<=lNum;i++)
	{
		VARIANT va;
		va.vt = VT_I4;
		va.lVal = i;
		
		CATIAMechanism *piaMech=NULL;
		if (SUCCEEDED(piaMechanisms->Item(va,piaMech))&&piaMech!=NULL)
		{
			CATISpecObject_var spiSpecMech = piaMech;
			if (spiSpecMech!=NULL_var)
			{
				//cout<<"===>Current Mechanism:  "<<spiSpecMech->GetName()<<endl;
				CATIAlias_var spiAlias = spiSpecMech;
				if (spiAlias!=NULL_var)
				{
					cout<<"===>Current Mechanism:  "<<spiAlias->GetAlias()<<endl;
				}
			}

			CATIKinMechanism *pKinMech=NULL;
			if (SUCCEEDED(piaMech->QueryInterface(IID_CATIKinMechanism,(void**)&pKinMech))&&pKinMech!=NULL)
			{
				double a=100;
				double* ListCommandValueToSet=&a;

				pKinMech->SetCmdValues(1,ListCommandValueToSet);
			}
		}
	}


	return S_OK;
}

HRESULT TestMechanismCmd::CreateImportedMechanism()
{
	CATCommand *pDSCmd=NULL; 
	CATUnicodeString cmdstring = "CATMecImportSubMechsHdr"; //"SectionView"; //"CATGSDPointDatumHdr";//"ZoomIn"; //"AsmSpaceMeasureBetween";
	
	CATCommandHeader * piCHeader=NULL;
	if (FAILED(CATAfrGetCommandHeader("CATMecImportSubMechsHdr",piCHeader))||piCHeader==NULL)
	{
		_pGeneralCls->MessageOutputWarning("Get " + cmdstring + " Header failed","Error");
		return E_FAIL;
	}

	this->RequestStatusChange(CATCommandMsgDesactivated);
	try
	{
		if(SUCCEEDED(CATAfrStartCommand(cmdstring.ConvertToChar(),pDSCmd)) && pDSCmd != NULL )
		{ 
			if(pDSCmd->GetStartMode() !=  CATCommandModeShared)
			{
				if(pDSCmd->RequestStatusChange(CATCommandMsgRequestSharedMode) != 0)
				{
					_pGeneralCls->MessageOutputWarning("Request " + cmdstring + " CATCommandModeShared failed","Notice");
					this->RequestStatusChange(CATCommandMsgRequestSharedMode);
					return E_FAIL;
				} 
			}
		}
		else
		{ 
			_pGeneralCls->MessageOutputWarning("Start command " + cmdstring + " failed","Notice");
			this->RequestStatusChange(CATCommandMsgRequestSharedMode);
			return E_FAIL;
		}
	}catch(...)
	{ 
		_pGeneralCls->MessageOutputWarning("Start command " + cmdstring + " failed","Notice");
		this->RequestStatusChange(CATCommandMsgRequestSharedMode);
		return E_FAIL;
	}
	
	
	return S_OK;
}

HRESULT TestMechanismCmd::SwitchWorkbench(CATUnicodeString istrWorkbench)
{
	CATApplicationFrame * pAF = CATApplicationFrame::GetFrame();
	if(NULL != pAF)
	{
		CATIAApplication *ptApp = NULL;
		if (SUCCEEDED(pAF->QueryInterface(IID_CATIAApplication, (void**) &ptApp)))
		{
			CATBSTR oworkbenchId;
			ptApp->GetWorkbenchId(oworkbenchId);

			CATUnicodeString strworkbench;
			strworkbench.BuildFromBSTR(oworkbenchId);

			cout<<"Current workbench: " + strworkbench<<endl;

			if(strworkbench != istrWorkbench)
			{
				CATBSTR BSTR =::SysAllocString(L" ");
				istrWorkbench.ConvertToBSTR(&BSTR );
				if (FAILED(ptApp->StartWorkbench(BSTR)))
				{
					ptApp->Release();
					ptApp=NULL;

					_pGeneralCls->MessageOutputWarning("Switch to workbench " + istrWorkbench + " failed","Error");
					return E_FAIL;
				}

				ptApp->Release();
				ptApp=NULL;
				return S_OK;
			}
		}
	}

	return E_FAIL;
}