// COPYRIGHT Dassault Systemes 2019
//===================================================================
//
// TestProjectionCmd.cpp
// The state chart based command: TestProjectionCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Mar 2019  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestProjectionCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"




CATCreateClass( TestProjectionCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestProjectionCmd::TestProjectionCmd() :
  CATStateCommand ("TestProjectionCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,_Indication(NULL)
{
	_pDlg = NULL;
	_pDlg = new TestProjectionDlg();
	_pDlg->Build();
	_pDlg->SetVisibility(CATDlgShow);

	_pPointAgent = NULL;
	_pPointFieldAgent = NULL;
	_pSolidAgent = NULL;
	_pSolidFieldAgent = NULL;

	//
	_pEditor = CATFrmEditor::GetCurrentEditor();
	if (_pEditor==NULL)
	{
		RequestDelayedDestruction();
		return;
	}
	_pHSO = _pEditor->GetHSO();
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestProjectionCmd::~TestProjectionCmd()
{
   if (_Indication != NULL) 
      _Indication->RequestDelayedDestruction();

   if (_pDlg != NULL)
   {
	   _pDlg->RequestDelayedDestruction();
	   _pDlg = NULL;
   }

   if (_pPointAgent != NULL)
   {
		_pPointAgent->RequestDelayedDestruction();
		_pPointAgent = NULL;
   }

   if (_pPointFieldAgent != NULL)
   {
	   _pPointFieldAgent->RequestDelayedDestruction();
	   _pPointFieldAgent = NULL;
   }

   if (_pSolidAgent != NULL)
   {
	   _pSolidAgent->RequestDelayedDestruction();
	   _pSolidAgent = NULL;
   }

   if (_pSolidFieldAgent != NULL)
   {
	   _pSolidFieldAgent->RequestDelayedDestruction();
	   _pSolidFieldAgent = NULL;
   }

   _pEditor = NULL;
   _pHSO = NULL;

}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestProjectionCmd::BuildGraph()
{

	//对话框
	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCLOSENotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionCancel,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionCancel,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionCancel,
		NULL);

	AddAnalyseNotificationCB(_pDlg,
		_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionOK,
		NULL);
	//PointField
	_pPointFieldAgent = new CATDialogAgent("Select Point");
	_pPointFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListPoint(),
									  _pDlg->GetSelectorListPoint()->GetListSelectNotification());
	//SolidField
	_pSolidFieldAgent = new CATDialogAgent("Select Solid");
	_pSolidFieldAgent->AcceptOnNotify(_pDlg->GetSelectorListSolid(),
									  _pDlg->GetSelectorListSolid()->GetListSelectNotification());
	//选择Point
	_pPointAgent = new CATFeatureImportAgent("Select Point");
	_pPointAgent->AddElementType("CATIGSMPoint");
	//_pPointAgent->AddElementType("CATCurve");
	_pPointAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//选择Solid
	_pSolidAgent = new CATFeatureImportAgent("Select Solid");
	_pSolidAgent->AddElementType("CATIMechanicalTool");
	//_pSolidAgent->AddElementType("CATIMfBiDimResult");
	_pSolidAgent->SetBehavior(CATDlgEngWithPrevaluation|CATDlgEngWithCSO|CATDlgEngOneShot);

	//
	CATDialogState *pPointState = GetInitialState("Select Point");
	pPointState->AddDialogAgent(_pPointAgent);
	pPointState->AddDialogAgent(_pPointFieldAgent);
	pPointState->AddDialogAgent(_pSolidFieldAgent);

	CATDialogState *pSolidState = AddDialogState("Select Solid");
	pSolidState->AddDialogAgent(_pSolidAgent);
	pSolidState->AddDialogAgent(_pPointFieldAgent);
	pSolidState->AddDialogAgent(_pSolidFieldAgent);

	//
	AddTransition(pPointState,pPointState,
		IsOutputSetCondition(_pPointAgent),
		Action((ActionMethod)& TestProjectionCmd::ActionSelectPoint));

	AddTransition(pSolidState,pSolidState,
		IsOutputSetCondition(_pSolidAgent),
		Action((ActionMethod)& TestProjectionCmd::ActionSelectSolid));

	AddTransition(pPointState,pSolidState,
		IsOutputSetCondition(_pSolidFieldAgent),
		Action((ActionMethod)& TestProjectionCmd::SwitchToSolidSelect));

	AddTransition(pSolidState,pPointState,
		IsOutputSetCondition(_pPointFieldAgent),
		Action((ActionMethod)& TestProjectionCmd::SwitchToPointSelect));

	//选中高亮
	AddAnalyseNotificationCB(_pDlg->GetSelectorListPoint(),
		_pDlg->GetSelectorListPoint()->GetListSelectNotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionHighlightPoint,
		NULL);

	AddAnalyseNotificationCB(_pDlg->GetSelectorListSolid(),
		_pDlg->GetSelectorListSolid()->GetListSelectNotification(),
		(CATCommandMethod)&TestProjectionCmd::ActionHighlightSolid,
		NULL);


}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestProjectionCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}

void TestProjectionCmd::ActionCancel(void * data)
{
	this->RequestDelayedDestruction();
}

void TestProjectionCmd::ActionOK(void * data)
{
	if (_spiSpecPoint != NULL_var && _spiSpecSolid != NULL_var)
	{
		HRESULT rc = ActionCreateProjection(_spiSpecPoint,_spiProductPoint,_spiSpecSolid,_spiProductSolid);
		if (FAILED(rc))
		{
			return;
		}
	}
	return;
}

//
void TestProjectionCmd::ActionSelectPoint()
{
	//
	if (_pHSO != NULL)
	{
		_pHSO->Empty();
	}
	//
	SelectElementUpdate(_pPointAgent,_spiSpecPoint,_spiProductPoint);
	////存入PathElement
	//CATPathElement *pPath = NULL;
	//pPath = _pPointAgent->GetValue();
	//_mapPathElemSelections[_strSelListNormalDir] = pPath;
	//
	CATIAlias_var spAlias = _spiSpecPoint;
	CATUnicodeString strAlias = "";
	if (spAlias != NULL_var)
	{
		strAlias = spAlias->GetAlias();
	}
	_pDlg->GetSelectorListPoint()->ClearLine();
	_pDlg->GetSelectorListPoint()->SetLine(strAlias,-1,CATDlgDataAdd);
	//
	SetHighlight(_pPointAgent);
	//
	_pPointAgent->InitializeAcquisition();
	//
	if (_spiSpecSolid == NULL_var)
	{
		int iTabRow = 0;
		_pDlg->GetSelectorListSolid()->SetSelect(&iTabRow,1);
	}
	//return TRUE;
}
//选择水平线
void TestProjectionCmd::ActionSelectSolid()
{
	//
	if (_pHSO != NULL)
	{
		_pHSO->Empty();
	}
	//
	SelectElementUpdate(_pSolidAgent,_spiSpecSolid,_spiProductSolid);
	////存入PathElement
	//CATPathElement *pPath = NULL;
	//pPath = _pBackViewHorizontalLineAgent->GetValue();
	//_mapPathElemSelections[_strSelListHorizontalLine] = pPath;
	//
	CATIAlias_var spAlias = _spiSpecSolid;
	CATUnicodeString strAlias = "";
	if (spAlias != NULL_var)
	{
		strAlias = spAlias->GetAlias();
	}
	_pDlg->GetSelectorListSolid()->ClearLine();
	_pDlg->GetSelectorListSolid()->SetLine(strAlias,-1,CATDlgDataAdd);
	//
	SetHighlight(_pSolidAgent);
	//
	_pSolidAgent->InitializeAcquisition();
	//
	if (_spiSpecPoint == NULL_var)
	{
		int iTabRow = 0;
		_pDlg->GetSelectorListPoint()->SetSelect(&iTabRow,1);
	}
	//return TRUE;


}
//
void TestProjectionCmd::SwitchToPointSelect()
{
	_pPointFieldAgent->InitializeAcquisition();
	_pSolidFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListSolid()->ClearSelect();
}
//
void TestProjectionCmd::SwitchToSolidSelect()
{
	_pPointFieldAgent->InitializeAcquisition();
	_pSolidFieldAgent->InitializeAcquisition();
	_pDlg->GetSelectorListPoint()->ClearSelect();
}

//
void TestProjectionCmd::ActionHighlightPoint()
{
	////SetHighlightUpdate(_spiSpecNormalDir);
	////
	//CATPathElement *pPath = NULL;
	//pPath = _mapPathElemSelections[_strSelListNormalDir];
	//if (pPath != NULL)
	//{
	//	SetHighlight(pPath);
	//}
	//else
	//{
	SetHighlightUpdate(_spiSpecPoint);
	//}

	//
	_pPointAgent->InitializeAcquisition();
	_pDlg->GetSelectorListSolid()->ClearSelect();
}
//
void TestProjectionCmd::ActionHighlightSolid()
{
	//SetHighlightUpdate(_spiSpecHorizontalLine);
	//
	//CATPathElement *pPath = NULL;
	//pPath = _mapPathElemSelections[_strSelListHorizontalLine];
	//if (pPath != NULL)
	//{
	//	SetHighlight(pPath);
	//}
	//else
	//{
	SetHighlightUpdate(_spiSpecSolid);
	//}
	//
	_pSolidAgent->InitializeAcquisition();
	_pDlg->GetSelectorListPoint()->ClearSelect();

}

//选择元素，转换成SpecObj，并同时返回所属Product(Instance)
void TestProjectionCmd::SelectElementUpdate(CATFeatureImportAgent *pFeatAgent,CATISpecObject_var &spSpecOnSelection, CATIProduct_var &ospProductSeletion) 
{
	HRESULT rc = E_FAIL;

	if (pFeatAgent == NULL)
	{
		return;
	}
	CATISpecObject *piSpecOnSelection = NULL;
	CATPathElement *pPath = pFeatAgent->GetValue();
	CATBaseUnknown *pSelection = pFeatAgent->GetElementValue(pPath);
	//CATBaseUnknown *pSelection = pFeatAgent->GetElementValue(pFeatAgent->GetValue());
	//转换成SpecObj
	if (NULL != pSelection)
	{
		rc = pSelection->QueryInterface(IID_CATISpecObject,(void**)&piSpecOnSelection);
		//转换为空时，说明选择的是Brep元素，需要特征化
		if (piSpecOnSelection == NULL)
		{
			//先判断是不是轴系
			//选择轴系的特征化
			CATIMf3DAxisSystem_var spiMf3DAxisSys = NULL_var;
			rc = pSelection->QueryInterface(IID_CATIMf3DAxisSystem, (void**)&spiMf3DAxisSys);
			if (SUCCEEDED(rc))
			{
				CATIBRepAccess_var spiBRepAccess = NULL_var;
				HRESULT rc1 = spiMf3DAxisSys->GetAxisBRepAccess(CATAxisSystemXNumber,spiBRepAccess);
				HRESULT rc2 = spiMf3DAxisSys->GetAxisBRepAccess(CATAxisSystemYNumber,spiBRepAccess);
				HRESULT rc3 = spiMf3DAxisSys->GetAxisBRepAccess(CATAxisSystemZNumber,spiBRepAccess);
				if (FAILED(rc1) && FAILED(rc2) && FAILED(rc3))
				{
					cout<<"AxisSys to Brep failed"<<endl;
					return;
				}
				CATIFeaturize_var spToFeaturize = spiBRepAccess;
				if (NULL_var != spToFeaturize)
				{
					piSpecOnSelection = spToFeaturize->FeaturizeR();  //(MfNoDuplicateFeature | MfTemporaryBody | MfSelectingFeatureSupport | MfFunctionalFeaturization);
				}
			} 
			else
			{
				//一般特征化
				CATIBRepAccess *pBRepAccess = NULL;
				rc = pSelection -> QueryInterface(IID_CATIBRepAccess, (void**) & pBRepAccess);
				CATIFeaturize_var spToFeaturize = pBRepAccess;
				if (NULL_var != spToFeaturize)
				{
					piSpecOnSelection = spToFeaturize->FeaturizeR(MfPermanentBody|MfLastFeatureSupport|MfRelimitedFeaturization);  //(MfNoDuplicateFeature | MfTemporaryBody | MfSelectingFeatureSupport | MfFunctionalFeaturization);
				}
			}

		}
		spSpecOnSelection = piSpecOnSelection;
	}
	//返回所属Product
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospProductSeletion = spPartObject;
	}
	ospProductSeletion = pProduct;
}

//高亮元素
void TestProjectionCmd::SetHighlight(CATFeatureImportAgent *ipFeatImpAgt)
{

	CATPathElement* pPathEle = NULL;
	pPathEle = ipFeatImpAgt->GetValue();
	if (pPathEle != NULL)
	{
		_pHSO->Empty();
		_pHSO->AddElements(pPathEle);
		_pHSO->EndAddElements();
	}
}

//投影
HRESULT TestProjectionCmd::ActionCreateProjection(CATISpecObject_var ispiSpecElement, CATIProduct_var ispiProductElement, CATISpecObject_var ispiSpecSupport, CATIProduct_var ispiProductSupport)
{
	HRESULT rc = S_OK;
	//
	//先判断传入的Support下面是否有实体
	CATIMechanicalTool_var spiMechTool = ispiSpecSupport;
	if (spiMechTool == NULL_var)
	{
		cout<<"Transfer to MechanicalTool failed"<<endl;
		return E_FAIL;
	}
	CATISpecObject_var spiSpecLastFeat = NULL_var;
	spiSpecLastFeat = spiMechTool->GetLastShapeFeature();
	if (spiSpecLastFeat == NULL_var)
	{
		cout<<"Solid Body is empty"<<endl;
		return E_FAIL;
	}
	//
	CATSoftwareConfiguration *pConfig = new CATSoftwareConfiguration();
	CATTopData pTopData(pConfig);
	//
	//CATGeoFactory *pGeoFact = ::CATCreateCGMContainer();
	CATGeoFactory_var spGeoFact = NULL_var;
	GetGeoFactoryFromObject(ispiSpecSupport,spGeoFact);
	if (spGeoFact == NULL_var)
	{
		return E_FAIL;
	}
	//把需要投影的元素转到Support所属的part里面
	//先把SpecObj转成MathPoint
	CATMathPoint mathPointElement = GetMathPoint(ispiSpecElement);
	//坐标变换到support里面
	CATMathTransformation mathTrans = GetMatrixTransformation(ispiProductElement,ispiProductSupport);
	mathPointElement = mathTrans * mathPointElement;
	//在Support中转成body,TOPO Point
	CATBody_var spBodyElement = NULL_var;
	rc = CreateTopPointByXYZ(spGeoFact,pTopData,mathPointElement,spBodyElement);
	if (FAILED(rc))
	{
		cout<<"Create Topo Point in Support Part failed"<<endl;
		return E_FAIL;
	}
	//在同一个part内开始做相交
	//
	CATBody_var spBodySupport = GetBodyFromFeature(ispiSpecSupport);
	//投影方向，不区分方向，正负的结果都一样
	CATMathDirection mathDir(0,0,1);
	//
	CATBody_var spBodyProjResult = NULL_var;
	CATTry
	{
		CATHybProject *pHybProj = ::CATCreateTopProject(spGeoFact,&pTopData,spBodyElement,spBodySupport,&mathDir);
		if (pHybProj == NULL)
		{
			cout<<"projection failed"<<endl;
			return E_FAIL;
		} 
		pHybProj->Run();
		CATBody *pBodyProj = pHybProj->GetResult();
		if (pBodyProj == NULL)
		{
			cout<<"proj to body no projection result"<<endl;
			return E_FAIL;
		}
		cout<<"projection succeed"<<endl;
		delete pHybProj;
		pHybProj = NULL;

		spBodyProjResult = pBodyProj;

	}
	CATCatch(CATMfErrUpdate, error)	
	{
		if(NULL != error)
		{
			::Flush(error);
		}
		return E_FAIL;
	}

	CATCatch(CATError,error)
	{
		if(NULL != error)
		{
			::Flush(error);
		}
		return E_FAIL;

	}
	CATEndTry;
	//
	if (spBodyProjResult != NULL_var)
	{
		CATLISTP(CATCell) lstCell; 
		spBodyProjResult->GetAllCells( lstCell, 0); 
		if(lstCell.Size()== 0)
		{
			cout<<"LISTCell size == 0"<<endl;
			return E_FAIL;
		}
		else
		{
			cout<<"Projection Result List size: "<<lstCell.Size()<<endl;
			cout<<"--------Projection Result:  "<<endl;
			for (int i=1; i<=lstCell.Size(); i++)
			{
				CATVertex_var spVertex = lstCell[i];
				CATPoint * pPoint = spVertex->GetPoint();
				CATMathPoint mathPoint;
				pPoint->GetMathPoint(mathPoint);
				mathPoint.Dump();
			}
		}
	}

	return rc;
}

//使用全局函数CATCreateTopProject，对于点来说，可以投影到线、面或者实体上
HRESULT TestProjectionCmd::CreateProjection(CATISpecObject_var ispiSpecElement, CATISpecObject_var ispiSpecSupport)
{
	HRESULT rc = S_OK;
	//
	CATSoftwareConfiguration *pConfig = new CATSoftwareConfiguration();
	CATTopData pTopData(pConfig);
	//
	//CATGeoFactory *pGeoFact = ::CATCreateCGMContainer();
	CATGeoFactory_var spGeoFact = NULL_var;
	GetGeoFactoryFromObject(ispiSpecElement,spGeoFact);
	if (spGeoFact == NULL_var)
	{
		return E_FAIL;
	}
	//
	CATBody_var spBodyElement = GetBodyFromFeature(ispiSpecElement);
	CATBody_var spBodySupport = GetBodyFromFeature(ispiSpecSupport);
	//
	CATMathDirection mathDir(0,0,-1);
	//
	CATBody_var spBodyProjResult = NULL_var;
	CATTry
	{
		CATHybProject *pHybProj = ::CATCreateTopProject(spGeoFact,&pTopData,spBodyElement,spBodySupport,&mathDir);
		if (pHybProj == NULL)
		{
			cout<<"projection failed"<<endl;
			return E_FAIL;
		} 
		pHybProj->Run();
		CATBody *pBodyProj = pHybProj->GetResult();
		if (pBodyProj == NULL)
		{
			cout<<"proj to body failed"<<endl;
			return E_FAIL;
		}
		cout<<"projection succeed"<<endl;
		delete pHybProj;
		pHybProj = NULL;

		spBodyProjResult = pBodyProj;

	}
	CATCatch(CATMfErrUpdate, error)	
	{
		if(NULL != error)
		{
			::Flush(error);
		}
		return E_FAIL;
	}

	CATCatch(CATError,error)
	{
		if(NULL != error)
		{
			::Flush(error);
		}
		return E_FAIL;

	}
	CATEndTry;
	
	if (spBodyProjResult != NULL_var)
	{
		CATLISTP(CATCell) lstCell; 
		spBodyProjResult->GetAllCells( lstCell, 0); 
		if(lstCell.Size()== 0)
		{
			cout<<"LISTCell size == 0"<<endl;
			return E_FAIL;
		}
		else
		{
			cout<<"Projection Result List size: "<<lstCell.Size()<<endl;
			CATVertex_var spV1 = lstCell[1];

			CATPoint * pt1 = spV1->GetPoint();

			CATMathPoint mathPt1;
			pt1->GetMathPoint(mathPt1);

			cout<<"--------Projection Result:  ";
			mathPt1.Dump();
		}
	}

	return rc;
}

//使用全局函数CATCreateTopProject，对于点来说，只能投影到线或者面上，不能投影到体上
HRESULT TestProjectionCmd::CreateProjectionUpdate(CATISpecObject_var ispiSpecElement, CATISpecObject_var ispiSpecSupport)
{
	HRESULT rc = S_OK;
	//
	CATSoftwareConfiguration *pConfig = new CATSoftwareConfiguration();
	CATTopData pTopData(pConfig);
	//
	//CATGeoFactory *pGeoFact = ::CATCreateCGMContainer();
	CATGeoFactory_var spGeoFact = NULL_var;
	GetGeoFactoryFromObject(ispiSpecElement,spGeoFact);
	if (spGeoFact == NULL_var)
	{
		return E_FAIL;
	}
	//
	//转到GSMFactory接口
	CATIContainer_var spiContainer = ispiSpecSupport->GetFeatContainer();
	if (spiContainer == NULL_var)
	{
		return E_FAIL;
	}
	CATIGSMFactory_var spiGSMFactory = spiContainer;
	//
	CATIGSMExtractSolide_var spiExtract = spiGSMFactory->CreateExtractSolide(ispiSpecSupport,ExtractSolide_PointPropag);
	CATISpecObject_var spiSpecExtract = spiExtract;
	spiSpecExtract->Update();
	//
	CATBody_var spBodyElement = GetBodyFromFeature(ispiSpecElement);
	CATBody_var spBodySupport = GetBodyFromFeature(spiSpecExtract);
	//
	CATMathDirection mathDir(0,0,-1);
	//
	CATHybProject *pHybProj = ::CATCreateTopProject(spGeoFact,&pTopData,spBodyElement,spBodySupport,&mathDir);
	if (pHybProj == NULL)
	{
		cout<<"projection failed"<<endl;
		return rc;
	} 
	else
	{
		cout<<"projection succeeded"<<endl;
		pHybProj->Run();
		CATBody *pBodyProj = pHybProj->GetResult();
		if (pBodyProj == NULL)
		{
			cout<<"no projection result"<<endl;
		}
	}

	return rc;
}

//点击Selectorlist后高亮选择元素
void TestProjectionCmd::SetHighlightUpdate(CATISpecObject_var ispSpecSelect)
{
	if (_pHSO != NULL)
	{
		_pHSO->Empty();
	}

	if ((ispSpecSelect != NULL_var) && (_pEditor != NULL) && (_pHSO != NULL))
	{
		CATIBuildPath *piBuildPath = NULL;
		HRESULT rc = ispSpecSelect->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
		if (SUCCEEDED(rc))
		{
			CATPathElement context = _pEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
			if (pPathElement != NULL)
			{
				_pHSO->AddElement(pPathElement);
				pPathElement->Release();
				pPathElement = NULL;
			}
			piBuildPath->Release();
			piBuildPath = NULL;
		}
	}

}

// 通过特征获取Body
CATBody_var TestProjectionCmd::GetBodyFromFeature( CATBaseUnknown_var& ispFeature ) 
{ 
	//cout<<"GetBodyFromFeature...."<<endl;
	CATBody_var spBody = NULL_var; 
	do { 
		if( ispFeature==NULL_var )  break; 

		CATIMfBRep_var spBRepOnFeature = ispFeature; 
		if(spBRepOnFeature!=NULL_var )
		{ 
			spBody = spBRepOnFeature->GetBody(); 
			if (spBody==NULL_var)
			{
				spBody=spBRepOnFeature->CreateBody(MfWithPermanentBody);
				if (spBody==NULL_var)
				{
					spBody=spBRepOnFeature->CreateSickBody();
					if (spBody==NULL_var)
					{
						cout<<"CATIMfBRep GetBody Failed"<<endl;

					}
					else
					{
						cout<<"CreateSickBody sucess"<<endl;

					}

				}
				else
				{
					cout<<"CreateBody sucess"<<endl;
				}
			}
		} 
		else
		{ 
			CATIBRepAccess_var spBRepAccess=ispFeature;
			if (spBRepAccess!=NULL_var)
			{
				spBody=spBRepAccess->CreateBody();
			}
			else
			{
				CATIGeometricalElement_var spGeometricalElementOnFeature = ispFeature; 
				if( !!spGeometricalElementOnFeature ) 
				{ 
					spBody = spGeometricalElementOnFeature->GetBodyResult(); 
				} 
				else
				{ 
					CATIBodyRequest_var spBodyRequestOnModel = ispFeature; 
					if( spBodyRequestOnModel == NULL_var) break; 

					CATListValCATBaseUnknown_var listResult; 
					HRESULT rc = spBodyRequestOnModel->GetResults("MfDefault3DView",listResult);
					if(FAILED(rc) ||  listResult.Size() <= 0)   break; 

					CATIGeometricalElement_var spGeometricalElementOnBody = listResult[1]; 
					if(spGeometricalElementOnBody==NULL_var)  break;    
					spBody = spGeometricalElementOnBody->GetBodyResult();
				} 
			}
		}
		if( spBody==NULL_var) break;
	} while(FALSE); 
	//cout<<"GetBodyFromFeature...."<<endl;
	return spBody; 
}

void TestProjectionCmd::GetGeoFactoryFromObject(CATISpecObject_var piCenterCurve,CATGeoFactory_var &ospGeoFactory)
{
	HRESULT rc=E_FAIL;

	//获得当前Document
	CATILinkableObject *pLinkableObjectPart=NULL;
	rc = piCenterCurve->QueryInterface(IID_CATILinkableObject,(void**)&pLinkableObjectPart);	
	CATDocument * pDoc = pLinkableObjectPart->GetDocument();

	//获得CATGeoFactory
	CATGeoFactory * pGeoFactory = NULL;	
	if ( NULL != pDoc )
	{
		CATIContainerOfDocument * pIContainerOfDocument = NULL ;
		rc = pDoc->QueryInterface(IID_CATIContainerOfDocument, (void**)& pIContainerOfDocument );
		if ( SUCCEEDED(rc) )
		{
			CATIContainer * pIContainerOnGeomContainer = NULL ;
			rc = pIContainerOfDocument->GetResultContainer(pIContainerOnGeomContainer);
			if ( SUCCEEDED(rc) )
			{
				rc = pIContainerOnGeomContainer->QueryInterface( IID_CATGeoFactory, (void**)&pGeoFactory );
				if(pGeoFactory==NULL || FAILED(rc))
				{
					cout<<" QueryInterface pGeoFactory FAILED"<<endl;
					return ;
				}
			}
		}
	}
	else
	{
		cout<<"pDoc is NULL"<<endl;
		return ;
	}

	ospGeoFactory=pGeoFactory;
}

//创建拓扑点
//-----------------------------------------------------------------------------------------
HRESULT TestProjectionCmd::CreateTopPointByXYZ(CATGeoFactory_var ispiGeoFactory,CATTopData iTopdata,CATMathPoint iMathPoint,CATBody_var &ospBodyPoint)
{
	CATBody*pBodyPoint=NULL;
	pBodyPoint=CATCreateTopPointXYZ(ispiGeoFactory, &iTopdata,iMathPoint.GetX(),iMathPoint.GetY(), iMathPoint.GetZ()) ; 
	if (pBodyPoint==NULL)
		return E_FAIL;

	ospBodyPoint=pBodyPoint;
	return S_OK;

}

//获得所选择点的数学点
CATMathPoint TestProjectionCmd::GetMathPoint(CATBaseUnknown_var ispiSpecPoint)
{
	CATMathPoint oMathPoint;
	CATPoint_var spPoint = GetPoint(ispiSpecPoint);
	if (spPoint==NULL_var)
	{
		cout<<"GetPoint Failed"<<endl;
		return oMathPoint;
	}

	double x,y,z;
	spPoint->GetCoord(x,y,z);
	spPoint->GetMathPoint(oMathPoint);

	return oMathPoint;
}

//获得所选点
CATMathPoint TestProjectionCmd::GetPointFromBody(CATBody_var spBody)
{
	CATMathPoint oMathPoint;
	CATPoint_var spPoint=NULL_var;
	if(spBody != NULL_var) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;

			CATVertex_var spVertex = spCell;
			if(spVertex == NULL_var) 
			{
				cout<<"CATVertex is NULL_var."<<endl;
				continue;
			}

			CATPoint *pPoint = spVertex->GetPoint();
			if(pPoint == NULL)
			{
				cout<<"GetPoint failed."<<endl;
				continue;
			}

			spPoint = pPoint;
		}

		double x,y,z;
		spPoint->GetCoord(x,y,z);
		spPoint->GetMathPoint(oMathPoint);
	}

	return oMathPoint;
}
//获得所选点
CATPoint_var TestProjectionCmd::GetPoint(CATBaseUnknown_var ispiSpecObject)
{
	CATPoint_var spPoint=NULL_var;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody != NULL_var) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;

			CATVertex_var spVertex = spCell;
			if(spVertex == NULL_var) 
			{
				cout<<"CATVertex is NULL_var."<<endl;
				continue;
			}

			CATPoint *pPoint = spVertex->GetPoint();
			if(pPoint == NULL)
			{
				cout<<"GetPoint failed."<<endl;
				continue;
			}

			spPoint = pPoint;
		}
	}
	return spPoint;
}

//坐标变换
CATMathTransformation TestProjectionCmd::GetMatrixTransformation(CATIProduct_var ispCurrentProduct,CATIProduct_var ispTargetProduct)
{
	CATMathAxis iCurrentAxis;
	CATMathAxis iTargetAxis;

	CATIMovable_var spiMovableOne=NULL_var;
	spiMovableOne=ispCurrentProduct;

	CATIMovable_var spiMovableTwo=NULL_var;
	spiMovableTwo=ispTargetProduct;

	CATMathTransformation absCurrentTransformation;
	spiMovableOne->GetAbsPosition(absCurrentTransformation);
	iCurrentAxis=absCurrentTransformation*iCurrentAxis;

	CATMathTransformation absTargetTransformation;
	spiMovableTwo->GetAbsPosition(absTargetTransformation);
	iTargetAxis=absTargetTransformation*iTargetAxis;

	CATMathTransformation  oTransPart;
	oTransPart=CATMathTransformation(iTargetAxis,CATMathOIJK)*CATMathTransformation(CATMathOIJK,iCurrentAxis);
	return oTransPart;
}