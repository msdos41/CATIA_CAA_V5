// COPYRIGHT Dassault Systemes 2019
//===================================================================
//
// TestUserDefinedMathBoxCmd.cpp
// The state chart based command: TestUserDefinedMathBoxCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Aug 2019  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "TestUserDefinedMathBoxCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( TestUserDefinedMathBoxCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TestUserDefinedMathBoxCmd::TestUserDefinedMathBoxCmd() :
  CATStateCommand ("TestUserDefinedMathBoxCmd", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,_Indication(NULL)
{
	/* 读取txt获取ip地址和port的测试代码
	cout<<"Test Starting........."<<endl;

	char *pIPAddr = NULL;
	int iPort = 8090;
	YFGetLicServerIP(&pIPAddr,iPort);
	cout<<pIPAddr<<": "<<iPort<<endl;
	*/
	
	_pGeneralCls = new GeneralClass();

	//测试最小包围凸多边形
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	CATDocument *pDoc = pEditor->GetDocument();
	CATLISTV(CATISpecObject_var) lstViews;
	_pGeneralCls->GetAllViews(pDoc,lstViews);
	if (lstViews.Size()==0)
	{
		return;
	}
	for (int i=1;i<=lstViews.Size();i++)
	{
		CATIView_var spiView = lstViews[i];
		vector<CATMathPoint2D> vecPt2D;
		this->GetAllPointsFromView(spiView,vecPt2D);
		if (vecPt2D.size()==0)
		{
			continue;
		}
		UserDefinedCircle MinOuterCircle;
		this->GetMinOuterCircle(vecPt2D,MinOuterCircle);

		//UserDefinedCircle MaxInnerCircle;
		//this->GetMaxInnerCircle(vecPt2D,MaxInnerCircle);

		//
		CATIDftView *piDftView=NULL;
		HRESULT rc=spiView->QueryInterface(IID_CATIDftView,(void**)&piDftView);
		if(FAILED(rc)||piDftView==NULL) 
		{
			continue;
		}
		piDftView->Activate();

		//
		CATI2DWFFactory_var spi2DWFFactory = spiView;
		if (spi2DWFFactory!=NULL_var)
		{
			double arrCenter[2] = {MinOuterCircle.ptCenter.GetX(),MinOuterCircle.ptCenter.GetY()};
			double dRadius = MinOuterCircle.dRadius;

			CATISpecObject_var spiSpecCircle = spi2DWFFactory->CreateCircle(arrCenter,dRadius);
			spiSpecCircle->Update();

			//double arrCenter2[2] = {MaxInnerCircle.ptCenter.GetX(),MaxInnerCircle.ptCenter.GetY()};
			//double dRadius2 = MaxInnerCircle.dRadius;

			//CATISpecObject_var spiSpecCircle2 = spi2DWFFactory->CreateCircle(arrCenter2,dRadius2);
			//spiSpecCircle2->Update();
		}
	}


#if 0
	//测试2维最小外接圆
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	CATDocument *pDoc = pEditor->GetDocument();
	CATLISTV(CATISpecObject_var) lstViews;
	_pGeneralCls->GetAllViews(pDoc,lstViews);
	if (lstViews.Size()==0)
	{
		return;
	}

	for (int i=1;i<=lstViews.Size();i++)
	{
		CATIView_var spiView = lstViews[i];
		vector<CATMathPoint2D> vecPt2D;
		this->GetAllPointsFromView(spiView,vecPt2D);
		if (vecPt2D.size()==0)
		{
			continue;
		}
		UserDefinedCircle MinOuterCircle;
		this->GetMinOuterCircle(vecPt2D,MinOuterCircle);

		//UserDefinedCircle MaxInnerCircle;
		//this->GetMaxInnerCircle(vecPt2D,MaxInnerCircle);

		//
		CATIDftView *piDftView=NULL;
		HRESULT rc=spiView->QueryInterface(IID_CATIDftView,(void**)&piDftView);
		if(FAILED(rc)||piDftView==NULL) 
		{
			continue;
		}
		piDftView->Activate();

		//
		CATI2DWFFactory_var spi2DWFFactory = spiView;
		if (spi2DWFFactory!=NULL_var)
		{
			double arrCenter[2] = {MinOuterCircle.ptCenter.GetX(),MinOuterCircle.ptCenter.GetY()};
			double dRadius = MinOuterCircle.dRadius;

			CATISpecObject_var spiSpecCircle = spi2DWFFactory->CreateCircle(arrCenter,dRadius);
			spiSpecCircle->Update();

			//double arrCenter2[2] = {MaxInnerCircle.ptCenter.GetX(),MaxInnerCircle.ptCenter.GetY()};
			//double dRadius2 = MaxInnerCircle.dRadius;

			//CATISpecObject_var spiSpecCircle2 = spi2DWFFactory->CreateCircle(arrCenter2,dRadius2);
			//spiSpecCircle2->Update();
		}
	}

#endif

#if 0
	//测试clipping view内的线条数量
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	CATDocument *pDoc = pEditor->GetDocument();

	CATLISTV(CATISpecObject_var) lstViews;
	_pGeneralCls->GetAllViews(pDoc,lstViews);
	if (lstViews.Size()==0)
	{
		return;
	}
	for (int i=1;i<=lstViews.Size();i++)
	{
		CATIView_var spiView = lstViews[i];
		if (spiView==NULL_var)
		{
			continue;
		}
		CATIDftView* piDftView=NULL;
		HRESULT rc=spiView->QueryInterface(IID_CATIDftView, (void**)&piDftView);
		if(SUCCEEDED(rc)&&piDftView!=NULL)
		{
			IUnknown* piGenView = NULL;
			if(SUCCEEDED(piDftView->GetApplicativeExtension(IID_CATIDftGenView,&piGenView)))
			{
				CATIDftGenGeomAccess* piGenGeomAccess = NULL;
				if(SUCCEEDED(piGenView->QueryInterface(IID_CATIDftGenGeomAccess,(void**)&piGenGeomAccess)))
				{
					// Get a list containing all Generated Geometry of the view
					CATIUnknownList* piList=NULL;
					if( SUCCEEDED(piGenGeomAccess->GetAllGeneratedItems(IID_CATIDftGenGeom,&piList)))
					{
						if(piList!=NULL)
						{
							unsigned int iListSize = 0;
							piList->Count(&iListSize);
							cout<<"# The Number Of Generated Geometry:"<<iListSize<<endl;

							piList->Release();
							piList = NULL;
						}
						piGenGeomAccess->Release();
						piGenGeomAccess = NULL;
					}
				}
				piGenView->Release();
				piGenView=NULL;
			}
		}
	}
#endif
	/*
	//测试自动高亮以及高亮面的中点处的曲率半径
	CATIProduct_var spiProdRoot = NULL_var;
	_pGeneralCls->GetRootProductUpdate(spiProdRoot);
	if (spiProdRoot == NULL_var)
	{
		RequestDelayedDestruction();
		return;
	}
	cout<<spiProdRoot->GetPartNumber()<<endl;
	CATIPrtContainer_var  spRootContainer = _pGeneralCls->GetPrtContainer(spiProdRoot);
	if( spRootContainer == NULL_var )
	{
		cout <<"# Get Container error !" << endl;
		return;
	}

	CATISpecObject_var spiSpecOnPart = spRootContainer -> GetPart();
	if (spiSpecOnPart == NULL_var)
	{
		cout<<"Get Part Failed!"<<endl;
		return;
	}
	CATIPartRequest *piPartRequest = NULL;
	CATListValCATBaseUnknown_var lstBodies = NULL;
	HRESULT rc = spiSpecOnPart->QueryInterface(IID_CATIPartRequest,(void**) &piPartRequest);
	if (FAILED(rc) || piPartRequest == NULL)
	{
		return;
	}
	piPartRequest->GetSolidBodies("",lstBodies);
	piPartRequest->Release();
	piPartRequest = NULL;
	//获取头一个实体作为测试对象
	if (lstBodies.Size()==0)
	{
		return;
	}
	CATISpecObject_var spCurrObj = lstBodies[1];
	if (spCurrObj == NULL_var)
	{
		return;
	}
	//获取所有二维的cell
	CATBody_var spBody = _pGeneralCls->GetBodyFromFeature(spCurrObj);
	if (spBody == NULL_var)
	{
		return;
	}
	CATLISTP(CATCell) lstCell;
	spBody->GetAllCells(lstCell,2);
	if (lstCell.Size()==0)
	{
		return;
	}
	int iCountColor = 0;
	for (int i=1; i<= lstCell.Size(); i++)
	{
		CATFace_var spFace = lstCell[i];
		if (spFace == NULL_var)
		{
			continue;
		}
		//
		//double dblCrvRadiusMin,dblCrvRadiusMax;
		//rc = _pGeneralCls->GetCrvRadiusOnSurface(spFace,dblCrvRadiusMin,dblCrvRadiusMax);
		//if (SUCCEEDED(rc))
		//{
		//	cout<<"Rmin: "<<dblCrvRadiusMin<<"   Rmax: "<<dblCrvRadiusMax<<endl;
		//}
		//if (dblCrvRadiusMin < 2.8 || dblCrvRadiusMin > 3.2)
		//{
		//	continue;
		//}
		//
		//
		CATIBRepAccess_var spiBrepAcess  =NULL_var;
		spiBrepAcess = CATBRepDecodeCellInBody(spFace,spBody);
		if (spiBrepAcess == NULL_var)
		{
			continue;
		}
		unsigned int iRed,iGreen,iBlue;
		rc = _pGeneralCls->GetColorOnBRepObject(spiBrepAcess,iRed,iGreen,iBlue);
		if (SUCCEEDED(rc)&&iRed==0&&iGreen==0&&iBlue==0)
		{
			iCountColor++;
		}
		CATIFeaturize_var  spToFeaturize  =  spiBrepAcess;
		if  (NULL_var  ==  spToFeaturize)
		{
			continue;
		}
		CATISpecObject_var spiSpecOnCell  =  spToFeaturize->FeaturizeR(MfPermanentBody|MfLastFeatureSupport|MfRelimitedFeaturization|MfDuplicateFeature);    //(MfNoDuplicateFeature  |  MfTemporaryBody  |  MfSelectingFeatureSupport  |  MfFunctionalFeaturization);
		//CATISpecObject_var spiSpecOnCell  =  spToFeaturize->FeaturizeF();
		//CATISpecObject_var spiSpecOnCell  =  spToFeaturize->FeaturizeR(MfNoDuplicateFeature | MfPermanentBody | MfSelectingFeatureSupport | MfFunctionalFeaturization);
		CATBaseUnknown *pBU = NULL;
		rc = spiSpecOnCell->QueryInterface(IID_CATBaseUnknown,(void**)&pBU);
		if (SUCCEEDED(rc)&&pBU != NULL)
		{
			_pGeneralCls->SetHighlight(pBU);	//目前只能用vb方法高亮成功，caa方法暂时都无法高亮
		}
		//
		CATISpecObject_var spiSpecFather = spiSpecOnCell->GetFather();
		if (spiSpecFather != NULL_var)
		{
			CATIAlias_var spiAlias = spiSpecFather;
			cout<<"Father Name: "<<spiAlias->GetAlias()<<endl;
		}
		//rc = _pGeneralCls->GetColorOnObject(spiSpecOnCell,iRed,iGreen,iBlue);
		//if (SUCCEEDED(rc)&&iRed==0&&iGreen==0&&iBlue==0)
		//{
		//	iCountColor++;
		//}
		//AddHSO(spiSpecOnCell);
		//
	}
	cout<<"-----------------------------------------------"<<endl;
	cout<<"The Specific Color Count is "<<iCountColor<<endl;
	cout<<"-----------------------------------------------"<<endl;

	*/

	/*
	double num1 = 0.00005;
	double num2 = 0.00006;
	cout<<abs(num2-num1)<<"  "<<fabs(num2-num1)<<endl;
	cout<<"----------------"<<endl;

	POINT2D pt1 = {{0,100}};
	POINT2D pt2 = {{100,100}};
	POINT2D pt3 = {{100,0}};
	POINT2D pt4 = {{0,0}};
	vector<POINT2D> vecPt;
	vecPt.push_back(pt1);
	vecPt.push_back(pt2);
	vecPt.push_back(pt3);
	vecPt.push_back(pt4);
	vector<vector<POINT2D>> vecLstPt;
	vecLstPt.push_back(vecPt);

	POINT2D PT1 = {{50,50}};
	POINT2D PT2 = {{150,60}};
	POINT2D PT3 = {{150,-40}};
	POINT2D PT4 = {{50,-50}};
	vector<POINT2D> vecPT;
	vecPT.push_back(PT1);
	vecPT.push_back(PT2);
	vecPT.push_back(PT3);
	vecPT.push_back(PT4);


	double collision;
	CATBoolean bIntersect = _pGeneralCls->CheckBoxIntersect(1,vecPT,vecLstPt,collision);
	cout<<"------------------"<<endl;

	*/

	/* 二维直线相交测试代码

	CATMathPoint2D pt1(0,-500);
	CATMathPoint2D pt2(500,-500);
	CATMathPoint2D pt3(100,0);
	CATMathVector2D dir(0,-1);
	CATMathLine2D line1(pt2,pt1);
	CATMathLine2D line2(pt3,dir);
	CATMathPoint2D ptOrigin = line2.GetOrigin();
	double parm,parmOther;
	int iIntersect = line2.Intersect(line1,parmOther,parm);
	cout<<"--------------"<<endl;

	*/
	
	/* vector相关方法代码测试
	vector<int> vec;
	for (int i=0;i<10;i++)
	{
		vec.push_back(i);
	}
	for (int i=0; i<vec.size(); i++)
	{
		cout<<vec[i];
	}
	cout<<"\n"<<endl;
	vec.erase(vec.begin(),vec.begin()+3);//删掉从第一个起的3个元素
	for (int i=0; i<vec.size(); i++)
	{
		cout<<vec[i];
	}
	cout<<"\n"<<endl;
	*/
	
	/* 二维点顺时针排序并计算移动量的测试代码
	double pt1[2]={50,200};
	double pt4[2]={50,0};
	double pt3[2]={-50,-200};
	double pt2[2]={-50,0};
	vector<double*> vecPt;
	vecPt.push_back(pt1);
	vecPt.push_back(pt2);
	vecPt.push_back(pt3);
	vecPt.push_back(pt4);
	vector<double*> ptResult;
	_pGeneralCls->SortPt2DClockwise(vecPt,ptResult);
	double ipt1[2] = {-500,200};
	double ipt2[2] = {500,-200};
	double ptMove[2];
	_pGeneralCls->CalculateVerticalMovePoint(ptResult,ipt1,ipt2,10,1,ptMove);
	cout<<ptMove[0]<<" , "<<ptMove[1]<<endl;
	cout<<"-------------------------------"<<endl;
	*/

	/*
	POINT2D pt1 = {{0,200}};
	POINT2D pt4 = {{500,0}};
	//pt4.Coord={500,0};
	POINT2D pt3 = {{0,-200}};
	//pt3.Coord={0,-200};
	POINT2D pt2 = {{-500,0}};
	//pt2.Coord={-500,0};
	vector<POINT2D> vecPt;
	vecPt.push_back(pt1);
	vecPt.push_back(pt2);
	vecPt.push_back(pt3);
	vecPt.push_back(pt4);
	double arrPos[2] = {0,0};
	//vector<double*> ptResult;
	_pGeneralCls->SortPt2DClockwise(vecPt);
	for (int i=0; i<vecPt.size(); i++)
	{
		cout<<vecPt[i].Coord[0]<<","<<vecPt[i].Coord[1]<<endl;
	}
	cout<<"-------------------------"<<endl;

	vector<POINT2D> ptTransfer;
	double ptCorner1[2];
	double ptcorner2[2];
	//_pGeneralCls->TransferPt2DToAbsPos(vecPt,arrPos,0.5,ptTransfer);
	_pGeneralCls->MovePt2DToAbsPos(vecPt,arrPos,0.5,1,ptTransfer,ptCorner1,ptcorner2);
	for (int i=0; i<ptTransfer.size(); i++)
	{
		cout<<ptTransfer[i].Coord[0]<<","<<ptTransfer[i].Coord[1]<<endl;
	}
	cout<<"-------------------------"<<endl;

	*/
	
	/* 二维点顺逆时针排序相关测试代码
	//vector<double[2]> vec;
	
	double pt1[2]={0,200};
	double pt4[2]={500,0};
	double pt3[2]={0,-200};
	double pt2[2]={-500,0};
	vector<double*> vecPt;
	vecPt.push_back(pt1);
	vecPt.push_back(pt2);
	vecPt.push_back(pt3);
	vecPt.push_back(pt4);
	double arrPos[2] = {0,0};
	vector<double*> ptResult;
	_pGeneralCls->SortPt2DClockwise(vecPt);
	for (int i=0; i<vecPt.size(); i++)
	{
		cout<<vecPt[i][0]<<","<<vecPt[i][1]<<endl;
	}
	cout<<"-------------------------"<<endl;

	vector<double*> ptTransfer;
	_pGeneralCls->TransferPt2DToAbsPos(vecPt,arrPos,0.5,ptTransfer);
	for (int i=0; i<ptTransfer.size(); i++)
	{
		cout<<ptTransfer[i][0]<<","<<ptTransfer[i][1]<<endl;
	}
	cout<<"-------------------------"<<endl;
	*/

	/*根据名称获取Drawing内Instance Component的测试代码
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	CATDocument *pDoc = pEditor->GetDocument();
	//CATIDftSheet *pDftSheet = _pGeneralCls->GetSheetFromComponentName(pDoc,"Circle");
	CATIDftSheet *piDftSheet = NULL;
	CATI2DDitto *piDitto = NULL;
	double arrPosDitto[2], arrPosTable[2];
	//HRESULT rc = _pGeneralCls->GetSheetFromDittoName(pDoc,"Circle",piDftSheet,piDitto);
	//if (piDftSheet != NULL)
	//{
	//	CATISheet *piSheet = NULL;
	//	rc = piDftSheet->QueryInterface(IID_CATISheet,(void**)&piSheet);
	//	if (SUCCEEDED(rc) && piSheet != NULL)
	//	{
	//		cout<<"Ditto in Sheet: "<<CATIAlias_var(piSheet)->GetAlias()<<endl;
	//	}
	//	double arrPos[6];
	//	piDitto->Get2DAxisMatrix(arrPos);
	//	for (int i=0; i <6; i++)
	//	{
	//		cout<<arrPos[i]<<endl;	//最后两位就是坐标系原点位置
	//	}
	//	IUnknown *piUnknown = NULL;
	//	rc = piDitto->GetDetail(IID_CATIView,&piUnknown);	//获得Ditto的参考视图
	//	if (SUCCEEDED(rc) && piUnknown != NULL)
	//	{
	//		CATIView_var spiView = NULL_var;
	//		rc = piUnknown->QueryInterface(IID_CATIView,(void**)&spiView);
	//		if (SUCCEEDED(rc) && spiView != NULL_var)
	//		{
	//			cout<<"Ditto's reference view is  "<<CATIAlias_var(spiView)->GetAlias()<<endl;
	//		}
	//	}
	//}
	HRESULT rc = _pGeneralCls->GetSheetFromDittoName(pDoc,"Table",piDftSheet,piDitto,arrPosDitto);
	if (piDftSheet != NULL)
	{
		cout<<"Ditto Pos: "<<arrPosDitto[0]<<" , "<<arrPosDitto[1]<<endl;
		_pGeneralCls->GetTablePosInView(piDitto,arrPosTable);
		cout<<"Table Pos: "<<arrPosTable[0]<<" , "<<arrPosTable[1]<<endl;
	}
	
	*/

	/* 测试yfai逻辑读取零件号和零件名的代码
	//
	CATIProduct_var spiRootProd = NULL_var;
	_pGeneralCls->GetRootProductUpdate(spiRootProd);
	//CATBoolean bIsVWPartNum = _pGeneralCls->IsVWPartNumber(spiRootProd);
	//if (bIsVWPartNum == TRUE)
	//{
	//	CATUnicodeString strFullName = spiRootProd->GetPartNumber();
	//	CATUnicodeString strVWPartNum = _pGeneralCls->GetVWPartNum(strFullName);
	//	CATUnicodeString strVWPartName = _pGeneralCls->GetVWPartName(strFullName);
	//}
	//else
	//{
	//	CATUnicodeString strFullName = spiRootProd->GetPartNumber();
	//	CATUnicodeString strVWNonPartNum = _pGeneralCls->GetNonVWPartNum(strFullName);
	//	CATUnicodeString strVWNonPartName = _pGeneralCls->GetNonVWPartName(strFullName);
	//}
	CATUnicodeString strPartNum = "";
	CATUnicodeString strPartName = "";
	HRESULT rc = _pGeneralCls->GetPartNumAndNameFromProduct(spiRootProd,strPartNum,strPartName);
	cout<<strPartNum<<"  "<<strPartName<<endl;

	*/

	/*  读取xml相关测试代码

	CATListOfCATUnicodeString lstHVaneFeatureName = NULL;
	_pGeneralCls->GetFeatureNamesFromXML("H-Vane.xml", lstHVaneFeatureName);
	for (int i=1 ; i <= lstHVaneFeatureName.Size(); i++)
	{
		cout<<lstHVaneFeatureName[i]<<endl;
	}

	CATListOfCATUnicodeString lstHVaneParmName = NULL;
	_pGeneralCls->GetParmNamesAndTolFromXML("H-Vane.xml",lstHVaneParmName);
	for (int j=1 ; j <= lstHVaneParmName.Size(); j++)
	{
		cout<<lstHVaneParmName[j]<<endl;
	}

	*/

	//CAACommonModule *pCommonMod = new CAACommonModule();



	/* 斜向包围盒的测试代码
	
	//
	CATIProduct_var spiRootProduct = NULL_var;
	_pGeneralCls->GetRootProductUpdate(spiRootProduct);

	CATListValCATBaseUnknown_var *lstAllChildren = spiRootProduct->GetAllChildren();
	if (lstAllChildren == NULL)
	{
		return;
	}
	//过滤出Part
	CATIProduct_var spChild = NULL_var;
	CATLISTP(CATIProduct) lstCATPart = NULL;
	for (int i = 1; i <= lstAllChildren->Size(); i++)
	{
		spChild = (*lstAllChildren)[i];
		lstCATPart.Append(spChild);
	}

	CATMathPlane mathPlaneScreen;
	_pGeneralCls->GetPlaneFromScreen(mathPlaneScreen);

	///*
	//定义斜向坐标系
	CATMathVector mathVecX, mathVecY, mathVecScreen;
	CATMathPoint mathPointOrg;
	mathPlaneScreen.GetFirstDirection(mathVecX);
	mathPlaneScreen.GetSecondDirection(mathVecY);
	mathPlaneScreen.GetNormal(mathVecScreen);
	mathPlaneScreen.GetOrigin(mathPointOrg);
	double arrayX[3], arrayScreen[3], arrayOrg[3];
	mathVecX.GetCoord(arrayX);
	mathVecScreen.GetCoord(arrayScreen);
	mathPointOrg.GetCoord(arrayOrg);



	//从测量Inertia获得斜向方向
	CATIInertia* piInertiaOnProduct = NULL;
	HRESULT rc = lstCATPart[1]->QueryInterface(IID_CATIInertia,(void**)&piInertiaOnProduct);
	if (FAILED(rc) || piInertiaOnProduct == NULL)
	{
		return;
	}
	double arrdAxis[9];
	rc = piInertiaOnProduct->GetPrincipalAxes(arrdAxis);
	double arrayTemp[3] = {arrdAxis[6],arrdAxis[7],arrdAxis[8]};
	//
	double arrayXnew[3], arrayYnew[3];
	CATMathVector mathVecXnew = mathVecScreen ^ CATMathVector(arrayTemp);
	mathVecXnew = mathVecXnew ^ mathVecScreen;
	mathVecXnew.Normalize();
	mathVecXnew.GetCoord(arrayXnew);
	
	//D3PointProjectOnPlane(arrayTemp,arrayOrg,arrayScreen,arrayXnew);
	//D3ArrayCopy(arrayTemp,arrayXnew);
	//D3VectorRotate(arrayX,arrayScreen,CATPI/6,arrayXnew);
	D3CrossProduct(arrayScreen,arrayXnew,arrayYnew);

	//获取当前打开零件的包围盒------绝对坐标系下
	//CATMathBox mathBoxAbs = _pGeneralCls->Get3DBoundingBoxOfSinglePart(spiRootProduct);

	//double   ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax;
	//mathBoxAbs.GetExtremities (ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);
	//CATMathPoint  iLow1(ioXMin,ioYMin,ioZMin);
	//CATMathPoint  iLow2(ioXMin,ioYMax,ioZMin);
	//CATMathPoint  iLow3(ioXMax,ioYMax,ioZMin);
	//CATMathPoint  iLow4(ioXMax,ioYMin,ioZMin);
	//CATMathPoint  iHigh1(ioXMin,ioYMin,ioZMax);
	//CATMathPoint  iHigh2(ioXMin,ioYMax,ioZMax);
	//CATMathPoint  iHigh3(ioXMax,ioYMax,ioZMax);
	//CATMathPoint  iHigh4(ioXMax,ioYMin,ioZMax);
	////
	//vector<CATMathPoint> lstPointsAbs;
	//lstPointsAbs.push_back(iLow1);
	//lstPointsAbs.push_back(iLow2);
	//lstPointsAbs.push_back(iLow3);
	//lstPointsAbs.push_back(iLow4);
	//lstPointsAbs.push_back(iHigh1);
	//lstPointsAbs.push_back(iHigh2);
	//lstPointsAbs.push_back(iHigh3);
	//lstPointsAbs.push_back(iHigh4);

	//根据Inertia测量计算出的轴系，计算包围盒
	double arrX[3] = {arrdAxis[0],arrdAxis[3],arrdAxis[6]};
	double arrY[3] = {arrdAxis[1],arrdAxis[4],arrdAxis[7]};
	double arrZ[3] = {arrdAxis[2],arrdAxis[5],arrdAxis[8]};
	vector<CATMathPoint> lstAllPartsBoundary;
	for (int i=1; i <= lstCATPart.Size(); i++)
	{
		vector<CATMathPoint> lstBoundaryPts;
		rc = _pGeneralCls->Get3DBoundingBoxOfSinglePart(lstCATPart[i],CATMathVector(arrX),CATMathVector(arrY),CATMathVector(arrZ),lstBoundaryPts);
		for (int j=0; j < lstBoundaryPts.size(); j++)
		{
			lstAllPartsBoundary.push_back(lstBoundaryPts[j]);
		}
	}
	CATMathPoint*  pBoundingBox3D = new CATMathPoint[8];
	Create3DBoxWithAxis(lstAllPartsBoundary,mathPlaneScreen.GetOrigin(),CATMathVector(arrX),CATMathVector(arrY),CATMathVector(arrZ),pBoundingBox3D);

	double arrPt1[3],arrPt2[3],arrPt4[3],arrPt5[3];
	pBoundingBox3D[0].GetCoord(arrPt1);
	pBoundingBox3D[1].GetCoord(arrPt2);
	pBoundingBox3D[3].GetCoord(arrPt4);
	pBoundingBox3D[4].GetCoord(arrPt5);
	double vectorX[3],vectorY[3],vectorZ[3];
	D3VectorSetFromTwoPoint(arrPt1,arrPt4,vectorX);
	D3VectorSetFromTwoPoint(arrPt1,arrPt5,vectorY);
	D3VectorSetFromTwoPoint(arrPt1,arrPt2,vectorZ);
	double vector1[3],vector2[3];
	_pGeneralCls->GetTwoLongerDirections(vectorX,vectorY,vectorZ,arrayScreen,vector1,vector2);


	////把inertia测出的x和y轴投影到当前屏幕
	//double arrXproj[3], arrYproj[3], arrZproj[3];
	//double arrT[3];
	//D3CrossProduct(arrayScreen,arrX,arrT);
	//D3CrossProduct(arrT,arrayScreen,arrXproj);

	//D3CrossProduct(arrayScreen,arrY,arrT);
	//D3CrossProduct(arrT,arrayScreen,arrYproj);

	//D3CrossProduct(arrayScreen,arrZ,arrT);
	//D3CrossProduct(arrT,arrayScreen,arrZproj);

	////算出夹角最接近90度的两个方向
	//double arrFirst[3],arrSecond[3];
	//_pGeneralCls->GetTwoVerticalVectors(arrXproj,arrYproj,arrZproj,arrFirst,arrSecond);


	CATMathPoint*  BoundingBox3Dnew = new CATMathPoint[8] ;
	CATMathPoint*  BoundingBox2Dnew = new CATMathPoint[4] ;
	vector<CATMathPoint> lstPointsNewSys;
	//Create3DBoxWithAxis(lstBoundingPts,mathPlaneScreen.GetOrigin(),CATMathVector(arrayXnew),CATMathVector(arrayYnew),mathVecScreen,BoundingBox3Dnew);
	Create3DBoxWithAxis(lstAllPartsBoundary,mathPlaneScreen.GetOrigin(),CATMathVector(vector1),CATMathVector(vector2),mathVecScreen,BoundingBox3Dnew);
	for (int i=0; i<=7; i++)
	{
		lstPointsNewSys.push_back(BoundingBox3Dnew[i]);
	}
	//
	//lstPointsNewSys.clear();
	//rc = _pGeneralCls->GetBoundingPtsFromInertia(spiRootProduct,lstPointsNewSys);
	PointsProjectingInTo2DBoxOnViewAlongDirection(lstPointsNewSys,mathPlaneScreen.GetOrigin(),CATMathVector(vector1),CATMathVector(vector2),mathVecScreen,BoundingBox2Dnew);

	


	//CATListValCATBaseUnknown_var *lstAllChildren = spiRootProduct->GetAllChildren();
	//if (lstAllChildren == NULL)
	//{
	//	return;
	//}
	////过滤出Part
	//CATIProduct_var spChild = NULL_var;
	//CATLISTP(CATIProduct) lstCATPart = NULL;
	//for (int i = 1; i <= lstAllChildren->Size(); i++)
	//{
	//	spChild = (*lstAllChildren)[i];
	//	lstCATPart.Append(spChild);
	//}

	//打开图纸
	CATUnicodeString strDwgPath = "C:\\Users\\Administrator\\Desktop\\Drawing1.CATDrawing";
	//CATDocument * pDoc = NULL;
	//HRESULT rc=CATDocumentServices::OpenDocument(strDwgPath,pDoc);//打开二维图文档
	//if (NULL == pDoc)
	//{
	//	return;
	//}
	CATSession * pSession = CATSession::GetPtrSession();
	if (pSession==NULL)
	{
		cout<<"GetPtrSession Failed"<<endl;
		return;
	}

	CATIIniInteractiveSession* pInteractiveSession = NULL;
	rc=pSession->QueryInterface(IID_CATIIniInteractiveSession, (void **) &pInteractiveSession);
	if (FAILED(rc)||pInteractiveSession==NULL)
	{
		cout<<"Get CATIIniInteractiveSession Failed"<<endl;
		return;
	}

	CATIEditor* pEditor = NULL;
	pInteractiveSession->Open( strDwgPath, FALSE,&pEditor);
	if (pEditor == NULL)
	{
		cout<<"NewFrom Failed"<<endl;
		return;
	}

	CATDocument* pDoc = NULL;
	pDoc = pEditor->GetEditor()->GetDocument();
	if (pDoc==NULL)
	{
		cout<<"GetDocument Failed"<<endl;
		return;
	}
	//ISO投图
	vector<CATIDftSheet*> lstSheets;
	_pGeneralCls->GetAllSheets(pDoc,lstSheets);
	CATLISTP(CATIProduct) lstProducts = NULL;
	_pGeneralCls->GetAllRootPrdFromWindows(lstProducts);
	//CATIView_var spiViewISO = _pGeneralCls->CreateISOView(lstSheets[0],lstProducts[1],mathPlaneScreen);
	CATIView_var spiViewISO = _pGeneralCls->CreateISOView(lstSheets[0],lstCATPart,mathPlaneScreen);

	//画点
	CATI2DWFFactory_var spi2DWFFactory = spiViewISO;
	for (int i=0; i <=3; i++)
	{
		double arrd[2];
		_pGeneralCls->Coord3DTransformTo2D(spiViewISO,BoundingBox2Dnew[i],arrd);
		cout<<i+1<<" : "<<arrd[0]<<" , "<<arrd[1]<<endl;
		CATISpecObject_var spiSpecCircle = spi2DWFFactory->CreatePoint(arrd);
		spiSpecCircle->Update();
	}

	RequestDelayedDestruction();

	*/


}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TestUserDefinedMathBoxCmd::~TestUserDefinedMathBoxCmd()
{
   cout<<"Test Ending............."<<endl;

	if (_Indication != NULL) 
      _Indication->RequestDelayedDestruction();

	if (_pGeneralCls != NULL)
	{
		delete _pGeneralCls;
		_pGeneralCls = NULL;
	}
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TestUserDefinedMathBoxCmd::BuildGraph()
{


  // TODO: Define the StateChart 
  // ---------------------------
  _Indication = new CATIndicationAgent ("Indication");
  CATMathPlane PlaneXY;
  _Indication -> SetMathPlane (PlaneXY);
  CATDialogState * initialState = GetInitialState("initialState");
  initialState -> AddDialogAgent (_Indication);
  
  AddTransition( initialState, NULL, 
                 IsOutputSetCondition (_Indication),
                 Action ((ActionMethod) &TestUserDefinedMathBoxCmd::ActionOne));
}


//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TestUserDefinedMathBoxCmd::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}


//描述：高亮某对象
//输入：CATISpecObject对象
//输出：CATBoolean
//返回：CATBoolean
CATBoolean TestUserDefinedMathBoxCmd::AddHSO(CATBaseUnknown_var ispSpecSelect)
{
	HRESULT rc=S_OK;

	CATFrmEditor * pEditor=NULL;
	pEditor = CATFrmEditor::GetCurrentEditor();
	if(pEditor==NULL)
		return FALSE;

	CATHSO * pHSO = pEditor->GetHSO();
	if(pHSO==NULL)
		return FALSE;

	//if (pHSO != NULL)
	//	pHSO->Empty();

	if ((ispSpecSelect != NULL_var) && (pEditor != NULL) && (pHSO != NULL))
	{
		CATIBuildPath *piBuildPath = NULL;
		HRESULT rc = ispSpecSelect->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
		if (SUCCEEDED(rc))
		{
			CATPathElement context = pEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
			if (pPathElement != NULL)
			{
				CATUnicodeString strPath = "";
				_pGeneralCls->PathElementString(pPathElement,strPath);
				cout<<strPath<<endl;
				pHSO->AddElement(pPathElement);
				pPathElement->Release();
				pPathElement = NULL;
			}
			piBuildPath->Release();
			piBuildPath = NULL;
		}
	}

	return TRUE;
}

//从view中获取所有的不重复的端点
HRESULT TestUserDefinedMathBoxCmd::GetAllPointsFromView(CATIView_var ispiView,vector<CATMathPoint2D> &ovecPt)
{
	HRESULT rc = S_OK;
	if (ispiView==NULL_var)
	{
		return E_FAIL;
	}

	vector<CATMathPoint2D> vecPt;

	CATIDftView* piDftView=NULL;
	rc=ispiView->QueryInterface(IID_CATIDftView, (void**)&piDftView);
	if(SUCCEEDED(rc)&&piDftView!=NULL)
	{
		IUnknown* piGenView = NULL;
		if(SUCCEEDED(piDftView->GetApplicativeExtension(IID_CATIDftGenView,&piGenView)))
		{
			CATIDftGenGeomAccess* piGenGeomAccess = NULL;
			if(SUCCEEDED(piGenView->QueryInterface(IID_CATIDftGenGeomAccess,(void**)&piGenGeomAccess)))
			{
				// Get a list containing all Generated Geometry of the view
				CATIUnknownList* piList=NULL;
				if( SUCCEEDED(piGenGeomAccess->GetAllGeneratedItems(IID_CATIDftGenGeom,&piList)))
				{
					if(piList!=NULL)
					{
						unsigned int iListSize = 0;
						piList->Count(&iListSize);
						//cout<<"# The Number Of Generated Geometry:"<<iListSize<<endl;

						IUnknown* item = NULL;
						// Loop on all Generated Geometry of the view.
						for(unsigned int iFirCount=0;iFirCount<iListSize;iFirCount++)
						{
							if( SUCCEEDED(piList->Item(iFirCount,&item)))
							{
								IDMCurve2D* piIDMCurve2D = NULL;
								double arrStartPt[2],arrEndPt[2];
								if(SUCCEEDED(item->QueryInterface(IID_IDMCurve2D,(void**)&piIDMCurve2D)))
								{
									piIDMCurve2D->GetEndPoints(arrStartPt,arrEndPt);
									CATMathPoint2D pt1(arrStartPt);
									CATMathPoint2D pt2(arrEndPt);
									if (FALSE==this->IsOccurInList(pt1,vecPt))
									{
										vecPt.push_back(pt1);
									}
									if (FALSE==this->IsOccurInList(pt2,vecPt))
									{
										vecPt.push_back(pt2);
									}
								}
								item->Release();
								item = NULL;
							}							
						}
						piList->Release();
						piList = NULL;
					}
					piGenGeomAccess->Release();
					piGenGeomAccess = NULL;
				}
			}
			piGenView->Release();
			piGenView=NULL;
		}
	}

	ovecPt.swap(vecPt);
	return rc;
}

CATBoolean TestUserDefinedMathBoxCmd::IsOccurInList(CATMathPoint2D iPt2D,vector<CATMathPoint2D> ivecPt2D)
{
	CATBoolean bOccur = FALSE;
	for (int i=0;i<ivecPt2D.size();i++)
	{
		CATMathPoint2D ptInList = ivecPt2D[i];
		double dDist = iPt2D.DistanceTo(ptInList);
		if (dDist<0.001)
		{
			bOccur = TRUE;
			break;
		}
	}
	return bOccur;
}

HRESULT TestUserDefinedMathBoxCmd::GetMinOuterCircle(vector<CATMathPoint2D> ivecPt2D,UserDefinedCircle &oOuterCircle)
{
	HRESULT rc = S_OK;
	//点列表中必须至少有2个点
	if (ivecPt2D.size()<2)
	{
		return E_FAIL;
	}
	//先取列表头2个点，计算出初始的外接圆
	CATMathPoint2D pt1=ivecPt2D[0];
	CATMathPoint2D pt2=ivecPt2D[1];
	oOuterCircle.ptCenter = 0.5*(pt1+pt2);
	oOuterCircle.dRadius = 0.5*(pt1.DistanceTo(pt2));
	
	//从列表第三个点开始循环
	for (int i=2;i<ivecPt2D.size();i++)
	{
		CATMathPoint2D ptCurrent = ivecPt2D[i];
		if (TRUE==this->IsIncludedInCircle(ptCurrent,oOuterCircle))	//如果当前点在当前状态的外接面内，则继续下个循环
		{
			continue;
		}
		else
		{
			vector<CATMathPoint2D> vecPtCurrent;
			vecPtCurrent.assign(ivecPt2D.begin(),ivecPt2D.begin()+i);
			rc = this->MinOuterCircleWithOnePoint(vecPtCurrent,ptCurrent,oOuterCircle);
		}
	}



	return rc;
}

HRESULT TestUserDefinedMathBoxCmd::MinOuterCircleWithOnePoint(vector<CATMathPoint2D> ivecPt2D,CATMathPoint2D iPt,UserDefinedCircle &oOuterCircle)
{
	HRESULT rc = S_OK;
	//
	if (ivecPt2D.size()<1)
	{
		return E_FAIL;
	}
	//根据列表第一个和输入的点，求出初始外接圆
	CATMathPoint2D pt1 = ivecPt2D[0];
	CATMathPoint2D pt2 = iPt;
	oOuterCircle.ptCenter = 0.5*(pt1+pt2);
	oOuterCircle.dRadius = 0.5*(pt1.DistanceTo(pt2));

	//从列表第二位开始循环
	for (int i=1;i<ivecPt2D.size();i++)
	{
		CATMathPoint2D ptCurrent = ivecPt2D[i];
		if (TRUE==this->IsIncludedInCircle(ptCurrent,oOuterCircle))	//如果当前点在当前状态的外接面内，则继续下个循环
		{
			continue;
		}
		else
		{
			vector<CATMathPoint2D> vecPtCurrent;
			vecPtCurrent.assign(ivecPt2D.begin(),ivecPt2D.begin()+i);
			rc = this->MinOuterCircleWithTwoPoints(vecPtCurrent,ptCurrent,iPt,oOuterCircle);
		}
	}

	return rc;
}

HRESULT TestUserDefinedMathBoxCmd::MinOuterCircleWithTwoPoints(vector<CATMathPoint2D> ivecPt2D,CATMathPoint2D iPt1,CATMathPoint2D iPt2,UserDefinedCircle &oOuterCircle)
{
	HRESULT rc = S_OK;

	//根据输入的点，求出初始外接圆
	CATMathPoint2D pt1 = iPt1;
	CATMathPoint2D pt2 = iPt2;
	oOuterCircle.ptCenter = 0.5*(pt1+pt2);
	oOuterCircle.dRadius = 0.5*(pt1.DistanceTo(pt2));

	//从列表第一位开始循环
	for (int i=0;i<ivecPt2D.size();i++)
	{
		CATMathPoint2D ptCurrent = ivecPt2D[i];
		if (TRUE==this->IsIncludedInCircle(ptCurrent,oOuterCircle))	//如果当前点在当前状态的外接面内，则继续下个循环
		{
			continue;
		}
		else
		{
			//先判断三点是否共线
			CATMathVector2D dir1 = pt1 - ptCurrent;
			CATMathVector2D dir2 = pt2 - ptCurrent;
			CATAngle angleDir = abs(dir1.GetAngleTo(dir2));
			if ((angleDir>=0&&angleDir<=0.01)||(angleDir<=CATPI&&angleDir>=CATPI-0.01))	//如果3点共线，取最外侧的两个点算出外接圆
			{
				CATMathPoint2D opt1,opt2;
				double dDist1 = pt1.DistanceTo(ptCurrent);
				double dDist2 = pt2.DistanceTo(ptCurrent);
				double dDist3 = pt1.DistanceTo(pt2);
				double dDistMax = dDist1;
				opt1 = pt1;
				opt2 = ptCurrent;
				if (dDist2>dDistMax)
				{
					dDistMax = dDist2;
					opt1 = pt2;
					opt2 = ptCurrent;
				}
				if (dDist3>dDistMax)
				{
					opt1 = pt1;
					opt2 = pt2;
				}
				oOuterCircle.ptCenter = 0.5*(opt1+opt2);
				oOuterCircle.dRadius = 0.5*dDistMax;
			}
			else	//三点取圆
			{
				CATMathPoint ptA(pt1.GetX(),pt1.GetY(),0);
				CATMathPoint ptB(pt2.GetX(),pt2.GetY(),0);
				CATMathPoint ptC(ptCurrent.GetX(),ptCurrent.GetY(),0);
				CATMathPoint oCenter;
				double dRadius;
				this->GetCenterAndRadius(ptA,ptB,ptC,oCenter,dRadius);

				//
				oOuterCircle.dRadius = dRadius;
				oOuterCircle.ptCenter = CATMathPoint2D(oCenter.GetX(),oCenter.GetY());
			}
		}
	}

	return rc;
}
//判断点是否包含于外接圆
CATBoolean TestUserDefinedMathBoxCmd::IsIncludedInCircle(CATMathPoint2D iPt,UserDefinedCircle iCircle)
{
	CATBoolean bIsIncluded = FALSE;

	CATMathPoint2D ptCenter = iCircle.ptCenter;
	double dRadius = iCircle.dRadius;
	double dDist = iPt.DistanceTo(ptCenter);
	if (dDist<=dRadius)
	{
		bIsIncluded = TRUE;
	}

	return bIsIncluded;
}

void TestUserDefinedMathBoxCmd::GetCenterAndRadius(CATMathPoint iPTA,CATMathPoint iPTB,CATMathPoint iPTC,CATMathPoint &oPT,double &oRadius)
{
	double dPx,dQx,dRx;
	double dPy,dQy,dRy;
	double dPz,dQz,dRz;
	//	double dX0,dY0,dZ0;

	dPx=iPTA.GetX();
	dQx=iPTB.GetX();
	dRx=iPTC.GetX();

	dPy=iPTA.GetY();
	dQy=iPTB.GetY();
	dRy=iPTC.GetY();

	dPz=iPTA.GetZ();
	dQz=iPTB.GetZ();
	dRz=iPTC.GetZ();

	// 	//算平面法量
	// 	double pi,pj,pk;
	// 	double x1=dQx-dPx;
	// 	double x2=dRx-dPx;
	// 
	// 	double y1=dQy-dPy;
	// 	double y2=dRy-dPy;
	// 
	// 	double z1=dQz-dPz;
	// 	double z2=dRz-dPz;
	// 
	// 	pi=y1*z2-z1*y2;
	// 	pj=z1*x2-x1*z2;
	// 	pk=x1*y2-y1*x2;
	// 
	// 	//求PQ和PR的中垂线
	// 	//1，过PQ的中点(Mx,My,Mz),
	// 
	// 	double dMx,dMy,dMz;
	// 
	// 	dMx=(dPx+dQx)/2;
	// 	dMy=(dPy+dQy)/2;
	// 	dMz=(dPz+dQz)/2;
	// 
	// 	//（Mi,Mj,Mk）＝（pi，pj，pk）×（x1,y1,z1）垂直
	// 	double dMi,dMj,dMk;
	// 	dMi=pj*z1-pk*y1;
	// 	dMj=pk*x1-pi*z1;
	// 	dMk=pi*y1-pj*x1;
	// 
	// 	//2，过PR的中点(Nx,Ny,Nz),
	// 	double dNx,dNy,dNz;
	// 
	// 	dNx=(dPx+dRx)/2;
	// 	dNy=(dPy+dRy)/2;
	// 	dNz=(dPz+dRz)/2;
	// 
	// 	//（Ni,Nj,Nk）＝（pi，pj，pk）×（x2,y2,z2）垂直
	// 	double dNi,dNj,dNk;
	// 
	// 	dNi=pj*z2-pk*y2;
	// 	dNj=pk*x2-pi*z2;
	// 	dNk=pi*y2-pj*x2;
	// 
	// 	//解两直线交点
	// 	double tn;
	// 	if((dNj*dMi-dMj*dNi)!=0)
	// 	{	
	// 		tn=((dMy-dNy)*dMi+dMj*(dNx-dMx))/(dNj*dMi-dMj*dNi);
	// 	}
	// 	else if((dMi*dNk-dMk*dNi)!=0)
	// 	{	
	// 		tn=((dMz-dNz)*dMi+dMk*(dNx-dMx))/(dNk*dMi-dMk*dNi);
	// 	}
	// 	else if((dMj*dNk-dMk*dNj)!=0)
	// 	{	
	// 		tn=((dMz-dNz)*dMj+dMk*(dNy-dMy))/(dMj*dNk-dMk*dNj);
	// 	}
	// 	dX0=dNx+dNi*tn;
	// 	dY0=dNy+dNj*tn;
	// 	dZ0=dNz+dNk*tn;
	// 
	// 	//得半径
	// 	oRadius=(dX0-dPx)*(dX0-dPx)+(dY0-dPy)*(dY0-dPy)+(dZ0-dPz)*(dZ0-dPz);
	// 	oPT.SetCoord(dX0,dY0,dZ0);
	// 	oRadius=sqrt(oRadius);
	double x1=iPTA.GetX();
	double x2=iPTB.GetX();
	double x3=iPTC.GetX();

	double y1=iPTA.GetY();
	double y2=iPTB.GetY();
	double y3=iPTC.GetY();

	double z1=iPTA.GetZ();
	double z2=iPTB.GetZ();
	double z3=iPTC.GetZ();

	double a1, b1, c1, d1;
	double a2, b2, c2, d2;
	double a3, b3, c3, d3;

	a1 = (y1*z2 - y2*z1 - y1*z3 + y3*z1 + y2*z3 - y3*z2);
	b1 = -(x1*z2 - x2*z1 - x1*z3 + x3*z1 + x2*z3 - x3*z2);
	c1 = (x1*y2 - x2*y1 - x1*y3 + x3*y1 + x2*y3 - x3*y2);
	d1 = -(x1*y2*z3 - x1*y3*z2 - x2*y1*z3 + x2*y3*z1 + x3*y1*z2 - x3*y2*z1);

	a2 = 2 * (x2 - x1);
	b2 = 2 * (y2 - y1);
	c2 = 2 * (z2 - z1);
	d2 = x1 * x1 + y1 * y1 + z1 * z1 - x2 * x2 - y2 * y2 - z2 * z2;

	a3 = 2 * (x3 - x1);
	b3 = 2 * (y3 - y1);
	c3 = 2 * (z3 - z1);
	d3 = x1 * x1 + y1 * y1 + z1 * z1 - x3 * x3 - y3 * y3 - z3 * z3;

	double x, y, z;
	x = -(b1*c2*d3 - b1*c3*d2 - b2*c1*d3 + b2*c3*d1 + b3*c1*d2 - b3*c2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);
	y = (a1*c2*d3 - a1*c3*d2 - a2*c1*d3 + a2*c3*d1 + a3*c1*d2 - a3*c2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);
	z = -(a1*b2*d3 - a1*b3*d2 - a2*b1*d3 + a2*b3*d1 + a3*b1*d2 - a3*b2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);

	oPT.SetCoord(x,y,z);
	double r = 0.0;
	r = sqrt((x1 - x)*(x1 - x) + (y1 - y)*(y1 - y) + (z1 - z)*(z1 - z));
	r = sqrt((x2 - x)*(x2 - x) + (y2 - y)*(y2 - y) + (z2 - z)*(z2 - z));
	r = sqrt((x3 - x)*(x3 - x) + (y3 - y)*(y3 - y) + (z3 - z)*(z3 - z));
	oRadius=r;

}

//获取在一定范围内的点集
void TestUserDefinedMathBoxCmd::GetPointsInsideBox(CATMathPoint2D iPtLL,CATMathPoint2D iPtRH,vector<CATMathPoint2D> &iovecPtFiltered)
{
	vector<CATMathPoint2D> vecPt;
	for (int i=0;i<iovecPtFiltered.size();i++)
	{
		CATMathPoint2D mathPt = iovecPtFiltered[i];
		if (mathPt.GetX()>=iPtLL.GetX()&&mathPt.GetX()<=iPtRH&&mathPt.GetY()>=iPtLL.GetY()&&mathPt.GetY()<=iPtRH.GetY())
		{
			vecPt.push_back(mathPt);
		}
	}
	iovecPtFiltered.swap(vecPt);
}
//获取凸多边形边界
HRESULT TestUserDefinedMathBoxCmd::GetConvexHull(vector<CATMathPoint2D> ivecPt2D, vector<CATMathPoint2D> &ovecPtConvexHull)
{
	HRESULT rc = S_OK;
	//先找到y值最小的点
	double dYmin = DBL_MAX;
	int iIndexMin = 0;
	for (int i=0;i<ivecPt2D.size();i++)
	{
		CATMathPoint2D mathPt = ivecPt2D[i];
		double dYcoord = mathPt.GetY();
		if (dYcoord<dYmin)
		{
			dYmin = dYcoord;
			iIndexMin = i;
		}
	}
	CATMathPoint2D mathPtFirst = ivecPt2D[i];
	ivecPt2D.erase(ivecPt2D.begin()+iIndexMin);
	//把该最小点和其他所有点分别做向量，求出和x正向最小的夹角和最大的夹角，获取对应的两个点
	int iIndexMinAngle = 0;
	int iIndexMaxAngle = 0;
	for (int i=1;i<ivecPt2D.size();i++)	//先以第一位作为初始，从第二位开始循环
	{
		CATMathVector2D dirMinAngle = ivecPt2D[iIndexMinAngle]-mathPtFirst;
		CATMathVector2D dirMaxAngle = ivecPt2D[iIndexMaxAngle]-mathPtFirst;
		CATAngle angleMin = CATMathVector2D(1,0).GetAngleTo(dirMinAngle);
		CATAngle angleMax = CATMathVector2D(1,0).GetAngleTo(dirMaxAngle);

		CATMathVector2D dirCurrent = ivecPt2D[i]-mathPtFirst;
		CATAngle angleCurrent = CATMathVector2D(1,0).GetAngleTo(dirCurrent);

		if (angleCurrent<angleMin)
		{
			angleMin = angleCurrent;
			iIndexMinAngle = i;
		}
		if (angleCurrent>angleMax)
		{
			angleMax = angleCurrent;
			iIndexMaxAngle = i;
		}
	}
	//从起始点开始，和x正向夹角最小的那个点肯定是最终列表中的第二个点，夹角最大的是最终列表的最后一个点
	CATMathVector2D mathPtSecond = ivecPt2D[iIndexMinAngle];
	CATMathVector2D mathPtLast = ivecPt2D[iIndexMaxAngle];
	ovecPtConvexHull.push_back(mathPtFirst);
	ovecPtConvexHull.push_back(mathPtSecond);
	ivecPt2D.erase(ivecPt2D.begin()+iIndexMinAngle);
	ivecPt2D.erase(ivecPt2D.begin()+iIndexMaxAngle);
	//
	for (int i=0;i<ivecPt2D.size();i++)
	{
		//最终列表的当前状态的最后一个点和当前列表的点组成base line，然后判断其他点相对这根线的位置
		CATMathPoint2D ptLast = ovecPtConvexHull[ovecPtConvexHull.size()-1];
		CATMathPoint2D ptJudgeCurrent = ivecPt2D[i];
		CATBoolean bIsOnRightSide = FALSE;
		for (int j=0;j<ivecPt2D.size();j++)
		{
			if (i==j)
			{
				continue;
			}
			CATMathPoint2D ptCurrent = ivecPt2D[j];
			if (IsOnRightSide(ptLast,ptJudgeCurrent,ptCurrent))	//如果点在线的右侧，该点作为新的输入重新循环，直至所有点都在左侧
			{
				ptJudgeCurrent = ptCurrent;
				i=j;
				j=-1;
				bIsOnRightSide = TRUE;
			}
		}

	}

	ovecPtConvexHull.push_back(mathPtLast);

	return rc;
}

//判断点是否在直线的右侧，如果是，后续操作需要把judge2代替judge1
CATBoolean TestUserDefinedMathBoxCmd::IsOnRightSide(CATMathPoint2D iPtBase,CATMathPoint2D iPtJudge1,CATMathPoint2D iPtJudge2)
{
	CATMathVector2D dirBase = iPtJudge1 - iPtBase;
	CATMathVector2D dirJudge = iPtJudge2 - iPtBase;

	double dCross = dirBase.GetX()*dirJudge.GetY()-dirJudge.GetX()*dirBase.GetY();

	if (dCross>0)
	{
		return FALSE;
	}
	else if (dCross<0)
	{
		return TRUE;
	}
	else if (dCross==0)
	{
		double dLengthBase = sqrt(dirBase.GetX()*dirBase.GetX()+dirBase.GetY()*dirBase.GetY());
		double dLengthJudge = sqrt(dirJudge.GetX()*dirJudge.GetX()+dirJudge.GetY()*dirJudge.GetY());
		if (dLengthBase>dLengthJudge)
		{
			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}
}