// COPYRIGHT Dassault Systemes 2018
//===================================================================
//
// CAACommonModule.cpp
// Header definition of CAACommonModule
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Oct 2018  Creation: Code generated by the CAA wizard  music
//===================================================================
#include "CAACommonModule.h"

#include "iostream.h"
#include <cmath>
#include <string>
#include <windows.h>
#include <fstream>
#include <vector>
using namespace std;


#include "CATIndicationAgent.h"
#include "CATPathElementAgent.h"
#include "CATDialogAgent.h"
#include "CATOtherDocumentAgent.h"
#include "CATCreateExternalObject.h"

#include "CATMathPlane.h"
#include "CATFrmLayout.h"
#include "CATListOfCATFrmWindow.h"
#include "CATUnicodeString.h"
#include "CATDocument.h"
#include "CATFrmEditor.h"
#include "CATIDocId.h"
#include "CATIDocRoots.h"
#include "CATISpecObject.h"
#include "CATISpecAttrAccess.h"
#include "CATISpecAttrKey.h"
#include "CATISpecDeclarations.h"
#include "CATDlgNotify.h"
#include "CATDlgUtility.h"
#include "CATListOfCATUnicodeString.h"
#include "CATLISTV_CATISpecAttrKey.h"
#include "CATListOfInt.h"
#include "CATListOfDouble.h"
#include "CATICamera.h"
#include "CATFrmLayout.h"
#include "CATFrmWindow.h"
#include "CATPathElement.h"
#include "CATApplicationFrame.h"
#include "CATCommand.h"
#include "CATIBRepAccess.h"
#include "CATIFeaturize.h"
#include "CATMfBRepDefs.h"
#include "CATIProduct.h"
#include "CATGeometry.h"

#include "CATMathBox.h"
#include "CATIPrtPart.h"
#include "CATIDescendants.h"
#include "CATBody.h"
#include "CATIMfBRep.h"
#include "CATIGeometricalElement.h"
#include "CATIBodyRequest.h"
#include "CATIContainer.h"
#include "CATIPrtContainer.h"
#include "CATInit.h"
#include "CATIAlias.h"
#include "CATIMovable.h"
#include "CATMathTransformation.h"
#include "CATMathPoint.h"
#include "CATMathVector.h"
#include "CATLISTV_CATMathPoint.h"
#include "CATMathPlane.h"
#include "CATMathLine.h"
#include "CATMathAxis.h"
#include "CATPoint.h"
#include "CATVertex.h"
#include "CATBody.h"
#include "CATListOfCATCells.h"
#include "CATEdge.h"
#include "CATIVisProperties.h"
#include "CATVisPropertiesValues.h"
#include "CATVisGeomType.h"
#include "CATVisPropertyType.h"
#include "CATShowAttribut.h"
#include "CATIInertia.h"
 
CATImplementClass( CAACommonModule,
                   Implementation, 
                   CATBaseUnknown,
                   CATNull );
 
//-----------------------------------------------------------------------------
// CAACommonModule : constructor
//-----------------------------------------------------------------------------
CAACommonModule::CAACommonModule():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// CAACommonModule : destructor
//-----------------------------------------------------------------------------
CAACommonModule::~CAACommonModule()
{
}
 
//-----------------------------------------------------------------------------
// CAACommonModule : copy constructor
//-----------------------------------------------------------------------------
CAACommonModule::CAACommonModule(CAACommonModule& original):
   CATBaseUnknown(original)
{
}
 
//-----------------------------------------------------------------------------
// CAACommonModule : equal operator
//-----------------------------------------------------------------------------
CAACommonModule& CAACommonModule::operator=(CAACommonModule& original)
{
   CATBaseUnknown::operator=(original);
   return *this;
}

//描述：写入错误信息
//输入：CATUnicodeString
//输出：void
//返回：void
CATBoolean WriteErrorLog(CATUnicodeString strErrorPath,CATUnicodeString strErrorMsg)
{
	ofstream errorfile(strErrorPath.ConvertToChar(),ios::app);
	char strchar[1000];
	CAAUStringConvertToChar(strErrorMsg,strchar);
	errorfile<<(CATTime::GetCurrentLocalTime()).ConvertToString("%Y/%m/%d,%H:%M:%S")<<":"<<strchar<<"\n";
	errorfile.close();
	return TRUE;
}

//描述：添加记录功能-获取初始记录
//输入：istrFuncString功能名称
//输出：ostrUserInfo用户使用记录,oStartTime程序启动时间
//返回：HRESULT
HRESULT AddUsedHistory0(CATUnicodeString istrFuncString,CATUnicodeString &ostrErrorPath)
{
	HRESULT oResult = S_OK;
	CATTime oStartTime = CATTime::GetCurrentLocalTime();
	CATUnicodeString strErrorDir = "C:\\cattmp";
	if(!DirExists(strErrorDir.ConvertToChar()))
	{
		CreateDirectory(strErrorDir,NULL) ;
	}
	ostrErrorPath.Append("C:\\cattmp\\KBEErrorLog_"); 
	ostrErrorPath.Append(istrFuncString ); 
	ostrErrorPath.Append("_"); 
	ostrErrorPath.Append(oStartTime.ConvertToString("%Y%m%d")); 
	ostrErrorPath.Append(".txt"); 

	return oResult ;
}

//描述：添加记录功能-获取初始记录
//输入：istrFuncString功能名称
//输出：ostrUserInfo用户使用记录,oStartTime程序启动时间
//返回：HRESULT
HRESULT AddUsedHistory1(CATUnicodeString istrFuncString,CATUnicodeString &ostrUserInfo,CATTime &oStartTime)
{
	HRESULT oResult = S_OK;
	ostrUserInfo = "";
	oStartTime = CATTime::GetCurrentLocalTime();
	CATUnicodeString strStartTime = oStartTime.ConvertToString("%Y/%m/%d,%H:%M:%S,%p,%A");
	CATUnicodeString strLoginName = "UnKnownLoginName";

	char strLoginNameChar[1000];
	if(CATGetLoginName(strLoginNameChar,1000) == CATLibError)
	{
		oResult = E_FAIL;
	}
	else
	{
		strLoginName = CAAUStringBuildFromChar(strLoginNameChar);
	}

	ostrUserInfo.Append(istrFuncString);
	ostrUserInfo.Append(",");
	ostrUserInfo.Append(strLoginName);
	ostrUserInfo.Append(",");
	ostrUserInfo.Append(strStartTime);
	ostrUserInfo.Append(","); 

	return oResult ;
}

//描述：添加记录功能-获取剩余记录
//输入：iStartTime程序启动时间
//输出：ostrUserInfo用户使用记录
//返回：void
void AddUsedHistory2(CATTime iStartTime, CATUnicodeString &ostrUserInfo)
{
	//获取程序变量
	char* docPath = "KBETracePath";															//保存模版的环境变量名
	char* docPathValue = NULL;																//保存莫班的环境变量对应的路
	CATLibStatus envState = ::CATGetEnvValue(docPath,&docPathValue);							//获得保存模版的环境变量的值
	CATUnicodeString strUserInfoDirect = docPathValue;
	strUserInfoDirect.Append("\\KBE_Traces\\CATIA");
	if(DirExists(strUserInfoDirect.ConvertToChar()))
	{
		strUserInfoDirect.Append("\\2DTools.txt");
	}
	else
	{
		strUserInfoDirect = "C:\\ToolTestData";
		CreateDirectory(strUserInfoDirect,NULL) ;
		strUserInfoDirect.Append("\\2DTools.txt");
	}

	//结束时间
	CATTime currentEndTime = CATTime::GetCurrentLocalTime();
	CATTimeSpan runtime =  currentEndTime - iStartTime;
	CATUnicodeString strSec = NULL;
	strSec.BuildFromNum(runtime.GetTotalSeconds());
	ostrUserInfo.Append("DurationTime:");
	ostrUserInfo.Append(strSec);
	ostrUserInfo.Append("S");
	char strchar[1000];
	CAAUStringConvertToChar(strUserInfoDirect,strchar);
	ofstream file(strchar,ios::app);
	file<<ostrUserInfo<<"\n";
	file.close(); //使用完毕之后需要关闭
}

bool DirExists(const std::string& dirName_in)
{
	DWORD ftyp = GetFileAttributesA(dirName_in.c_str());
	if (ftyp == INVALID_FILE_ATTRIBUTES)
	{
		return false; 
	}

	if (ftyp & FILE_ATTRIBUTE_DIRECTORY)
	{
		return true;  
	}
	return false;
}

CATUnicodeString CAAUStringBuildFromUString(CATUnicodeString strUnicode)
{
	char pchars2[10000] ;
	const char* pchars = strUnicode.ConvertToChar();
	strcpy(pchars2,pchars);
	CATUnicodeString strresult = CAAUStringBuildFromChar(pchars2);
	return strresult;
}
CATUnicodeString CAAUStringBuildFromChar(char * strchar)
{
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	wchar_t* strwcANSI = new wchar_t[len + 1]; 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
	CATUnicodeString strwcUnicode;
	strwcUnicode.BuildFromWChar(strwcANSI); 
	if(strwcANSI) delete [] strwcANSI;
	return strwcUnicode;
}

void CAAUStringConvertToChar(CATUnicodeString strUnicode,char* strchar )
{
	int len = WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, NULL, 0, NULL, NULL); 
	memset(strchar, 0, len + 1); 
	WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, strchar, len, NULL, NULL); 
}

void CAAUStringConvertToWChar(CATUnicodeString strUnicode, wchar_t* strwcANSI)
{
	const char *strchar =  strUnicode.ConvertToChar();
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
}

////通知对话框
//void CAAMessageBox(CATUnicodeString message,CATUnicodeString title)
//{
//	CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), title.ConvertToChar(),CATDlgNfyWarning);
//	if (NULL != pNotifyDlg)
//	{
//		pNotifyDlg->DisplayBlocked(message ,title);
//		pNotifyDlg->RequestDelayedDestruction(); 
//		pNotifyDlg = NULL;
//	}
//}

//从代理中获取特征
CATISpecObject_var  GetSelectObjectFromAgent(CATPathElementAgent * pSelectAgent )
{
	CATISpecObject_var spSelObj = NULL_var;
	CATBaseUnknown_var  spBaseUnkn = pSelectAgent->GetElementValue();
	if ( NULL != spBaseUnkn )
	{
		spSelObj = NULL_var;
		HRESULT rc = spBaseUnkn->QueryInterface(IID_CATISpecObject, (void**)&spSelObj);
		if ( !SUCCEEDED(rc) )
		{
			CATIBRepAccess_var spBRep = spBaseUnkn;
			spSelObj = GetSpecObjFromBRep( spBRep);
		}
	}
	return spSelObj ;
}

//从引用中获取对象
CATISpecObject_var GetSpecObjFromBRep(CATIBRepAccess_var spBRep)
{
	if (spBRep == NULL_var)
	{
		return NULL_var;
	}
	CATISpecObject_var spSpecObj = spBRep;
	if (spSpecObj != NULL_var)
	{	
		return spSpecObj;
	}	
	CATIFeaturize * pFeaturize = NULL;
	HRESULT rc = spBRep->QueryInterface(IID_CATIFeaturize,(void**)&pFeaturize);	
	if(FAILED(rc)||(NULL_var == pFeaturize))
	{
		return spSpecObj; 
	}	
	spSpecObj = pFeaturize->FeaturizeR(MfTemporaryBody|MfSelectingFeatureSupport|MfNoDuplicateFeature);
	return spSpecObj;

}

//获取特征的几何体
CATBody_var  GetBodyFromFeature( const CATISpecObject_var& ispFeature ) 
{ 

	if( ispFeature == NULL_var) 
	{ 
		return NULL_var;
	} 
	CATBody_var spBody = NULL_var; 

	do 
	{ 

		CATIMfBRep_var spBRepOnFeature = ispFeature; 
		if( spBRepOnFeature != NULL_var ) 
		{ 
			spBody = spBRepOnFeature->GetBody(); 
		} 
		else 
		{ 
			CATIGeometricalElement_var spGeometricalElementOnFeature = ispFeature; 
			if( spGeometricalElementOnFeature != NULL_var ) 
			{ 
				spBody = spGeometricalElementOnFeature->GetBodyResult(); 

			} 
			else 
			{ 
				CATIBodyRequest_var spBodyRequestOnModel = ispFeature; 
				if( !spBodyRequestOnModel )
				{ 
					break; 
				} 
				CATListValCATBaseUnknown_var listResult; 
				HRESULT rc = spBodyRequestOnModel->GetResults("MfDefault3DView",listResult); 
				if(FAILED(rc))
				{ 
					break; 
				} 
				if( listResult.Size() == 0 )
				{ 
					break; 
				} 
				CATIGeometricalElement_var spGeometricalElementOnBody = listResult[1]; 
				if(!spGeometricalElementOnBody)
				{ 
					break; 
				} 
				spBody = spGeometricalElementOnBody->GetBodyResult(); 
			} 
		} 

		if( !spBody )
		{ 
			break; 
		} 
	}
	while(FALSE); 

	return spBody; 
}

//获取文档窗口，通过名称
void GetFrmWindowByName(CATUnicodeString WindName , CATFrmWindow** owindow)
{
	CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
	CATLISTP(CATFrmWindow) pWindowList = pLayout->GetWindowList( 0,0)  ;
	if (pWindowList.Size() != 0)
	{
		for (int i =1;i<=pWindowList.Size();i++)
		{
			if(NULL != pWindowList[i])
			{
				CATUnicodeString pWindName = pWindowList[i]->GetBaseName();
				if(WindName == pWindName)
				{
					*owindow = (pWindowList[i]);
					return;
				}
			}
		}
	}
}

//获取文档类型
CATUnicodeString  GetDocumentType( CATFrmWindow * pWind,CATDocument ** pDoc  )
{
	CATUnicodeString oType = "";
	if (pWind!= NULL)
	{
		CATDocument * pCurDoc = NULL;
		CATFrmEditor * pEditor = pWind -> GetEditor();
		if (pEditor!= NULL)
		{
			pCurDoc = pEditor -> GetDocument();
			if(pDoc!= NULL)
			{
				CATIDocId* oDocId = NULL;
				pCurDoc -> GetDocId(&oDocId);
				oDocId -> GetType(oType); 
				oDocId->Release();oDocId = NULL;
				*pDoc = pCurDoc;
				return oType;
			}
			pEditor = NULL;
		}
	}
	return "";
}

//获取Product的根
CATISpecObject_var  GetProductDocumentRoot(CATDocument* pDoc)
{
	HRESULT rc =E_FAIL;
	CATISpecObject_var spRoot = NULL_var;
	if ( NULL != pDoc ) 
	{ 
		CATIDocRoots *piDocRootsOnDoc = NULL;
		rc = pDoc->QueryInterface(IID_CATIDocRoots,(void**) &piDocRootsOnDoc);
		if ( SUCCEEDED(rc) && NULL != piDocRootsOnDoc ) 
		{
			CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
			if (pRootProducts->Size())
			{ 
				spRoot = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			piDocRootsOnDoc->Release();
			piDocRootsOnDoc = NULL;
		}
	} 
	return spRoot;
}




//获取Part的根
CATISpecObject_var  GetPartDocumentRoot(CATDocument* pDoc)
{
	HRESULT rc =E_FAIL;
	CATISpecObject_var spRoot = NULL_var;
	if ( NULL != pDoc ) 
	{ 
		CATInit * piInitOnDoc = NULL;
		rc = pDoc->QueryInterface(IID_CATInit,(void**)&piInitOnDoc);
		if( SUCCEEDED(rc) && piInitOnDoc != NULL) 
		{
			CATIPrtContainer *piPrtContainerOnRoot =(CATIPrtContainer*)piInitOnDoc->GetRootContainer("CATIPrtContainer");
			piInitOnDoc->Release(); piInitOnDoc=NULL;
			if (NULL != piPrtContainerOnRoot) 
			{
				spRoot = piPrtContainerOnRoot->GetPart();
				piPrtContainerOnRoot->Release(); piPrtContainerOnRoot=NULL;
			}
		}
	} 
	return spRoot;
}


//获取Product的根
CATISpecObject_var  GetProductRoot(CATIProduct_var spProduct)
{
	HRESULT rc =E_FAIL;
	CATISpecObject_var spRoot = NULL_var;
	CATIProduct_var spSectionRefProd = spProduct->GetReferenceProduct();
	if (spSectionRefProd != NULL_var)
	{
		CATILinkableObject_var spLink = NULL_var;
		if (SUCCEEDED(spSectionRefProd->QueryInterface(IID_CATILinkableObject, (void**)&spLink))   && NULL_var != spLink ) 
		{
			CATDocument *piDoc = spLink->GetDocument(); 
			if ( NULL != piDoc ) 
			{ 
				CATIDocRoots *piDocRootsOnDoc = NULL;
				rc = piDoc->QueryInterface(IID_CATIDocRoots,(void**) &piDocRootsOnDoc);
				if ( SUCCEEDED(rc) && NULL != piDocRootsOnDoc ) 
				{
					CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
					if (pRootProducts->Size())
					{ 
						spRoot = (*pRootProducts)[1];
						delete pRootProducts;
						pRootProducts = NULL;
					}
					piDocRootsOnDoc->Release();
					piDocRootsOnDoc = NULL;
				}
				piDoc->Release();
				piDoc = NULL;
			} 
		}
	}
	return spRoot;
}

//获取单个零件Product的根
CATISpecObject_var  GetPartInstanceRoot(CATIProduct_var   spPartInstance)
{
	HRESULT rc =E_FAIL ;
	CATISpecObject_var spRoot = NULL_var;
	int childNum = spPartInstance->GetChildrenCount() ;
	if (childNum == 0)
	{
		CATIProduct_var spSectionRefProd = spPartInstance->GetReferenceProduct();
		if (spSectionRefProd != NULL_var)
		{
			CATILinkableObject_var spLink = NULL_var;
			if (SUCCEEDED(spSectionRefProd->QueryInterface(IID_CATILinkableObject, (void**)&spLink))   && NULL_var != spLink ) 
			{
				CATDocument *piDoc = spLink->GetDocument(); 
				if (piDoc != NULL)
				{
					spRoot = GetPartDocumentRoot( piDoc);
					piDoc->Release();
					piDoc = NULL;
				}
			}
		}
	}
	return spRoot;
}

//void GetGeomElmFromGSetAndBody(CATISpecObject_var ispiGSet,vector<CATISpecObject_var>& ospiGeomElmList ,vector<CATISpecObject_var>& ospiGSMElmList ,vector<CATISpecObject_var>& ospiSolidElmList )
//{
//	CATUnicodeString strShowValue = "";
//	GetSpecObjShowAttr(ispiGSet,strShowValue);
//	CATUnicodeString strGSName = ispiGSet->GetName();
//
//	CATUnicodeString strTemp = CAAGsiGetSpecBasicName(ispiGSet);
//
//	if(strShowValue == "Show")
//	{
//					/*
//					Surfacic features sets: 
//					Geometrical Set (or GS) (startup: GSMTool, CATIMmiNonOrderedGeometricalSet) 
//					Ordered Geometrical Set (or OGS) (startup: GSMTool,  CATIMmiOrderedGeometricalSet) 
//
//					Bodies: 
//					Solid features set (user name: Body) (startup: MechanicalTool,CATIMechanicalTool) 
//					Solid and Surfacic features sets (user name: Body) (startup: HybridBody) 
//					*/
//		//GeometricObjects.CATGeometry//PartInterfaces.CATIShape//GSMInterfaces.CATIGSMLinePtDir
//		//CATI3DGeometricalElement//CATISpecObject//CATICGMObject
//		CATIDescendants_var spDesc=NULL_var;
//		if (SUCCEEDED(ispiGSet->QueryInterface(IID_CATIDescendants, (void**)&spDesc)) && spDesc != NULL_var)
//		{
//			CATIMechanicalTool_var spMechanicalTool = NULL_var;
//			if (SUCCEEDED(ispiGSet->QueryInterface(IID_CATIMechanicalTool, (void**)&spMechanicalTool)) && spMechanicalTool != NULL_var)
//			{
//				CATISpecObject_var  spLastShape = spMechanicalTool->GetLastShapeFeatureSuccessfullyUpdated();
//				if(spLastShape != NULL_var)
//				{
//					CATUnicodeString strShowValueSub = "";
//					GetSpecObjShowAttr(spLastShape,strShowValueSub);
//					if(strShowValueSub == "Show")
//					{
//						ospiSolidElmList.push_back(spLastShape);
//					}		
//				}
//			}
//			else
//			{
//				CATListValCATISpecObject_var sp3DGeomElmList = NULL;
//				spDesc->GetDirectChildren( "CATI3DGeometricalElement" ,sp3DGeomElmList );
//				if ( sp3DGeomElmList != NULL  && sp3DGeomElmList.Size()>0)
//				{
//					for(int f = 1;f<=sp3DGeomElmList.Size();f++ )
//					{
//						CATUnicodeString strShowValueSub = "";
//						GetSpecObjShowAttr(sp3DGeomElmList[f],strShowValueSub);
//						if(strShowValueSub == "Show")
//						{
//							CATIShape_var spShape=NULL_var;
//							CATGeometry_var spGeometry=NULL_var;
//							if (SUCCEEDED(sp3DGeomElmList[f]->QueryInterface(IID_CATIShape, (void**)&spShape)) && spShape != NULL_var)
//							{
//								ospiSolidElmList.push_back(sp3DGeomElmList[f]);
//							}
//							if (SUCCEEDED(sp3DGeomElmList[f]->QueryInterface(IID_CATGeometry, (void**)&spGeometry)) && spGeometry != NULL_var)
//							{
//								ospiGeomElmList.push_back(sp3DGeomElmList[f]);
//							}
//							else
//							{
//								ospiGSMElmList.push_back(sp3DGeomElmList[f]);
//							}
//						}
//					}
//				}
//				sp3DGeomElmList = NULL;
//			}
//
//
//			CATListValCATISpecObject_var NonOrderedGSList = NULL;
//			spDesc->GetDirectChildren( "CATIMmiNonOrderedGeometricalSet" ,NonOrderedGSList );
//			if (  NonOrderedGSList != NULL && NonOrderedGSList.Size()>0)
//			{
//				for(int f = 1;f<=NonOrderedGSList.Size();f++ )
//				{
//					GetGeomElmFromGSetAndBody( NonOrderedGSList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
//				}
//			}
//			NonOrderedGSList = NULL;
//
//			CATListValCATISpecObject_var OrderedGSList = NULL;
//			spDesc->GetDirectChildren( "CATIMmiOrderedGeometricalSet" ,OrderedGSList );
//			if ( OrderedGSList != NULL  && OrderedGSList.Size()>0)
//			{
//				for(int f = 1;f<=OrderedGSList.Size();f++ )
//				{
//					GetGeomElmFromGSetAndBody( OrderedGSList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
//				}
//			}
//			 OrderedGSList = NULL;
//
//			CATListValCATISpecObject_var MechToolList = NULL;
//			spDesc->GetDirectChildren( "CATIMechanicalTool" ,MechToolList );
//			if (   MechToolList  != NULL && MechToolList.Size()>0)
//			{
//				for(int f = 1;f<=MechToolList.Size();f++ )
//				{
//					GetGeomElmFromGSetAndBody( MechToolList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
//				}
//			}
//			 MechToolList = NULL;
//		}
//	}
//}



////获取Part的包围盒
//HRESULT GetPartBoundingBox(CATIPrtPart_var spPrtPart,CATMathBox& oPartBoundingBox )
//{
//	HRESULT rc =E_FAIL ;
//
//	if (spPrtPart != NULL_var)
//	{
//		CATIProduct_var spProduct = spPrtPart->GetProduct();
//		CATUnicodeString strPartNumber = spProduct->GetPartNumber();
//		CATIPartRequest_var pPartAsRequest = NULL_var;
//		if (SUCCEEDED(spPrtPart->QueryInterface(IID_CATIPartRequest, (void**)&pPartAsRequest))  && pPartAsRequest != NULL_var)
//		{
//			CATListValCATBaseUnknown_var  spBodyList = NULL;
//			pPartAsRequest->GetDirectBodies("MfDefault3DView",spBodyList);
//			CATListValCATISpecObject_var  spBodyObjList;
//			if(spBodyList !=NULL && spBodyList.Size()>0)
//			{
//				for(int i = 1; i <= spBodyList.Size(); i++)
//				{
//					spBodyObjList.Append(spBodyList[i]);
//				}
//			}
//
//			CATUnicodeString msg = strPartNumber + "\n" ;//////测试用途
//			if(spBodyObjList !=NULL && spBodyObjList.Size()>0)//////测试用途
//			{
//				for(int i = 1; i <= spBodyObjList.Size(); i++)//////测试用途
//				{
//					msg = msg  + spBodyObjList[i]->GetName() + ",  " + spBodyObjList[i]->GetDisplayName() + ",  " +  CAAGsiGetSpecBasicName(spBodyObjList[i])  + "\n";//////测试用途
//				}
//			}
//			CATUnicodeString strToolTestDataDirection = "C:\\ToolTestData\\CommmonTestData.txt";//////测试用途
//			ofstream errorFile(strToolTestDataDirection.ConvertToChar());//////测试用途
//			if (errorFile.is_open())  //////测试用途 
//			{  
//				errorFile << msg;  //////测试用途
//				errorFile.close();  //////测试用途
//			}
//
//			rc = GetBodyListBox(strPartNumber, spBodyObjList,oPartBoundingBox );
//			spBodyList = NULL;
//			spBodyObjList = NULL;
//		}
//	}
//
//	return rc;
//}

//获取Part的包围盒
//HRESULT GetPartBoundingBox(CATIProduct_var spPrtProduct,CATMathBox& oPartBoundingBox )
//{
//	HRESULT rc =E_FAIL ;
//
//	if (spPrtProduct != NULL_var)
//	{
//		CATUnicodeString strPartNumber = spPrtProduct->GetPartNumber();
//		CATIDescendants_var spDescPart=NULL_var;
//		if (SUCCEEDED(spPrtProduct->QueryInterface(IID_CATIDescendants, (void**)&spDescPart))  && spDescPart != NULL_var)
//		{
//			CATListValCATISpecObject_var  spBodyList = NULL;
//			spDescPart->GetAllChildren("CATIMechanicalFeature",spBodyList);
//
//			if(spBodyList !=NULL && spBodyList.Size()>0)
//			{
//				CATIMechanicalFeature_var spMechPart=NULL_var;
//				if (SUCCEEDED(spBodyList[1]->QueryInterface(IID_CATIMechanicalFeature , (void**)&spMechPart))  && spMechPart != NULL_var)
//				{
//					CATISpecObject_var spPart = spMechPart->GetPart();
//					CATIPrtPart_var spPrtPart = spPart;
//					if(spPrtPart != NULL_var)
//					{
//						rc = GetPartBoundingBox( spPrtPart,oPartBoundingBox );
//					}
//				}
//			}
//			else
//			{
//				CATIPrtContainer *piPartContainer = NULL ;
//				CATIPrtPart_var spPrtPart = NULL_var; 
//
//				CATILinkableObject_var spLink =NULL_var;
//				if (SUCCEEDED(spPrtProduct->QueryInterface(IID_CATILinkableObject, (void**)&spLink))   && NULL_var != spLink ) 
//				{
//					CATDocument *piDoc = spLink->GetDocument(); 
//					if ( NULL != piDoc )
//					{ 
//						CATInit *pDocAsInit = NULL;
//						if (SUCCEEDED(piDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit))   && NULL != pDocAsInit ) 
//						{
//							piPartContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");
//							pDocAsInit->Release(); pDocAsInit = NULL ;   
//							if( NULL != piPartContainer )      
//							{
//								CATISpecObject_var spPart = piPartContainer->GetPart() ; 
//								spPrtPart = spPart ;
//							}  				
//						}
//						piDoc-> Release(); piDoc = NULL; 
//					}
//				}
//				if ( NULL !=piPartContainer ) 
//				{ 
//					piPartContainer -> Release(); piPartContainer = NULL; 
//				}
//
//				if(spPrtPart != NULL_var)
//				{
//					rc = GetPartBoundingBox( spPrtPart,oPartBoundingBox );
//				}
//			}
//			spBodyList = NULL;
//		}
//	}
//
//    return rc;
//}

//HRESULT GetBodyListBox(CATUnicodeString strPartNumber, CATListValCATISpecObject_var  spBodyList, CATMathBox& oPartBoundingBox )
//{
//	//GeometricObjects.CATGeometry//PartInterfaces.CATIShape//GSMInterfaces.CATIGSMLinePtDir
//	//CATIGeometricalElement//CATISpecObject//CATICGMObject
//	HRESULT rc =E_FAIL ;
//	int boxNum = 0;
//
//	vector<CATISpecObject_var> ospiGeomElmList;
//	vector<CATISpecObject_var> ospiGSMElmList ;
//	vector<CATISpecObject_var> ospiSolidElmList;
//
//	if(spBodyList !=NULL && spBodyList.Size()>0)
//	{
//		for(int q =1; q<=spBodyList.Size();q++)
//		{
//			GetGeomElmFromGSetAndBody(spBodyList[q],ospiGeomElmList ,ospiGSMElmList ,ospiSolidElmList );
//		}
//	}
//	spBodyList = NULL;
//
//	vector<CATISpecObject_var> spRefChildLst  ;
//	if(ospiGeomElmList.size()>0)
//	{
//		for(int i = 0; i<ospiGeomElmList.size();i++)
//		{
//			spRefChildLst.push_back(ospiGeomElmList[i]);
//		}
//	}
//	if(ospiGSMElmList.size()>0)
//	{
//		for(int i = 0; i<ospiGSMElmList.size();i++)
//		{
//			spRefChildLst.push_back(ospiGSMElmList[i]);
//		}
//	}
//	if(ospiSolidElmList.size()>0)
//	{
//		for(int i = 0; i<ospiSolidElmList.size();i++)
//		{
//			spRefChildLst.push_back(ospiSolidElmList[i]);
//		}
//	}
//
//	int nbChilds = spRefChildLst.size();
//	CATISpecObject_var spRefChildFeat;
//	CATUnicodeString childname;
//	CATUnicodeString childnameLower;
//	CATBody_var spBody;
//	double ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax;
//	double iboxx,iboxy, iboxz;
//	CATUnicodeString DataFilePath;////测试用途
//	CATUnicodeString iboxxStr,iboxyStr, iboxzStr;////测试用途
//	CATUnicodeString iboxxStr2,iboxyStr2, iboxzStr2;////测试用途
//	CATUnicodeString numstr;////测试用途
//	CATIAlias_var spAlias;////测试用途
//
//	if (nbChilds > 0)
//	{
//		CreateDirectory(_testDirection,NULL) ;////测试用途
//		DataFilePath = _testDirection + strPartNumber + "_ISOData.txt";////测试用途
//		CATUnicodeString msg = "";////测试用途
//		time_t t = time(0);////测试用途
//		char timestring[64];////测试用途
//		strftime(timestring, sizeof(timestring), "%Y-%m-%d %H:%M:%S", localtime(&t)); ////测试用途
//		msg = msg + "Time = " + timestring + "；\n\n";////测试用途
//		ofstream oCatAttrFile(DataFilePath.ConvertToChar()); ////测试用途
//
//		for (int i = 0; i < nbChilds; i++)
//		{
//			spRefChildFeat = spRefChildLst[i];
//			if ( spRefChildFeat != NULL_var )
//			{
//				childname = spRefChildFeat->GetName();
//				childnameLower =childname;
//				childnameLower.ToLower();
//				numstr.BuildFromNum(i);////测试用途
//				msg = msg   + numstr + ". 名称 = "  +  childname ;////测试用途
//				spAlias= NULL_var;////测试用途
//				spAlias=  spRefChildFeat;////测试用途
//				if (NULL_var != spAlias)////测试用途
//				{
//					msg = msg  +  "， "  +  spAlias->GetAlias()+  "\n";////测试用途
//				}
//				else////测试用途
//				{
//					msg = msg   +    "\n";////测试用途
//				}
//
//
//
//				if (childnameLower.SearchSubString( "plane") == -1 && childnameLower.SearchSubString( "direction") == -1  
//					&& childnameLower.SearchSubString( "axis") == -1 && childnameLower.SearchSubString( "sketch") == -1
//					&& childnameLower.SearchSubString( "origin") == -1 //&&  childnameLower.SearchSubString( "pocket") == -1
//					//&& childnameLower.SearchSubString( "remove") == -1 &&  childnameLower.SearchSubString( "hole") == -1
//					//&& childnameLower.SearchSubString( "draft") == -1 &&  childnameLower.SearchSubString( "pad") == -1
//					//&& childnameLower.SearchSubString( "split") == -1 &&  childnameLower.SearchSubString( "thickness") == -1
//					//&& childnameLower.SearchSubString( "shell") == -1  
//					)
//				{
//					spBody  = GetBodyFromFeature( spRefChildFeat) ;
//					if (spBody != NULL_var)
//					{
//						CATMathBox tempBox = spBody->GetBoundingBox();
//						tempBox.GetExtremities(ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);
//						iboxx = ioXMax - ioXMin;
//						iboxy = ioYMax - ioYMin;
//						iboxz = ioZMax - ioZMin;
//						iboxxStr.BuildFromNum(iboxx); //////测试用途
//						iboxyStr.BuildFromNum(iboxy);//////测试用途
//						iboxzStr.BuildFromNum(iboxz);//////测试用途
//						msg = msg +  "包围盒预测值 = (" + iboxxStr +  "，" + iboxyStr  +  "，" +  iboxzStr +  ")\n";////测试用途
//						iboxxStr.BuildFromNum(ioXMin); //////测试用途
//						iboxyStr.BuildFromNum(ioYMin);//////测试用途
//						iboxzStr.BuildFromNum(ioZMin);//////测试用途
//						iboxxStr2.BuildFromNum(ioXMax); //////测试用途
//						iboxyStr2.BuildFromNum(ioYMax);//////测试用途
//						iboxzStr2.BuildFromNum(ioZMax);//////测试用途
//						msg = msg +  "包围盒预测值明细 = (" + iboxxStr +  "，" + iboxyStr  +  "，" +  iboxzStr + "，" + iboxxStr2 +  "，" + iboxyStr2  +  "，" +  iboxzStr2 +  ")\n";////测试用途
//						if(!((iboxx < 0.1 && iboxx > -0.1)  ||   (iboxy < 0.1 && iboxy > -0.1)  ||(iboxz < 0.1 && iboxz > -0.1))   )
//						{
//							CATMathBox  BodyMathBox;
//							if (SUCCEEDED(GetBodyBox( spBody,BodyMathBox )))
//							{
//								BodyMathBox.GetExtremities(ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);
//								iboxx = ioXMax - ioXMin;
//								iboxy = ioYMax - ioYMin;
//								iboxz = ioZMax - ioZMin;
//								if(!((iboxx < 0.1 && iboxx > -0.1)  ||   (iboxy < 0.1 && iboxy > -0.1)  ||(iboxz < 0.1 && iboxz > -0.1))   )
//								{
//									boxNum = boxNum + 1;
//									if (boxNum < 1)
//									{
//										oPartBoundingBox = BodyMathBox;
//									}
//									else
//									{
//										oPartBoundingBox.AddInside( BodyMathBox) ;
//									}
//									//////测试用途
//									iboxxStr.BuildFromNum(iboxx); //////测试用途
//									iboxyStr.BuildFromNum(iboxy);//////测试用途
//									iboxzStr.BuildFromNum(iboxz);//////测试用途
//									msg = msg +  "包围盒实际值 = (" + iboxxStr +  "，" + iboxyStr  +  "，" +  iboxzStr +  ")\n";////测试用途
//									iboxxStr.BuildFromNum(ioXMin); //////测试用途
//									iboxyStr.BuildFromNum(ioYMin);//////测试用途
//									iboxzStr.BuildFromNum(ioZMin);//////测试用途
//									iboxxStr2.BuildFromNum(ioXMax); //////测试用途
//									iboxyStr2.BuildFromNum(ioYMax);//////测试用途
//									iboxzStr2.BuildFromNum(ioZMax);//////测试用途
//									msg = msg +  "包围盒实际值明细 = (" + iboxxStr +  "，" + iboxyStr  +  "，" +  iboxzStr + "，" + iboxxStr2 +  "，" + iboxyStr2  +  "，" +  iboxzStr2 +  ")\n";////测试用途
//									//////测试用途
//								}
//							}
//						}
//					}
//				}
//
//			}
//		}
//		if (boxNum >=1)//////测试用途
//		{//////测试用途
//			oPartBoundingBox.GetExtremities(ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);//////测试用途
//			iboxx = ioXMax - ioXMin;//////测试用途
//			iboxy = ioYMax - ioYMin;//////测试用途
//			iboxz = ioZMax - ioZMin;//////测试用途
//			iboxxStr.BuildFromNum(iboxx); //////测试用途
//			iboxyStr.BuildFromNum(iboxy);//////测试用途
//			iboxzStr.BuildFromNum(iboxz);//////测试用途
//			msg = msg +  "\n包围盒总大小 = (" + iboxxStr +  "，" + iboxyStr  +  "，" +  iboxzStr +  ")\n";////测试用途
//
//		}//////测试用途
//		if (oCatAttrFile.is_open()) //////测试用途  
//		{  
//			oCatAttrFile << msg;  //////测试用途
//			oCatAttrFile.close();  //////测试用途
//		} 
//	}
//
//	if (boxNum >=1)
//	{
//		return   S_OK ;
//	}
//	else
//	{
//		return E_FAIL;
//	}
//}

////获取单个零件Product的包围盒
//HRESULT GetPartInstanceBoundingBox(CATIProduct_var spProduct,CATMathPoint oProductBox[8])
//{
//	HRESULT rc =E_FAIL ;
//	CATUnicodeString strPartNumber =  spProduct->GetPartNumber();
//	CATUnicodeString strPartName =""  ;
//	spProduct->GetPrdInstanceName(strPartName);
//	CATUnicodeString strDocName = "";
//	int childCount = spProduct->GetChildrenCount(); 
//	if (childCount == 0)
//	{
//		
//		//获取文档
//		CATIProduct_var spProductRef = spProduct->GetReferenceProduct();
//
//		//获取容器
//		/*
//		CATIPrtContainer *piPartContainer = NULL ;
//		CATIPrtPart_var spPrtPart = NULL_var; 
//		CATTry
//		{
//			CATILinkableObject_var spLink =NULL_var;
//			if (SUCCEEDED(spProductRef->QueryInterface(IID_CATILinkableObject, (void**)&spLink))   && NULL_var != spLink ) 
//			{
//				CATDocument *piDoc = spLink->GetDocument(); 
//				if ( NULL != piDoc )
//				{ 
//					strDocName = piDoc->DisplayName();
//					CATInit *pDocAsInit = NULL;
//					if (SUCCEEDED(piDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit))   && NULL != pDocAsInit ) 
//					{
//						piPartContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");
//						pDocAsInit->Release(); pDocAsInit = NULL ;   
//						if( NULL != piPartContainer )      
//						{
//							CATISpecObject_var spPart = piPartContainer->GetPart() ; 
//							spPrtPart = spPart ;
//						}  				
//					}
//					piDoc-> Release(); piDoc = NULL; 
//				}
//			}
//			if ( NULL !=piPartContainer ) 
//			{ 
//				piPartContainer -> Release(); piPartContainer = NULL; 
//			}
//		}
//		CATCatch(CATError,er)
//		{
//			CATUnicodeString msg = "";
//			msg = strPartName + "\n" + er->GetNLSMessage();
//			er->CATCleanLastError();
//			er-> Release(); er = NULL; 
//			CAAMessageBox(msg,"ErrorNote");
//		}
//		CATEndTry;
//		*/
//
//		if(spProductRef != NULL_var)
//		{
//			CATMathBox PartBox ;
//			double   ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax;
//			rc = GetPartBoundingBox(spProductRef,PartBox);
//			if (rc != E_FAIL)
//			{
//				CATIMovable_var piMovableOnInstance = NULL_var;
//				spProduct -> QueryInterface (IID_CATIMovable,(void**) &piMovableOnInstance);
//				CATMathTransformation absolutePosition;
//				piMovableOnInstance -> GetAbsPosition(absolutePosition );
//
//				PartBox.GetExtremities (ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);
//				CATMathPoint  iLow1(ioXMin,ioYMin,ioZMin);
//				CATMathPoint  iLow2(ioXMin,ioYMax,ioZMin);
//				CATMathPoint  iLow3(ioXMax,ioYMax,ioZMin);
//				CATMathPoint  iLow4(ioXMax,ioYMin,ioZMin);
//				CATMathPoint  iHigh1(ioXMin,ioYMin,ioZMax);
//				CATMathPoint  iHigh2(ioXMin,ioYMax,ioZMax);
//				CATMathPoint  iHigh3(ioXMax,ioYMax,ioZMax);
//				CATMathPoint  iHigh4(ioXMax,ioYMin,ioZMax);
//				oProductBox[0] = (MathPointPositionTransformation(iLow1,absolutePosition));
//				oProductBox[1] = (MathPointPositionTransformation(iLow2,absolutePosition));
//				oProductBox[2] = (MathPointPositionTransformation(iLow3,absolutePosition));
//				oProductBox[3] = (MathPointPositionTransformation(iLow4,absolutePosition));
//				oProductBox[4] = (MathPointPositionTransformation(iHigh1,absolutePosition));
//				oProductBox[5] = (MathPointPositionTransformation(iHigh2,absolutePosition));
//				oProductBox[6] = (MathPointPositionTransformation(iHigh3,absolutePosition));
//				oProductBox[7] = (MathPointPositionTransformation(iHigh4,absolutePosition));
//				//CAAMessageBox(TransformProduct3DBoxInToString(oProductBox),CATUnicodeString("ProductBox"));
//				return   S_OK ;
//			}
//		}
//	}
//	return E_FAIL;
//
//}

//计算出一组点的3D包围盒，根据定义的轴系
void Create3DBoxWithAxis(vector <CATMathPoint> points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector viewZAxis,CATMathPoint onew3DBox[8] ) 
{
	CATMathPoint org = viewOrg;
	CATMathVector xVec = viewXAxis;
	CATMathVector yVec = viewYAxis;
	CATMathVector zVec = viewZAxis;
	CATMathVector nzVec = zVec * -1;
	xVec.Normalize();
	yVec.Normalize();
	zVec.Normalize();
	//CATMathPlane xyPlane(org,xVec,yVec);
	//CATMathPlane xzPlane(org,xVec,zVec);
	CATMathPoint* xyPlaneBox = new CATMathPoint[4];
	PointsProjectingInTo2DBoxOnViewAlongDirection(points,org,xVec,yVec,zVec,xyPlaneBox);
	CATMathPoint* xzPlaneBox = new CATMathPoint[4];
	PointsProjectingInTo2DBoxOnViewAlongDirection(points,org,xVec,zVec,yVec,xzPlaneBox);
	CATMathLine xLine(org,xVec);
	double tempx;
	CATMathPoint basepoint = PointProjectingOnLineAlongDirection(xyPlaneBox[0], xLine,yVec ,tempx);

	double basepoint_arr[3] = {0.0,0.0,0.0};
	double xyPlaneBox0_arr[3] = {0.0,0.0,0.0};
	double xyPlaneBox1_arr[3] = {0.0,0.0,0.0};
	double moveVec0_arr[3] = {0.0,0.0,0.0};
	double moveVec1_arr[3] = {0.0,0.0,0.0};
	basepoint.GetCoord(basepoint_arr);
	xyPlaneBox[0].GetCoord(xyPlaneBox0_arr);
	xyPlaneBox[1].GetCoord(xyPlaneBox1_arr);
	D3VectorSetFromTwoPoint(basepoint_arr,xyPlaneBox0_arr,moveVec0_arr);
	D3VectorSetFromTwoPoint(basepoint_arr,xyPlaneBox1_arr,moveVec1_arr);
	CATMathVector moveVec0(moveVec0_arr);
	CATMathVector moveVec1(moveVec1_arr);
	delete []xyPlaneBox;

	onew3DBox[0] = ( xzPlaneBox[1] + moveVec0);
	onew3DBox[1] = ( xzPlaneBox[0] + moveVec0);	//最大
	onew3DBox[2] = ( xzPlaneBox[3] + moveVec0);
	onew3DBox[3] = ( xzPlaneBox[2] + moveVec0);
	onew3DBox[4] = ( xzPlaneBox[1] + moveVec1);
	onew3DBox[5] = ( xzPlaneBox[0] + moveVec1);
	onew3DBox[6] = ( xzPlaneBox[3] + moveVec1);
	onew3DBox[7] = ( xzPlaneBox[2] + moveVec1);	//最小
	delete []xzPlaneBox;
}

//求出一组空间点投影到某个平面上的2DBox包围盒
void PointsProjectingInTo2DBoxOnViewAlongDirection(vector <CATMathPoint>  points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector iDirection ,CATMathPoint pro2dBox[4]) 
{
	vector <CATMathPoint> boxProjection;
	for(int i = 0 ; i < points.size() ; i++)
	{
		CATMathPoint temp = PointProjectingOnViewAlongDirection( points[i], viewOrg,viewXAxis,viewYAxis, iDirection);
		boxProjection.push_back (temp);
	}
	//CAAMessageBox(TransformVector3DBoxInToString(boxProjection),CATUnicodeString("Vector2DBOX"));
	Get2DBoxOfPointsOnView(boxProjection,  viewOrg,viewXAxis,viewYAxis, pro2dBox ) ;
	//delete boxProjection;
}

//在某个平面上，求出一组点的2D包围盒
void Get2DBoxOfPointsOnView(vector <CATMathPoint> points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathPoint points2dBox[4]) 
{
	CATMathPoint org = viewOrg;
	CATMathVector xVec = viewXAxis;
	CATMathVector yVec = viewYAxis;
	xVec.Normalize();
	yVec.Normalize();
	CATMathLine xline(org,xVec);
	CATMathLine yline(org,yVec);
	double x1,x2,y1,y2;
	for(int i = 0 ; i < points.size() ; i++)
	{
		double tempx;
		PointProjectingOnLineAlongDirection(points[i],xline,yVec ,tempx);
		double tempy;
		PointProjectingOnLineAlongDirection(points[i],yline,xVec ,tempy);
		if (i==1)
		{
			x1 = tempx;
			x2 = tempx;
			y1 = tempy;
			y2 = tempy;
		}
		else
		{
			if(x1 > tempx)
			{
				x1 = tempx;
			}
			else if(x2 < tempx)
			{
				x2 = tempx;
			}
			if(y1 > tempy)
			{
				y1 = tempy;
			}
			else if(y2 < tempy) 
			{
				y2 = tempy;
			}
		}

	}
	points2dBox[0] = (org + (xVec * x1) + (yVec * y1));	//最大 
	points2dBox[1] = (org + (xVec * x1) + (yVec * y2));
	points2dBox[2] = (org + (xVec * x2) + (yVec * y2));	//最小
	points2dBox[3] = (org + (xVec * x2) + (yVec * y1));	
}

//求出一个点投影到某个直线上的位置
CATMathPoint  PointProjectingOnLineAlongDirection(CATMathPoint iProjectingPoint, CATMathLine iLine, CATMathVector iDirection, double & oLength ) 
{
	double line1P1[3] = {0.0,0.0,0.0};
	iLine.GetOrigin().GetCoord(line1P1);
	double line1P2[3] = {0.0,0.0,0.0};
	CATMathVector line1Vec = (CATMathVector)iLine.GetDirection();
	line1Vec.Normalize();
	(iLine.GetOrigin() + line1Vec).GetCoord(line1P2);

	double line2P1[3] = {0.0,0.0,0.0};
	iProjectingPoint.GetCoord(line2P1);
	CATMathVector line2Vec = iDirection;
	line2Vec.Normalize();
	double line2P2[3] = {0.0,0.0,0.0};
	(iProjectingPoint + line2Vec).GetCoord(line2P2);

	double crossPointArray[3] = {0.0,0.0,0.0};
	D3LinesGetCrossPoint( line1P1,line1P2,line2P1,line2P2,crossPointArray);
	CATMathPoint crossPoint(crossPointArray);

	double line1VecUnit[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint( line1P1,line1P2   ,line1VecUnit );
	double projVec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint( line1P1,crossPointArray   ,projVec );
	double projVecUnit[3] = {0.0,0.0,0.0};
	D3VectorUnit(  projVec , projVecUnit);
	oLength = D3VectorLen(projVec);
	if (! D3VectorEqual( line1VecUnit,projVecUnit  ))
	{
		oLength = 0 - oLength;
	}
	return crossPoint;
}

//求出一个空间点投影到某个平面上的位置
CATMathPoint  PointProjectingOnViewAlongDirection( CATMathPoint ipoint, CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector iDirection ) 
{
	double line1P1[3] = {0.0,0.0,0.0};
	ipoint.GetCoord(line1P1);

	double line1P2[3] = {0.0,0.0,0.0};
	CATMathVector line1CATVec = (CATMathVector)iDirection;
	line1CATVec.Normalize();
	(ipoint + line1CATVec).GetCoord(line1P2);
	double line1Vec[3] = {0.0,0.0,0.0};
	line1CATVec.GetCoord(line1Vec);

	double line2P1[3] = {0.0,0.0,0.0};
	CATMathPoint org = viewOrg;

	double Direction[3] = {0.0,0.0,0.0};
 	double viewXAxisArray[3] = {0.0,0.0,0.0};
	double viewYAxisArray[3] = {0.0,0.0,0.0};
	viewXAxis.GetCoord(viewXAxisArray);
	viewYAxis.GetCoord(viewYAxisArray);
	D3CrossProduct(viewXAxisArray,viewYAxisArray,Direction);

	double originPoint[3] = {0.0,0.0,0.0};
	org.GetCoord(originPoint);
	D3PointProjectOnPlane(line1P1, originPoint, Direction,line2P1);

	double line2P2[3] = {0.0,0.0,0.0};
	double line3Vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P1,line3Vec);
	double line1line2Angle =mathPi * 0.5 - D3VectorAngle(line3Vec,line1Vec);

	double vnormal[3] = {0.0,0.0,0.0};
	D3CrossProduct(line3Vec,line1Vec,vnormal);

	if (D3VectorLen(vnormal) == 0)
	{
		return CATMathPoint(line2P1);
	}

	double line2Vec[3] = {0.0,0.0,0.0};
	D3VectorRotate(line1Vec, vnormal,line1line2Angle,line2Vec);
	D3PointMove(line2P1,line2Vec,line2P2);

	double crossPointArray[3] = {0.0,0.0,0.0};
	D3LinesGetCrossPoint( line1P1,line1P2,line2P1,line2P2,crossPointArray);
	return CATMathPoint(crossPointArray);
}

//通过变换矩阵，转换点的坐标
/*
CATMathPoint  MathPointPositionTransformation(CATMathPoint  mathPoint,CATMathTransformation mathTransf)
{
	double  pAbsoluteCoeff[12] ;
	mathTransf.GetCoef(pAbsoluteCoeff);
	double uVec[3] = {pAbsoluteCoeff[0],pAbsoluteCoeff[1],pAbsoluteCoeff[2]};
	double vVec[3] = {pAbsoluteCoeff[3],pAbsoluteCoeff[4],pAbsoluteCoeff[5]};
	double wVec[3] = {pAbsoluteCoeff[6],pAbsoluteCoeff[7],pAbsoluteCoeff[8]};
	double moveVec[3] = {pAbsoluteCoeff[9],pAbsoluteCoeff[10],pAbsoluteCoeff[11]};

	double tempArray1[3] = {1.0,0.0,0.0};
	double tempArray2[3] = {0.0,1.0,0.0};
	double tempArray3[3] = {0.0,0.0,1.0};

	double xAxis[3] = {1.0,0.0,0.0};
	double yAxis[3] = {0.0,1.0,0.0};
	double zAxis[3] = {0.0,0.0,1.0};

	D3VectorSum(xAxis,uVec,tempArray1);
	D3VectorSum(tempArray1,vVec,tempArray2);
	D3VectorSum(tempArray2,wVec,xAxis);

	D3VectorSum(yAxis,uVec,tempArray1);
	D3VectorSum(tempArray1,vVec,tempArray2);
	D3VectorSum(tempArray2,wVec,yAxis);

	D3VectorSum(zAxis,uVec,tempArray1);
	D3VectorSum(tempArray1,vVec,tempArray2);
	D3VectorSum(tempArray2,wVec,zAxis);

	D3VectorScal(xAxis,mathPoint.GetX(),tempArray1);
	D3VectorScal(yAxis,mathPoint.GetY(),tempArray2);
	D3VectorSum(tempArray1,tempArray2,tempArray3);
	D3VectorScal(zAxis,mathPoint.GetZ(),tempArray1);
	D3VectorSum(tempArray3,tempArray1,tempArray2);

	double oPoint[3] = {0.0,0.0,0.0};
	D3PointMove(tempArray2,moveVec,oPoint);

	return CATMathPoint(oPoint);
}*/

CATMathPoint  MathPointPositionTransformation(CATMathPoint  mathPoint,CATMathTransformation mathTransf)
{
double  pAbsoluteCoeff[12] ;
mathTransf.GetCoef(pAbsoluteCoeff);
CATMathVector uVec(pAbsoluteCoeff[0],pAbsoluteCoeff[1],pAbsoluteCoeff[2]);
CATMathVector vVec(pAbsoluteCoeff[3],pAbsoluteCoeff[4],pAbsoluteCoeff[5]);
CATMathVector wVec(pAbsoluteCoeff[6],pAbsoluteCoeff[7],pAbsoluteCoeff[8]);
CATMathVector moveVec(pAbsoluteCoeff[9],pAbsoluteCoeff[10],pAbsoluteCoeff[11]);
CATMathVector  pointVec = (uVec * mathPoint.GetX()) + (vVec * mathPoint.GetY()) + (wVec * mathPoint.GetZ()) + moveVec;
return CATMathPoint(pointVec.GetX(),pointVec.GetY(),pointVec.GetZ());
}

CATMathVector  MathVectorPositionTransformation(CATMathVector  mathVector,CATMathTransformation mathTransf)
{
	double  pAbsoluteCoeff[12] ;
	mathTransf.GetCoef(pAbsoluteCoeff);
	CATMathVector uVec(pAbsoluteCoeff[0],pAbsoluteCoeff[1],pAbsoluteCoeff[2]);
	CATMathVector vVec(pAbsoluteCoeff[3],pAbsoluteCoeff[4],pAbsoluteCoeff[5]);
	CATMathVector wVec(pAbsoluteCoeff[6],pAbsoluteCoeff[7],pAbsoluteCoeff[8]);
	CATMathVector moveVec(pAbsoluteCoeff[9],pAbsoluteCoeff[10],pAbsoluteCoeff[11]);
	CATMathVector  resultVec = (uVec * mathVector.GetX()) + (vVec * mathVector.GetY()) + (wVec * mathVector.GetZ());
	return CATMathVector(resultVec.GetX(),resultVec.GetY(),resultVec.GetZ());
}


//从顶点中获取坐标数组
void GetPointCoordFromVertex( CATVertex_var spVertex,double oPointCoord [3])
{
	CATPoint_var spPoint = spVertex->GetPoint();
	oPointCoord[0] = spPoint->GetX();
	oPointCoord[1] = spPoint->GetY();
	oPointCoord[2] = spPoint->GetZ();
}


//从直线中获取首尾端点坐标数组
void GetPointCoordFromLine( CATISpecObject_var spLine,double oStartPoint[3],double oEndPoint[3])
{
	CATBody_var spExpDirBody = GetBodyFromFeature(spLine);
	CATLISTP(CATCell) expDirCellList = NULL;
	spExpDirBody -> GetAllCells(expDirCellList,1);
	CATCell_var spCell = expDirCellList[1];
	CATEdge_var spEdge = spCell;
	CATVertex* piStartVertex = NULL; CATVertex* piEndVertex = NULL;
	spEdge->GetVertices( &piStartVertex,&piEndVertex);
	CATVertex_var spStartVertex = piStartVertex;
	CATVertex_var spEndVertex = piEndVertex;
	piStartVertex->Release(); piStartVertex = NULL; 
	piEndVertex->Release(); piEndVertex = NULL; 
	GetPointCoordFromVertex(spStartVertex,oStartPoint);
	GetPointCoordFromVertex(spEndVertex,oEndPoint);
}
HRESULT SetSpecObjShowAttr(CATISpecObject_var iSpecObj,CATUnicodeString iShowOrHide)
{
	if (NULL_var==iSpecObj) return E_FAIL;

	CATIVisProperties *piVisP=NULL;
	HRESULT rc = iSpecObj->QueryInterface(IID_CATIVisProperties,(void**)&piVisP);
	if( FAILED(rc) || piVisP == NULL ) return rc;


	CATVisPropertiesValues Attribut;
	if (iShowOrHide=="Show")
	{
		Attribut.SetShowAttr(CATShowAttr);
	}
	else
	{
		Attribut.SetShowAttr(CATNoShowAttr);
	}

	piVisP->SetPropertiesAtt(Attribut,CATVPShow,CATVPGlobalType,0,0);
	piVisP->Release();
	piVisP=NULL;

	return S_OK;
}
HRESULT GetSpecObjShowAttr(CATISpecObject_var iSpecObj,CATUnicodeString& iShowOrHide)
{
	if (NULL_var==iSpecObj) return E_FAIL;

	CATIVisProperties *piVisP=NULL;
	HRESULT rc = iSpecObj->QueryInterface(IID_CATIVisProperties,(void**)&piVisP);
	if( FAILED(rc) || piVisP == NULL ) return rc;

	CATVisPropertiesValues Attribut;
	piVisP->GetPropertiesAtt(Attribut,CATVPShow,CATVPGlobalType,0,0);
	CATShowAttribut Attributvalue;
	Attribut.GetShowAttr(Attributvalue);
	if (CATShowAttr == Attributvalue)
	{
		iShowOrHide = "Show";
	}
	else
	{
		iShowOrHide = "Hide";
	}
	piVisP->Release();
	piVisP=NULL;

	return S_OK;
}


HRESULT GetBodyBox(CATBody_var spBody, CATMathBox& oMathBox)
{
	HRESULT HR_END = E_FAIL;
	CATVertex_var spCell;
	CATPoint_var spPoint;
	CATMathPoint iMathPoint;
	CATLISTP(CATCell) iCellList = NULL;
	spBody -> GetAllCells(iCellList,0);
	if (iCellList != NULL && iCellList.Size() > 0)
	{
		int nums = iCellList.Size();
		for (int i = 1 ; i<=nums; i++)
		{
			spCell = NULL_var;
			spCell = iCellList[i]; 
			spPoint = NULL_var;
			spPoint = spCell->GetPoint();
			iMathPoint = NULL;
			spPoint->GetMathPoint(iMathPoint);
			oMathBox.AddInside(iMathPoint);
		}
		HR_END = S_OK;
	}
	return HR_END;
}


//描述：获取程序Bin目录
//输入：void
//输出：void
//返回：CATUnicodeString-BIN目录
CATUnicodeString GetCurrentBinPathFunc()
{
	CATUnicodeString oBinPath = NULL;
	//获得dll句柄
	HINSTANCE hinstance = ::GetModuleHandle(_T("YFDrwToolsPartListM.dll"));

	//获得dll路径
	TCHAR szFilePath[MAX_PATH + 1]; 
	GetModuleFileName(hinstance, szFilePath, MAX_PATH); 
	CString sCurDir = szFilePath;

	//分离路径和文件名
	int nPos = sCurDir.ReverseFind('\\');
	CString sBinPath = sCurDir.Left(nPos);

	//返回bin文件夹路径
	BSTR path = sBinPath.AllocSysString();
	oBinPath.BuildFromBSTR(path);

	return oBinPath;
}


//测试用途，将CATMathPoint包围盒输出
CATUnicodeString  TransformMathPointInToString(CATMathPoint  iPoint ) 
{
	CATUnicodeString allval = "";
	CATUnicodeString x = ""; CATUnicodeString y = ""; CATUnicodeString z = "";
	x.BuildFromNum(iPoint.GetX()); y.BuildFromNum(iPoint.GetY()); z.BuildFromNum(iPoint.GetZ());
	allval = allval +  "iPoint = (" + x +  "，" + y +  "，" + z + ")\n";
	return allval;
}

//测试用途，将vector包围盒输出
CATUnicodeString  TransformVector3DBoxInToString(vector <CATMathPoint>  productBox ) 
{
	CATUnicodeString allval = "";
	for (int i = 0 ; i < productBox.size();i++)
	{
		allval = allval + TransformMathPointInToString(productBox[i]) ;
	}
	return allval;
}

//测试用途，将CATMathBox包围盒输出
CATUnicodeString  TransformProduct3DBoxInToString(CATMathPoint  productBox[] ) 
{
	CATUnicodeString allval = "";
	CATUnicodeString x = ""; CATUnicodeString y = ""; CATUnicodeString z = "";
	x.BuildFromNum(productBox[0].GetX()); y.BuildFromNum(productBox[0].GetY()); z.BuildFromNum(productBox[0].GetZ());
	allval = allval +  "3DBoxiLow1 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[1].GetX()); y.BuildFromNum(productBox[1].GetY()); z.BuildFromNum(productBox[1].GetZ());
	allval = allval +  "3DBoxiLow2 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[2].GetX()); y.BuildFromNum(productBox[2].GetY()); z.BuildFromNum(productBox[2].GetZ());
	allval = allval +  "3DBoxiLow3 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[3].GetX()); y.BuildFromNum(productBox[3].GetY()); z.BuildFromNum(productBox[3].GetZ());
	allval = allval +  "3DBoxiLow4 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[4].GetX()); y.BuildFromNum(productBox[4].GetY()); z.BuildFromNum(productBox[4].GetZ());
	allval = allval +  "3DBoxiHigh1 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[5].GetX()); y.BuildFromNum(productBox[5].GetY()); z.BuildFromNum(productBox[5].GetZ());
	allval = allval +  "3DBoxiHigh2 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[6].GetX()); y.BuildFromNum(productBox[6].GetY()); z.BuildFromNum(productBox[6].GetZ());
	allval = allval +  "3DBoxiHigh3 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[7].GetX()); y.BuildFromNum(productBox[7].GetY()); z.BuildFromNum(productBox[7].GetZ());
	allval = allval +  "3DBoxiHigh4 = (" + x +  "，" + y +  "，" + z + ")\n";
	return allval;
}

//测试用途，将CATMathBox包围盒输出
CATUnicodeString  TransformProduct2DBoxInToString(CATMathPoint  productBox[] ) 
{
	CATUnicodeString allval = "";
	CATUnicodeString x = ""; CATUnicodeString y = ""; CATUnicodeString z = "";
	x.BuildFromNum(productBox[0].GetX()); y.BuildFromNum(productBox[0].GetY()); z.BuildFromNum(productBox[0].GetZ());
	allval = allval +  "2DBoxiPoint1 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[1].GetX()); y.BuildFromNum(productBox[1].GetY()); z.BuildFromNum(productBox[1].GetZ());
	allval = allval +  "2DBoxiPoint2 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[2].GetX()); y.BuildFromNum(productBox[2].GetY()); z.BuildFromNum(productBox[2].GetZ());
	allval = allval +  "2DBoxiPoint3 = (" + x +  "，" + y +  "，" + z + ")\n";
	x.BuildFromNum(productBox[3].GetX()); y.BuildFromNum(productBox[3].GetY()); z.BuildFromNum(productBox[3].GetZ());
	allval = allval +  "2DBoxiPoint4 = (" + x +  "，" + y +  "，" + z + ")\n";
	return allval;
}

//测试用途，将CATMathBox包围盒输出
CATUnicodeString  TransformCATMathBoxInToString( const CATMathBox& bodyBox ) 
{
	CATUnicodeString dimallvalue = "";
	CATUnicodeString dimvalue = "";
	double xmin;
	double xmax;
	double ymin;
	double ymax;
	double zmin;
	double zmax;
	bodyBox.GetExtremities(xmin,xmax,ymin,ymax,zmin,zmax);
	dimvalue.BuildFromNum(xmin);
	dimallvalue = dimallvalue + "xmin = " + dimvalue + "，";
	dimvalue.BuildFromNum(xmax);
	dimallvalue = dimallvalue + "xmax = " + dimvalue + "，";
	dimvalue.BuildFromNum(ymin);
	dimallvalue = dimallvalue + "ymin = " + dimvalue + "，";
	dimvalue.BuildFromNum(ymax);
	dimallvalue = dimallvalue + "ymax = " + dimvalue + "，";
	dimvalue.BuildFromNum(zmin);
	dimallvalue = dimallvalue + "zmin = " + dimvalue + "，";
	dimvalue.BuildFromNum(zmax);
	dimallvalue = dimallvalue + "zmax = " + dimvalue + "\n";
	return dimallvalue;
}

// 计算出ISO视角
CATMathPlane  ISOView()
{ 
	CATMathPoint eyept(0.0,0.0,0.0);
	CATMathVector axisx(1.0,0.0,0.0);
	CATMathVector axisy(0.0,1.0,0.0);
	CATMathVector axisz(0.0,0.0,1.0);
	CATMathVector eyedir =  -axisx  -axisy - axisz;
	CATMathVector viewmatx = axisy - axisx;
	CATMathVector viewmaty = viewmatx ^ eyedir;
	viewmatx.Normalize();
	viewmaty.Normalize();
	return CATMathPlane(eyept,viewmatx,viewmaty);
}


//以下是纯数学运算
bool D3LinesGetCrossPoint(double line1P1[3],double line1P2[3],double line2P1[3],double line2P2[3],double returnArray[3])
{
	double numArray[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line1P2,numArray);
	double numArray2[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line2P1,line2P2,numArray2);
	double numArray3[3] = {0.0,0.0,0.0};
	double numArray4[3] = {0.0,0.0,0.0};
	if (D3VectorsParallel(numArray,numArray2))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P1,numArray4);
		double num = D3PointDistance(numArray3,numArray4);
		if (D3PointDistance(line1P1,line2P2) <= num)
		{
			D3ArrayCopy(line1P1,numArray3);
			D3ArrayCopy(line2P2,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		if (D3PointDistance(line1P2,line2P1) <= num)
		{
			D3ArrayCopy(line1P2,numArray3);
			D3ArrayCopy(line2P1,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		if (D3PointDistance(line1P2,line2P2) <= num)
		{
			D3ArrayCopy(line1P2,numArray3);
			D3ArrayCopy(line2P2,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		D3GetMidPoint(numArray3,numArray4,returnArray);
		return false;
	}

	if ((D3PointDistance(line1P1,line2P1) <= offsettolerance) || (D3PointDistance(line1P1,line2P2) <= offsettolerance))
	{
		D3ArrayCopy(line1P1,returnArray);
		return true;
	}
	if ((D3PointDistance(line1P2,line2P1) <= offsettolerance) || (D3PointDistance(line1P2,line2P2) <= offsettolerance))
	{
		D3ArrayCopy(line1P2,returnArray);
		return true;
	}

	D3ArrayClear(numArray3);
	D3ArrayClear(numArray4);
	double numArray5[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P1,numArray5);
	double numArray6[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P2,numArray6);
	double numArray7[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P2,line2P1,numArray7);
	if (!(D3VectorsParallel(numArray,numArray5 ) || D3VectorsParallel(numArray2,numArray5)))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P1,numArray4);
	}
	else if (!(D3VectorsParallel(numArray,numArray6) || D3VectorsParallel(numArray2,numArray6)))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P2,numArray4);
	}
	else if (!(D3VectorsParallel(numArray,numArray7) || D3VectorsParallel(numArray2,numArray7)))
	{
		D3ArrayCopy(line1P2,numArray3);
		D3ArrayCopy(line2P1,numArray4);
	}
	else
	{
		D3ArrayCopy(line1P2,numArray3);
		D3ArrayCopy(line2P2,numArray4);
	}
	double vectoProjected[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(numArray3,numArray4,vectoProjected);
	double numArray0[3] = {0.0,0.0,0.0};
	D3VectorGetProjectY(vectoProjected,numArray,numArray0);
	double d = D3VectorAngle(numArray2,numArray0);
	double numArray8[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray2,numArray8);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorScal(numArray8,(D3VectorLen(numArray0) / cos(d)),vec);
	double numArray9[3] = {0.0,0.0,0.0};
	D3VectorScal(vec,-1,numArray9);
	D3PointMove(numArray4,numArray9,returnArray);
	if(abs(D3PointDistance(returnArray,line1P1) + D3PointDistance(returnArray,line1P2) - D3PointDistance(line1P1,line1P2))<=0.001)
	{
		return true;
	}
	else
	{
		return false;
	}

}

double D3PointDistance(double point1[3],double point2[3])
{
	double vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(point1,point2,vec);
	return D3VectorLen(vec);
}

void D3VectorSetFromTwoPoint(double P1[3],double P2[3],double returnArray[3])
{
	returnArray[0] = (P2[0] - P1[0]);
	returnArray[1] = (P2[1] - P1[1]);
	returnArray[2] = (P2[2] - P1[2]);
}

double D3VectorLen(double vec[3])
{
	return sqrt(((pow(vec[0],2) + pow(vec[1],2)) + pow(vec[2],2)));
}

void D3ArrayCopy(double inArray[3],double returnArray[3])
{
	for(int i=0;i<3;i++)
	{
		returnArray[i] = inArray[i];
	}
}

void D3ArrayClear(double inArray[3])
{
	for(int i=0;i<3;i++)
	{
		inArray[i] = 0.0 ;
	}
}

bool D3VectorsParallel(double vec1[3],double vec2[3] )
{
	double num = D3VectorAngle(vec1,vec2);
	return ((abs(num - 0.0) <= offsettolerance) || (abs(num - mathPi) <= offsettolerance));
}

double D3VectorAngle(double v1[3],double v2[3])
{
	double d = (D3DotProduct(v1,v2) / (D3VectorLen(v1) * D3VectorLen(v2)));
	if (abs(d + 1) < offsettolerance)
	{
		return mathPi;
	}
	if (abs(d - 1) < offsettolerance)
	{
		return 0.0;
	}
	return acos(d);
}

double D3DotProduct(double v1[3],double v2[3])
{
	return (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
}

void D3GetMidPoint(double P1[3],double P2[3],double returnArray[3])
{
	double numArray1[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(P1,P2,numArray1);

	double numArray2[3] = {0.0,0.0,0.0};
	D3VectorScal( numArray1,0.5,numArray2);

	D3PointMove(P1,numArray2,returnArray);
}

void D3VectorScal(double vec[3],double scal,double returnArray[3])
{
	returnArray[0] = (vec[0] * scal);
	returnArray[1] = (vec[1] * scal); 
	returnArray[2] = (vec[2] * scal);
}

void D3PointMove(double point[3],double vec[3],double returnArray[3])
{
	returnArray[0] = (point[0] + vec[0]);
	returnArray[1] = (point[1] + vec[1]);
	returnArray[2] = (point[2] + vec[2]);
}

void D3VectorGetProjectY(double vectoProjected[3],double vecAxis[3],double returnArray[3])
{
	double numArray[3] = {0.0,0.0,0.0};
	D3VectorGetProjectX(vectoProjected,vecAxis,numArray);
	D3VectorReduce(vectoProjected,numArray,returnArray);
}

void D3VectorGetProjectX(double vectoProjected[3],double vecAxis[3],double returnArray[3])
{
	double scal = (D3DotProduct(vecAxis,vectoProjected) / D3VectorLen(vecAxis));
	double numArray1[3] = {0.0,0.0,0.0};
	D3VectorUnit(vecAxis,numArray1);
	D3VectorScal(numArray1,scal,returnArray);
}

void D3VectorReduce(double v1Reduced[3],double v2[3],double returnArray[3])
{
	returnArray[0] = v1Reduced[0] - v2[0];
	returnArray[1] = v1Reduced[1] - v2[1];
	returnArray[2] = v1Reduced[2] - v2[2];
}

void D3VectorUnit(double vec[3],double returnArray[3])
{
	double num = D3VectorLen(vec);
	if (num == 0.0)
	{
		returnArray[0] = 0.0;
		returnArray[1] = 0.0;
		returnArray[2] = 0.0;
	}
	else
	{
		returnArray[0] = vec[0] / num;
		returnArray[1] = vec[1] / num;
		returnArray[2] = vec[2] / num;
	}
}

void D3VectorRotate(double vs[3],double vnormal[3],double ang,double returnArray[3])
{
	ang = D3AngleNew(ang);
	double numArray[3] = {0.0,0.0,0.0};
	double numArray4[3] = {0.0,0.0,0.0};
	D3CrossProduct(vs,vnormal,numArray4);
	double numArray5[3] = {0.0,0.0,0.0};
	D3VectorSymmetric(numArray4,numArray5);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray5,vec);
	double numArray3[3] = {0.0,0.0,0.0};
	if (ang == 0.0)
	{
		D3ArrayCopy(vs,returnArray);
		return ;
	}
	if (ang == (mathPi / 2))
	{
		D3VectorScal(vec,D3VectorLen(vs),returnArray);
		return ;
	}
	if (ang == mathPi)
	{
		D3VectorSymmetric(vs,returnArray);
		return;
	}
	if (ang == (mathPi * 1.5))
	{
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorScal(vec,D3VectorLen(vs),numArray6);
		D3VectorSymmetric(numArray6,returnArray);
		return;
	}
	if (ang == (mathPi * 2))
	{
		D3ArrayCopy(vs,returnArray);
		return ;
	}
	if ((ang > 0) && (ang < (mathPi / 2)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorUnit(numArray6,numArray7 );
		D3VectorScal( numArray7,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > (mathPi / 2)) && (ang < mathPi))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorSymmetric(numArray6,numArray7 );
		double numArray8[3] = {0.0,0.0,0.0};
		D3VectorUnit( numArray7,numArray8 );
		D3VectorScal(numArray8,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > mathPi) && (ang < (mathPi * 1.5)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorSymmetric(numArray6,numArray7 );
		double numArray8[3] = {0.0,0.0,0.0};
		D3VectorUnit( numArray7,numArray8 );
		D3VectorScal(numArray8,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > (mathPi * 1.5)) && (ang < (mathPi * 2)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorUnit(numArray6,numArray7 );
		D3VectorScal( numArray7,D3VectorLen(vs),returnArray);
		return;
	}
	D3ArrayCopy(numArray,returnArray);
}

double D3AngleNew(double a1)
{
	a1 = a1 - int(a1 / (mathPi * 2)) * (mathPi * 2);
	if (a1 < 0)
	{
		a1 = ((mathPi * 2) + a1);
	}
	return a1;
}
//vec1和vec2的叉积
void D3CrossProduct(double vec1[3],double vec2[3],double returnArray[3] )
{
	returnArray[0] = (vec1[1] * vec2[2]) - (vec1[2] * vec2[1]),
		returnArray[1] = (vec1[2] * vec2[0]) - (vec1[0] * vec2[2]),
		returnArray[2] = (vec1[0] * vec2[1]) - (vec1[1] * vec2[0]);
}

void D3VectorSymmetric(double vec[3],double returnArray[3])
{
	returnArray[0] = -vec[0];
	returnArray[1] = -vec[1];
	returnArray[2] = -vec[2];

}

void D3VectorSum(double v1[3],double v2[3],double returnArray[3])
{
	returnArray[0] = (v1[0] + v2[0]);
	returnArray[1] = (v1[1] + v2[1]);
	returnArray[2] = (v1[2] + v2[2]);

}

bool D3VectorEqual(double v1[3],double v2[3])
{
	return (((abs(v1[0] - v2[0]) <= offsettolerance) && (abs(v1[1] - v2[1]) <= offsettolerance)) && (abs(v1[2] - v2[2]) <= offsettolerance));
}

void D3PointProjectOnPlane(double pointToProjected[3], double originPoint[3], double Direction[3],double returnArray[3])
{
	if (D3VectorEqual(pointToProjected, originPoint))
	{
		D3ArrayCopy(pointToProjected,returnArray) ;
		return ;
	}
	double LineEndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint, Direction,LineEndPoint);
	double numArray2[3] = {0.0 , 0.0 , 0.0};
	D3PointProjectOnLine(originPoint, LineEndPoint, pointToProjected, false,numArray2);
	double vec[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(numArray2, pointToProjected,vec);
	D3PointMove(originPoint, vec, returnArray);
}

void D3PointProjectOnPlane(double pointToProjected[3], double originPoint[3], double vecX[3], double vecY[3], bool transformto2D,double returnArray[])
{
	if (D3VectorEqual(pointToProjected, originPoint))
	{
		if (!transformto2D)
		{
			D3ArrayCopy(pointToProjected,returnArray) ;
			return;
		}
		double numArray0[2] = {0.0,0.0};
		D2ArrayCopy(numArray0,returnArray) ;
		return ;
	}

	double vecZ[3] = {0.0 , 0.0 , 0.0};
	double resultPoint3D[3] = {0.0 , 0.0 , 0.0};
	D3CrossProduct(vecX,vecY,vecZ);
	D3PointProjectOnPlane( pointToProjected, originPoint,  vecZ, resultPoint3D);
	if (!transformto2D)
	{
		D3ArrayCopy (resultPoint3D,returnArray);
		return;
	}

	double vecY2[3] = {0.0 , 0.0 , 0.0};
	D3CrossProduct(vecZ,vecX,vecY2);
	double vecY2EndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint,vecY2,vecY2EndPoint);
	double vecXEndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint,vecX,vecXEndPoint);	

	double X2D[2] = {0.0, 0.0};
	D3PointProjectOnLine(originPoint, vecXEndPoint, resultPoint3D,true,X2D);
	double Y2D[2] = {0.0, 0.0};
	D3PointProjectOnLine(originPoint, vecY2EndPoint, resultPoint3D,true,Y2D);

	double numArray13[2] = {X2D[0], Y2D[0]};
	D2ArrayCopy(numArray13,returnArray);
}

bool D3PlanesGetCrossLine(double plane1Origin[3], double plane1Direction[3], double plane2Origin[3], double plane2Direction[3],double outCrossLineOrigin[3], double outCrossLineDir[3])
{
	if (D3VectorsParallel(plane1Direction, plane2Direction))
	{
		return false;
	}
	else
	{
		double numArray12[3] = {0.0 , 0.0 , 0.0};
		D3CrossProduct(plane1Direction, plane2Direction,numArray12);
		D3VectorUnit(numArray12,outCrossLineDir);

		if (D3VectorEqual(plane1Origin, plane2Origin))
		{
			D3ArrayCopy(plane1Origin,outCrossLineOrigin);
		}
		else
		{
			double plane1line[3] = {0.0 , 0.0 , 0.0};
			D3CrossProduct(plane1Direction, outCrossLineDir,plane1line);
			double plane2line[3] = {0.0 , 0.0 , 0.0};
			D3CrossProduct(outCrossLineDir , plane2Direction,plane2line);

			double vec[3] = {0.0 , 0.0 , 0.0};
			D3VectorSetFromTwoPoint(plane2Origin, plane1Origin,vec);
			double numArray6[3] = {0.0 , 0.0 , 0.0};
			D3VectorGetProjectX(vec, outCrossLineDir,numArray6);
			double plane2Origin2[3] = {0.0 , 0.0 , 0.0};
			D3PointMove(plane2Origin,numArray6,plane2Origin2);

			double plane1End[3] = {0.0 , 0.0 , 0.0};
			double plane2End[3] = {0.0 , 0.0 , 0.0};
			D3PointMove(plane1Origin,plane1line,plane1End);
			D3PointMove(plane2Origin2,plane2line,plane2End);
			D3LinesGetCrossPoint(plane1Origin,plane1End, plane2Origin2,plane2End ,outCrossLineOrigin);
		}
		return true;
	}
}

void D3PointProjectOnLine(double LineStartPoint[3],double LineEndPoint[3],double AnyPoint[3],bool transformto2D,double returnArray[])
{
	double vecAxis[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineStartPoint,LineEndPoint,vecAxis);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineStartPoint,AnyPoint,vec);
	double numArray3[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineEndPoint,AnyPoint,numArray3);
	double numArray4[3] = {0.0,0.0,0.0};
	double numArray5[3] = {0.0,0.0,0.0};
	if (D3VectorLen(vec) <= offsettolerance)
	{
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else if (D3VectorLen(numArray3) <= offsettolerance)
	{
		D3ArrayCopy(vecAxis,numArray4);
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else
	{
		D3VectorGetProjectX(vec,vecAxis,numArray4);
		D3PointMove(LineStartPoint,numArray4,numArray5);
	}
	if (!transformto2D)
	{
		D3ArrayCopy(numArray5,returnArray);
		return ;
	}
	double numArray6[3] = {0.0,0.0,0.0};
	D3VectorUnit(vecAxis,numArray6);
	double numArray7[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray4,numArray7);
	double num = 0.0;
	if(D3VectorEqual(numArray6,numArray7) )
	{
		num = D3VectorLen(numArray4);
	}
	else
	{
		num = 0 - D3VectorLen(numArray4);
	}
	double numArray2[2] = {num,0.0};
	D2ArrayCopy(numArray2,returnArray);
}

void D3PointProjectOnLineAlongDir(double LineStartPoint[3], double LineEndPoint[3], double AnyPoint[3], double projectDirection[3], bool transformto2D,double returnArray[])
{
	double vec[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineStartPoint, LineEndPoint,vec);
	double numArray2[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineStartPoint, AnyPoint,numArray2);
	double numArray3[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineEndPoint, AnyPoint,numArray3);
	double numArray4[3] = {0.0 , 0.0 , 0.0};
	double numArray5[3] = {0.0 , 0.0 , 0.0};
	if (D3VectorLen(numArray2) <= offsettolerance)
	{
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else if (D3VectorLen(numArray3) <= offsettolerance)
	{
		D3ArrayCopy(vec,numArray4);
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else
	{
		double numArray6[3] = {0.0 , 0.0 , 0.0};
		D3PointMove(AnyPoint, projectDirection,numArray6);
		D3LinesGetCrossPoint(LineStartPoint, LineEndPoint, AnyPoint, numArray6,numArray5);
		D3VectorSetFromTwoPoint(LineStartPoint, numArray5,numArray4);
	}
	if (!transformto2D)
	{
		D3ArrayCopy( numArray5,returnArray);
		return;
	}
	double numArray7[3] = {0.0 , 0.0 , 0.0};
	D3VectorUnit(vec,numArray7);
	double numArray8[3] = {0.0 , 0.0 , 0.0};
	D3VectorUnit(numArray4,numArray8);
	double num = 0.0;
	if(D3VectorEqual(numArray7, numArray8) )
	{
		num = D3VectorLen(numArray4) ;
	}
	else
	{
		num = 0 - D3VectorLen(numArray4);
	}
	double numArray9[2] = {num, 0.0};
	D2ArrayCopy(numArray9,returnArray);
}
void D2ArrayCopy(double inArray[2],double returnArray[2])
{
	for(int i=0;i<2;i++)
	{
		returnArray[i] = inArray[i];
	}
}

void D2VectorUnit(double vec[2],double returnArray[2])
{
	double num = D2VectorLen(vec);
	if (num == 0)
	{
		returnArray[0] = 0;
		returnArray[1] = 0;
	}
	else
	{
		returnArray[0] = (vec[0] / num);
		returnArray[1] = (vec[1] / num);
	}
}

void D2VectorScal(double vec[2],double scal,double returnArray[2])
{
	returnArray[0] = vec[0] * scal;
	returnArray[1] = vec[1] * scal;
}

double D2VectorLen(double vec[2])
{
	return sqrt((pow(vec[0],2) + pow(vec[1],2)));
}

void D2PointMove(double point[2],double vec[2],double returnArray[2] )
{
	returnArray[0] = (point[0] + vec[0]);
	returnArray[1] = (point[1] + vec[1]);
}

void D2VectorSetFromTwoPoint(double P1[2],double P2[2],double returnArray[2])
{
	returnArray[0] = (P2[0] - P1[0]);
	returnArray[1] = (P2[1] - P1[1]);
}
void D2VectorReduce(double v1Reduced[2],double v2[2],double returnArray[2])
{
	returnArray[0] = v1Reduced[0] - v2[0];
	returnArray[1] = v1Reduced[1] - v2[1];
}

double D2PointDistance(double point1[2],double point2[2])
{
	double vec[2] = {0.0,0.0};
	D2VectorSetFromTwoPoint(point1,point2,vec);
	return D2VectorLen(vec);
}
void D2GetMidPoint(double P1[2],double P2[2],double returnArray[2])
{
	double P3[2] = {0.0,0.0};
	D2VectorSetFromTwoPoint(P1,P2,P3);

	double P4[2] = {0.0,0.0};
	D2VectorScal( P3,0.5,P4);

	D2VectorSum(P1,P4,returnArray);
}
void D2VectorSum(double v1[2],double v2[2],double returnArray[2])
{
	returnArray[0] = v1[0] + v2[0];
	returnArray[1] = v1[1] + v2[1];
}