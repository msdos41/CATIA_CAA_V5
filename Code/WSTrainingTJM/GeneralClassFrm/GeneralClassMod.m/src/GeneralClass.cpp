// COPYRIGHT Dassault Systemes 2019
//===================================================================
//
// GeneralClass.cpp
// Header definition of GeneralClass
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jan 2019  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "GeneralClass.h"

CATImplementClass( GeneralClass,
                   Implementation, 
                   CATBaseUnknown,
                   CATNull );
 
//-----------------------------------------------------------------------------
// GeneralClass : constructor
//-----------------------------------------------------------------------------
GeneralClass::GeneralClass():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// GeneralClass : destructor
//-----------------------------------------------------------------------------
GeneralClass::~GeneralClass()
{
}
 
//-----------------------------------------------------------------------------
// GeneralClass : copy constructor
//-----------------------------------------------------------------------------
GeneralClass::GeneralClass(GeneralClass& original):
   CATBaseUnknown(original)
{
}
 
//-----------------------------------------------------------------------------
// GeneralClass : equal operator
//-----------------------------------------------------------------------------
GeneralClass& GeneralClass::operator=(GeneralClass& original)
{
   CATBaseUnknown::operator=(original);
   return *this;
}

//弹窗对话框
void CAAMessageBox(CATUnicodeString message,CATUnicodeString title)
{
	CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), title.ConvertToChar(),CATDlgNfyWarning);
	if (NULL != pNotifyDlg)
	{
		pNotifyDlg->DisplayBlocked(message ,title);
		pNotifyDlg->RequestDelayedDestruction(); 
		pNotifyDlg = NULL;
	}
}

//从char转到unicodestring，主要用于解决中文字符的乱码显示
CATUnicodeString CAAUStringBuildFromChar(char * strchar)
{
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	wchar_t* strwcANSI = new wchar_t[len + 1]; 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
	CATUnicodeString strwcUnicode;
	strwcUnicode.BuildFromWChar(strwcANSI); 
	if(strwcANSI) delete [] strwcANSI;
	return strwcUnicode;
}

void CAAUStringConvertToChar(CATUnicodeString strUnicode,char* strchar )
{
	int len = WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, NULL, 0, NULL, NULL); 
	memset(strchar, 0, len + 1); 
	WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, strchar, len, NULL, NULL); 
}

void CAAUStringConvertToWChar(CATUnicodeString strUnicode, wchar_t* strwcANSI)
{
	const char *strchar =  strUnicode.ConvertToChar();
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
}

//根据环境变量和文件名，取出第一行的内容
HRESULT GetIPAddrFromResourceFile(const char* ichVarName,CATUnicodeString istrFileName,char **ocharIPAddr)
{
	HRESULT rc = S_OK;
	//先找到特定的环境变量的路径
	//const char * cValue = "YFAIResourcePath";
	char * strPath = NULL;
	CATLibStatus sStatus = CATGetEnvValue(ichVarName,&strPath);
	if ((sStatus ==CATLibError)||(strPath==NULL))
	{
		CATUnicodeString strWarnMessage = "No Environment Parameter : " + CATUnicodeString(ichVarName);
		CATUnicodeString strWarnTitle = "Notice";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strWarnTitle.ConvertToChar(),CATDlgNfyWarning);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strWarnMessage ,strWarnTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}

	//如果输入的文件夹名称为空，则直接在环境变量文件夹下直接找
	CATUnicodeString strFilePath(CATFindPath(istrFileName,strPath));
	if(strFilePath == "")
	{
		CATUnicodeString strWarnMessage = "No File :" + istrFileName;
		CATUnicodeString strWarnTitle = "Notice";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strWarnTitle.ConvertToChar(),CATDlgNfyWarning);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strWarnMessage ,strWarnTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}

	ifstream input;
	const char* chPath = strFilePath.ConvertToChar();
	input.open(chPath);
	string strLine;
	vector<string> lstLine;
	CATUnicodeString strUniLine;
	while (getline(input,strLine))
	{
		lstLine.push_back(strLine);
	}
	input.close();

	//取第一行的内容作为ip地址
	string strLineFirst = lstLine[0];
	//int len = strLineFirst.length();
	// *ocharIPAddr = (char *)malloc((len)*sizeof(char));
	//strLineFirst.copy(*ocharIPAddr,len,0);

	const char *psz = strLineFirst.c_str();
	char *buf = new char[strlen(psz)+1];
	strcpy(buf, psz);

	*ocharIPAddr = buf;

	return rc;
}

//获得指定位置txt内的第一行内容
HRESULT YFGetLicServerIP(char **ocharIPAddr, int &oiPort)
{
	HRESULT rc = S_OK;
	//先找到特定的环境变量的路径
	//const char * cValue = "YFAIResourcePath";
	char * strPath = NULL;
	CATLibStatus sStatus = CATGetEnvValue("YFAIResourcePath",&strPath);
	if ((sStatus ==CATLibError)||(strPath==NULL))
	{
		CATUnicodeString strWarnMessage = "No Environment Parameter: YFAIResourcePath";
		CATUnicodeString strWarnTitle = "Notice";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strWarnTitle.ConvertToChar(),CATDlgNfyWarning);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strWarnMessage ,strWarnTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}

	//如果输入的文件夹名称为空，则直接在环境变量文件夹下直接找
	CATUnicodeString strFilePath(CATFindPath("Lic_Server.txt",strPath));
	if(strFilePath == "")
	{
		CATUnicodeString strWarnMessage = "No File : Lic_Server.txt";
		CATUnicodeString strWarnTitle = "Notice";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strWarnTitle.ConvertToChar(),CATDlgNfyWarning);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strWarnMessage ,strWarnTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}

	ifstream input;
	const char* chPath = strFilePath.ConvertToChar();
	input.open(chPath);
	string strLine;
	vector<string> lstLine;
	CATUnicodeString strUniLine;
	while (getline(input,strLine))
	{
		lstLine.push_back(strLine);
	}
	input.close();

	//取第一行的内容作为ip地址
	string strLineFirst = lstLine[0];
	//int len = strLineFirst.length();
	// *ocharIPAddr = (char *)malloc((len)*sizeof(char));
	//strLineFirst.copy(*ocharIPAddr,len,0);

	const char *psz = strLineFirst.c_str();
	char *buf = new char[strlen(psz)+1];
	strcpy(buf, psz);

	*ocharIPAddr = buf;

	//取第二行的内容作为Port
	string strPort = lstLine[1];
	oiPort = atoi(strPort.c_str());

	return rc;
}
 
//获得根文档
HRESULT GeneralClass::GetRootProductUpdate(CATIProduct_var &ospiRootProduct)
{
	//获取Document
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	if (pEditor == NULL)
	{
		return E_FAIL;
	}
	CATDocument *pDoc = pEditor->GetDocument();
	if (pDoc == NULL)
	{
		return E_FAIL;
	}

	//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDoc->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
	CATIProduct_var spRootProduct = NULL_var;
	if (pRootProducts->Size())
	{
		spRootProduct = (*pRootProducts)[1];
		delete pRootProducts;
		pRootProducts = NULL;
	}

	piDocRootsOnDoc->Release();

	ospiRootProduct = spRootProduct;

	////CATIProduct *piProductOnRoot = NULL;
	//rc = spRootProduct->QueryInterface(IID_CATIProduct, (void**)&opiRootProduct);
	//if (FAILED(rc) || piDocRootsOnDoc == NULL)
	//{
	//	return E_FAIL;
	//}

	return S_OK;
}

//描述：获取当前打开的根节点
//输入：
//输出：当前打开的根节点
//返回：HRESULT
HRESULT GeneralClass::GetRootProduct(CATIProduct_var &ospiRootProd)
{
	HRESULT rc=S_OK;

	CATFrmEditor * pEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL != pEditor)
	{
		CATDocument *pDocument = pEditor ->GetDocument(); 
		CATIDocId *piDocId=NULL;
		rc=pDocument->GetDocId(&piDocId);
		if (FAILED(rc) || piDocId==NULL) return E_FAIL;

		CATUnicodeString oType;
		rc=piDocId->GetType(oType);
		if(oType=="CATProduct")
		{
			CATIProduct_var spiOtherProduct=NULL_var;
			CATIDocRoots *piDocRootsOnDoc = NULL;
			rc = pDocument -> QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
			if ( FAILED(rc) ) return E_FAIL;

			CATListValCATBaseUnknown_var* pRootProducts = piDocRootsOnDoc -> GiveDocRoots();
			if (pRootProducts->Size())
			{	
				ospiRootProd = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			piDocRootsOnDoc->Release(); piDocRootsOnDoc = NULL;
		}
	}

	return rc;
}

HRESULT GeneralClass::GetRootProductFromResourceFile(CATUnicodeString istrFilePath,CATBoolean ibDocReadOnly,CATIProduct_var &ospiRootProd)
{
	HRESULT rc = S_OK;
	CATDocument* pDoc = NULL;
	rc = CATDocumentServices::OpenDocument(istrFilePath,pDoc,ibDocReadOnly);
	if (FAILED(rc) || pDoc == NULL)
	{
		return E_FAIL;
	}

	return rc;
}

//从指定目录下获得CATPart文件的根节点
HRESULT GeneralClass::GetRootPartFromResourceFile(CATUnicodeString istrFilePath,CATBoolean ibDocReadOnly,CATIPrtPart_var &ospiRootPrtPart)
{
	HRESULT rc = S_OK;
	CATDocument* pDoc = NULL;
	rc = CATDocumentServices::OpenDocument(istrFilePath,pDoc,ibDocReadOnly);
	if (FAILED(rc) || pDoc == NULL)
	{
		return E_FAIL;
	}

	CATInit *pDocAsInit = NULL ;
	rc = pDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit);
	if ( FAILED(rc) )
	{
		cout <<" Error in retrieving a QI on CATInit" << endl;
		return E_FAIL ;
	}

	CATIPrtContainer *pSpecContainer = NULL ;
	pSpecContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");

	if ( NULL == pSpecContainer )
	{
		cout <<" Error in retrieving the Root container" << endl;
		return E_FAIL ;
	}

	pDocAsInit->Release();
	pDocAsInit = NULL ;

	//
	// 5- Retrieves on the root container (CATPrtCont) to get the Part feature
	// 

	CATIPrtPart_var spPart = pSpecContainer->GetPart() ;
	if ( NULL_var == spPart )
	{
		cout <<" Error in retrieving the Part feature" << endl;
		return E_FAIL ;
	}
	ospiRootPrtPart = spPart;

	pSpecContainer->Release();
	pSpecContainer = NULL ;

	return rc;
}

//获取单开part的CATPrtPart
HRESULT GeneralClass::GetRootPrtPart(CATIPrtPart_var &ospiRootPrtPart)
{
	HRESULT rc = S_OK;
	//获取Document
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	if (pEditor == NULL)
	{
		return E_FAIL;
	}
	CATDocument *pDoc = pEditor->GetDocument();
	if (pDoc == NULL)
	{
		return E_FAIL;
	}

	CATInit *pDocAsInit = NULL ;
	rc = pDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit);
	if ( FAILED(rc) )
	{
		cout <<" Error in retrieving a QI on CATInit" << endl;
		return E_FAIL ;
	}

	CATIPrtContainer *pSpecContainer = NULL ;
	pSpecContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");

	if ( NULL == pSpecContainer )
	{
		cout <<" Error in retrieving the Root container" << endl;
		return E_FAIL ;
	}

	pDocAsInit->Release();
	pDocAsInit = NULL ;

	//
	// 5- Retrieves on the root container (CATPrtCont) to get the Part feature
	// 

	CATIPrtPart_var spPart = pSpecContainer->GetPart() ;
	if ( NULL_var == spPart )
	{
		cout <<" Error in retrieving the Part feature" << endl;
		return E_FAIL ;
	}
	ospiRootPrtPart = spPart;

	pSpecContainer->Release();
	pSpecContainer = NULL ;
	return rc;
}

//从所有打开的窗口中获取所有的RootProduct
HRESULT GeneralClass::GetAllRootPrdFromWindows(CATLISTP(CATIProduct) &olstRootProducts)
{
	HRESULT rc = S_OK;

	CATFrmLayout *pLayout =CATFrmLayout::GetCurrentLayout();
	CATLISTP(CATFrmWindow) listOfCurWindows = pLayout->GetWindowList();
	for (int i=1; i<=listOfCurWindows.Size(); i++)
	{
		CATFrmEditor* pEditor= listOfCurWindows[i]->GetEditor();
		if (pEditor == NULL)
		{
			continue;
		}
		CATDocument *pDoc = pEditor->GetDocument();
		if (pDoc == NULL)
		{
			continue;
		}
		CATIDocId* piDocId= NULL;
		CATUnicodeString strType = NULL;
		pDoc->GetDocId(&piDocId);
		if (piDocId == NULL)
		{
			continue;
		}
		piDocId->GetType(strType);
		if (strType == "CATPart" || strType == "CATProduct")
		{
			//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
			CATIDocRoots *piDocRootsOnDoc = NULL;
			rc = pDoc->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
			if (FAILED(rc))
			{
				continue;;
			}
			CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
			CATIProduct_var spRootProduct = NULL_var;
			if (pRootProducts->Size())
			{
				spRootProduct = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			piDocRootsOnDoc->Release();
			//
			olstRootProducts.Append(spRootProduct);
		}
	}

	return rc;
}

//判断是Product还是Part
CATBoolean GeneralClass::IsProduct(CATIProduct_var ispiPrd)
{
	HRESULT rc = S_OK;

	CATBoolean isProduct=FALSE;

	CATIProduct *piPrd=NULL;
	rc = ispiPrd->QueryInterface(IID_CATIProduct,(void **)&piPrd);

	CATIProduct_var spRefPrd=ispiPrd->GetReferenceProduct();
	piPrd->Release();  piPrd = NULL;

	if (spRefPrd==NULL_var)
	{
		isProduct = TRUE;
		cout<<"==>Get ReferenceProduct failed"<<endl;
		return isProduct;
	}

	CATILinkableObject *piLinkObj=NULL;
	rc=spRefPrd->QueryInterface(IID_CATILinkableObject,(void **)&piLinkObj);
	if( FAILED(rc) || !piLinkObj ) 
	{
		cout << "==> Get CATILinkableObject error !" << endl;
		return isProduct;
	}

	CATDocument *pDoc=piLinkObj->GetDocument();
	piLinkObj->Release();  piLinkObj = NULL;
	if( !pDoc ) 
	{
		cout << "==> Get CATDocument error !" << endl;
		return isProduct;
	}

	CATIDocId *pDocID;
	CATUnicodeString typeDoc="";
	rc = pDoc->GetDocId(&pDocID);
	if( !(FAILED(rc)) )
		rc = pDocID->GetType(typeDoc);
	//cout << " ==> The type of document is: " << typeDoc << endl;

	if( typeDoc == "CATProduct" )
		isProduct = TRUE;

	return isProduct;
}

//从Product获取PrtPart
HRESULT GeneralClass::GetPartFromProduct(CATIProduct_var ispProduct,CATISpecObject_var &ospPartFromProduct,CATIPrtContainer_var &ospiPrtCont)
{
	//cout<<"GetPartFromProduct"<<endl;

	HRESULT rc = E_FAIL ;
	if(ispProduct == NULL_var)
		return E_FAIL ;

	CATIProduct_var spRef=ispProduct->GetReferenceProduct();
	if(spRef!=NULL_var)
	{
		CATILinkableObject *piLinkableObject=NULL;
		rc = spRef->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObject);                            
		if(SUCCEEDED(rc))
		{
			// Do not release this pointer
			CATDocument *pDocument=NULL ;
			pDocument=piLinkableObject->GetDocument();
			if (pDocument!=NULL)
			{
				CATIContainerOfDocument *pIContainerOfDocument = NULL ;
				rc=pDocument->QueryInterface(IID_CATIContainerOfDocument,(void**)& pIContainerOfDocument );
				if(SUCCEEDED(rc))
				{
					CATIContainer *pIContainerOnSpecContainer = NULL ;
					rc = pIContainerOfDocument->GetSpecContainer(pIContainerOnSpecContainer);
					if ( SUCCEEDED(rc) && (NULL!=pIContainerOnSpecContainer) )
					{
						CATIPrtContainer *piPrtCont=NULL;
						rc=pIContainerOnSpecContainer->QueryInterface(IID_CATIPrtContainer,(void**)&piPrtCont);
						if(SUCCEEDED(rc))
						{
							ospPartFromProduct = piPrtCont->GetPart();
							ospiPrtCont=piPrtCont;
							//piPrtCont->Release();
							//piPrtCont=NULL ;
						}
						pIContainerOnSpecContainer->Release();
						pIContainerOnSpecContainer=NULL ;
					}
					pIContainerOfDocument->Release();
					pIContainerOfDocument=NULL ;
				}
			} 
			else 
				rc=E_FAIL ;

			piLinkableObject->Release();
			piLinkableObject = NULL ;
		}
	}
	return rc ;
}

//描述：获取某对象下的double参数
//输入：CATISpecObject对象，CATUnicodeString参数集名称，CATUnicodeString参数名称
//输出：double
//返回：CATBoolean
CATBoolean GeneralClass::GetParameterOfObject(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrParameterSetName,
										      CATUnicodeString istrParameterName,
											  double &oValue)
{
	HRESULT rc=S_OK;

	if (NULL_var == ispiSpecObject) return FALSE;
	oValue = 0;

	if (istrParameterSetName == "")
	{
		CATLISTV(CATISpecObject_var) oListParameters = NULL;
		CATIParmPublisher_var spiParmPub=ispiSpecObject;
		if(NULL_var != spiParmPub)
		{
			spiParmPub->GetAllChildren("CATICkeParm",oListParameters);
		}

		if (oListParameters.Size()>0)
		{
			CATICkeParm_var spResultParm;
			for (int i=1; i <= oListParameters.Size(); i++)
			{
				CATICkeParm_var spCkeParm = oListParameters[i];
				if (NULL_var !=spCkeParm)
				{
					CATUnicodeString strParmName=spCkeParm->Name();
					//把获得的Parameter的完整路径截取最后，再和输入的名称做判断
					int iParmNameCharCount = istrParameterName.GetLengthInChar();
					int iParmPathCharCount = strParmName.GetLengthInChar();
					if (iParmPathCharCount-iParmNameCharCount >=0)
					{
						CATUnicodeString strParmKeyName = strParmName.SubString(iParmPathCharCount-iParmNameCharCount,iParmNameCharCount);
						if (strParmKeyName == istrParameterName)
						{
							oValue = spCkeParm->Value()->AsReal();
							break;
						}
					}

				}
			}
		}
	}
	else
	{
		CATLISTV(CATISpecObject_var) lstParameterSets = NULL;
		CATIParmPublisher_var spiParmPub = ispiSpecObject;
		if (NULL_var != spiParmPub)
		{
			spiParmPub->GetAllChildren("CATICkeParameterSet",lstParameterSets);
		}
		if (lstParameterSets.Size() >0)
		{
			for (int i=1; i<=lstParameterSets.Size(); i++)
			{
				CATICkeParameterSet_var spiParmSet = lstParameterSets[i];
				if (spiParmSet != NULL_var)
				{
					//先比较名称
					CATUnicodeString strParmSetName = spiParmSet->Name();
					cout<<"ParameterSet:  "<<strParmSetName<<endl;
					//CATUnicodeString strParmSetPath = spiParmSet->Name();
					//cout<<"ParameterSet:  "<<strParmSetPath<<endl;
					//int iParmSetCharCount = istrParameterSetName.GetLengthInChar();
					//int iParmSetPathCharCount = strParmSetPath.GetLengthInChar();
					//if (iParmSetPathCharCount-iParmSetCharCount >= 0)
					//{
					//	CATUnicodeString strParmSetKeyName = strParmSetPath.SubString(iParmSetPathCharCount-iParmSetCharCount,iParmSetCharCount);
						if (strParmSetName == istrParameterSetName)
						{
							CATCkeListOfParm lstParm = spiParmSet->Parameters();
							for (int j=1; j<=lstParm->Size(); j++)
							{
								CATICkeParm_var spiCkeParm = (*lstParm)[j];
								if (spiCkeParm != NULL_var)
								{
									CATUnicodeString strParmName = spiCkeParm->Name();
									cout<<strParmName<<endl;
									//把获得的Parameter的完整路径截取最后，再和输入的名称做判断
									int iParmNameCharCount = istrParameterName.GetLengthInChar();
									int iParmPathCharCount = strParmName.GetLengthInChar();
									if (iParmPathCharCount-iParmNameCharCount >=0)
									{
										CATUnicodeString strParmKeyName = strParmName.SubString(iParmPathCharCount-iParmNameCharCount,iParmNameCharCount);
										if (strParmKeyName == istrParameterName)
										{
											oValue = spiCkeParm->Value()->AsReal();
											break;
										}
									}
								}
							}
						}
					//}
				}
			}
		}
	}


	return TRUE;	
}

// 获取所选择的面的数学平面
HRESULT GeneralClass::GetMathPlane(CATBaseUnknown_var ispiSpecObject,CATMathPlane &MathPlane)
{
	HRESULT rc=E_FAIL;

	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody == NULL_var ) 
		return E_FAIL;

	CATLISTP(CATCell) LISTCell; 
	spBody->GetAllCells( LISTCell, 2 ); 
	for( int index = 1; index <= LISTCell.Size(); index++ )
	{ 
		CATCell * pCell = LISTCell[index]; 
		if(pCell == NULL) 
		{
			cout<<"CATCell is NULL."<<endl;
			continue;
		}

		CATCell_var spCell = pCell;
		if(spCell == NULL_var) 
		{
			cout<<"CATCell_var is NULL_var."<<endl;
			continue;
		}

		CATFace_var spFace = spCell;
		if(spFace == NULL_var) 
		{
			cout<<"CATFace_var is NULL_var."<<endl;
			continue;
		}

		CATSurface_var spSurface = spFace->GetSurface();
		if(spSurface == NULL_var)
		{
			cout<<"CATSurface_var is NULL_var."<<endl;
			continue;
		}

		CATPlane *pPlane = NULL;
		rc = spSurface->QueryInterface(IID_CATPlane,(void**)&pPlane);
		if(FAILED(rc) || pPlane == NULL) 
		{
			cout<<"QI to CATPlane is failed!"<<endl;
			continue;
		}			

		MathPlane = pPlane->GetAxis();

		return S_OK;
	}

	return E_FAIL;
}

// 通过特征获取Body
CATBody_var GeneralClass::GetBodyFromFeature( CATBaseUnknown_var& ispFeature ) 
{ 
	//cout<<"GetBodyFromFeature...."<<endl;
	CATBody_var spBody = NULL_var; 
	do { 
		if( ispFeature==NULL_var )  break; 

		CATIMfBRep_var spBRepOnFeature = ispFeature; 
		if(spBRepOnFeature!=NULL_var )
		{ 
			spBody = spBRepOnFeature->GetBody(); 
			if (spBody==NULL_var)
			{
				spBody=spBRepOnFeature->CreateBody(MfWithPermanentBody);
				if (spBody==NULL_var)
				{
					spBody=spBRepOnFeature->CreateSickBody();
					if (spBody==NULL_var)
					{
						cout<<"CATIMfBRep GetBody Failed"<<endl;

					}
					else
					{
						cout<<"CreateSickBody sucess"<<endl;

					}

				}
				else
				{
					cout<<"CreateBody sucess"<<endl;
				}
			}
		} 
		else
		{ 
			CATIBRepAccess_var spBRepAccess=ispFeature;
			if (spBRepAccess!=NULL_var)
			{
				spBody=spBRepAccess->CreateBody();
			}
			else
			{
				CATIGeometricalElement_var spGeometricalElementOnFeature = ispFeature; 
				if( !!spGeometricalElementOnFeature ) 
				{ 
					spBody = spGeometricalElementOnFeature->GetBodyResult(); 
				} 
				else
				{ 
					CATIBodyRequest_var spBodyRequestOnModel = ispFeature; 
					if( spBodyRequestOnModel == NULL_var) break; 

					CATListValCATBaseUnknown_var listResult; 
					HRESULT rc = spBodyRequestOnModel->GetResults("MfDefault3DView",listResult);
					if(FAILED(rc) ||  listResult.Size() <= 0)   break; 

					CATIGeometricalElement_var spGeometricalElementOnBody = listResult[1]; 
					if(spGeometricalElementOnBody==NULL_var)  break;    
					spBody = spGeometricalElementOnBody->GetBodyResult();
				} 
			}
		}
		if( spBody==NULL_var) break;
	} while(FALSE); 
	//cout<<"GetBodyFromFeature...."<<endl;
	return spBody; 
}

//从输入的Curve的Body中获取所有的不共点的端点列表
HRESULT GeneralClass::GetAllStartEndPoints(CATBody_var ispBodyOnCurve, CATLISTV(CATMathPoint) &olstMathPointsStartEnd)
{
	HRESULT rc = S_OK;
	////
	//if (ispBUCurve == NULL_var)
	//{
	//	return E_FAIL;
	//}
	////
	//CATBody_var spBodyOnCurve = GetBodyFromFeature(ispBUCurve);
	//if (spBodyOnCurve == NULL_var)
	//{
	//	return E_FAIL;
	//}
	//从body获得CATCurve的列表
	CATLISTP(CATCurve) lstCurves = NULL;
	rc = GetCurvesFromBody(ispBodyOnCurve,lstCurves);
	if (lstCurves.Size() == 0)
	{
		return E_FAIL;
	}
	//根据CATCurve列表获得所有的端点
	CATLISTV(CATMathPoint) lstMathPointTemp = NULL;
	for (int i=1; i <= lstCurves.Size(); i++)
	{
		CATCurve_var spCurve = lstCurves[i];
		if (spCurve == NULL_var)
		{
			continue;
		}
		CATCrvParam param1 = spCurve->GetStartLimit();
		CATCrvParam param2 = spCurve->GetEndLimit();
		CATMathPoint mathPoint1 = spCurve->EvalPoint(param1);
		CATMathPoint mathPoint2 = spCurve->EvalPoint(param2);
		lstMathPointTemp.Append(mathPoint1);
		lstMathPointTemp.Append(mathPoint2);
	}
	if (lstMathPointTemp.Size() == 0)
	{
		return E_FAIL;
	}
	//把距离小于0.01的两个点都从列表中删掉
	for (int i=1; i <= lstMathPointTemp.Size(); i++)
	{
		for (int j = lstMathPointTemp.Size(); j > i; j--)
		{
			double dDistance = lstMathPointTemp[i].DistanceTo(lstMathPointTemp[j]);
			if (dDistance <= 0.01)
			{
				lstMathPointTemp.RemovePosition(i);
				lstMathPointTemp.RemovePosition(j);
			}
		}
	}
	
	return rc;
}

//从Curve的Body转到CATCurve
HRESULT GeneralClass::GetCurvesFromBody(CATBody_var spCurveBody,CATLISTP(CATCurve) &olstCurves)
{
	HRESULT rc = S_OK;

	if (NULL_var == spCurveBody) return E_FAIL;

	CATEdgeCurve_var spCircleCurve = NULL_var;
	CATLISTP(CATCell) LISTCell;
	spCurveBody->GetAllCells(LISTCell,1);

	for( int index = 1; index <= LISTCell.Size(); index++)
	{ 
		CATCell *pSplineCell = LISTCell[index]; 
		if(!pSplineCell)
		{ 
			continue; 
		} 
		CATCell_var spSplineCell = pSplineCell; 
		if(!spSplineCell)
		{ 
			continue; 
		};
		CATEdge_var spEdge=spSplineCell;
		if(!spEdge)
		{
			continue;
		}
		CATEdgeCurve_var spEdgeCurve = spEdge ->GetCurve(NULL);
		if(!spEdgeCurve)
		{ 
			continue; 
		}
		
		CATCurve_var spCurve = NULL_var;
		spCurve=spEdgeCurve->GetRefCurve();
		if (NULL_var != spCurve)
		{
			olstCurves.Append(spCurve);
		}					
	}

	return rc;
}

//获取所选择线的两个数学端点
void GeneralClass::GetPointFromCurve(CATBaseUnknown_var ispBUCurve,CATMathPoint &omathPt1,CATMathPoint &omathPt2)
{
	CATBody_var spBody = GetBodyFromFeature(ispBUCurve);
	if(spBody != NULL ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0); 
		if(LISTCell.Size()<2)
		{
			cout<<"LISTCell size != 2"<<endl;
		}
		else
		{
			CATVertex_var spV1 = LISTCell[1];
			CATVertex_var spV2 = LISTCell[LISTCell.Size()];

			CATPoint * pt1 = spV1->GetPoint();
			CATPoint * pt2 = spV2->GetPoint();

			CATMathPoint mathPt1;
			CATMathPoint mathPt2;
			pt1->GetMathPoint(mathPt1);
			pt2->GetMathPoint(mathPt2);

			omathPt1=mathPt1;
			omathPt2=mathPt2;

			//vec = mathPt2 - mathPt1;

		}		
	}
	else  
		cout<<"Get Body From Feature is failed."<<endl;

	return ;
}

//从CATSurface获得对应的Body
HRESULT GeneralClass::GetBodyFromSurface(CATSurface *ipSurface,CATIProduct_var ispiProduct,CATBody *&opBodyOnSurface)
{
	HRESULT rc = S_OK;
	//
	if (ipSurface==NULL || ispiProduct == NULL_var)
	{
		return E_FAIL;
	}
	//
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata

	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=GetProductGeoFactoryAndPrtCont(ispiProduct,ospiCont);
	if (ospiCont==NULL_var||pGeoFactory==NULL)
	{
		cout<<"GetProductGeoFactoryAndPrtCont Failed"<<endl;
		return E_FAIL;
	}
	//
	CATSurLimits surMaxLimits;
	ipSurface->GetLimits(surMaxLimits) ;

	CATTopSkin * TopSkin =CATCreateTopSkin(pGeoFactory,topdata,ipSurface,&surMaxLimits);
	//CATICGMTopSkin * TopSkin =CATCGMCreateTopSkin(pGeoFactory,topdata,iNewSurface,&surMaxLimits);
	if (TopSkin==NULL)
	{
		cout<<"CATCGMCreateTopSkin Failed"<<endl;
		return E_FAIL;
	}

	TopSkin->Run();

	CATBody*pTopPlaneBody=NULL;
	pTopPlaneBody = TopSkin->GetResult();
	if (pTopPlaneBody==NULL)
	{
		cout<<"pTopPlaneBody==NULL"<<endl;
		return E_FAIL;
	}

	if (TopSkin!=NULL)
	{
		delete TopSkin;
		//TopSkin->Release();
		TopSkin = NULL;
	}
	//
	opBodyOnSurface = pTopPlaneBody;

	return rc;
}

//选择元素，转换成BaseUnknown，并同时返回所属Product(Instance)
void GeneralClass::TransferSelectToBU(CATFeatureImportAgent *pFeatAgent,CATBaseUnknown *&opBUSelection, CATIProduct_var &ospProductSeletion) 
{
	HRESULT rc = E_FAIL;

	if (pFeatAgent == NULL)
	{
		return;
	}
	CATISpecObject *piSpecOnSelection = NULL;
	CATPathElement *pPath = pFeatAgent->GetValue();
	CATBaseUnknown *pSelection = pFeatAgent->GetElementValue(pPath);

	opBUSelection = pSelection;

	//返回所属Product
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospProductSeletion = spPartObject;
	}
	ospProductSeletion = pProduct;
}

//选择元素，转换成BaseUnknown，并同时返回所属Product(Instance)
void GeneralClass::TransferSelectToBU(CATOtherDocumentAgent *pOtherDocAgent,CATBaseUnknown *&opBUSelection, CATIProduct_var &ospProductSeletion) 
{
	HRESULT rc = E_FAIL;

	if (pOtherDocAgent == NULL)
	{
		return;
	}
	CATISpecObject *piSpecOnSelection = NULL;
	CATPathElement *pPath = pOtherDocAgent->GetValue();
	CATBaseUnknown *pSelection = pOtherDocAgent->GetElementValue();

	opBUSelection = pSelection;

	//返回所属Product
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospProductSeletion = spPartObject;
	}
	ospProductSeletion = pProduct;
}

//设置高亮
void GeneralClass::SetHighlight(CATFeatureImportAgent *ipFeatImpAgt, CATHSO *ipHSO)
{

	CATPathElement* pPathEle = NULL;
	pPathEle = ipFeatImpAgt->GetValue();
	if (pPathEle != NULL)
	{
		ipHSO->Empty();
		ipHSO->AddElements(pPathEle);
		ipHSO->EndAddElements();
	}
}
//点击Selectorlist后高亮选择元素
void GeneralClass::SetHighlight(CATBaseUnknown *ipBUSelect, CATFrmEditor *ipEditor, CATHSO *ipHSO)
{
	if (ipHSO != NULL)
	{
		ipHSO->Empty();
	}

	if ((ipBUSelect != NULL) && (ipEditor != NULL) && (ipHSO != NULL))
	{
		CATIBuildPath *piBuildPath = NULL;
		HRESULT rc = ipBUSelect->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
		if (SUCCEEDED(rc))
		{
			CATPathElement context = ipEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
			if (pPathElement != NULL)
			{
				ipHSO->AddElement(pPathElement);
				pPathElement->Release();
				pPathElement = NULL;
			}
			piBuildPath->Release();
			piBuildPath = NULL;
		}
	}
}

//使用VB方法高亮
void GeneralClass::SetHighlight(CATBaseUnknown *pBUSelect)
{
	if (pBUSelect == NULL) return;
	HRESULT rc = E_FAIL;

	CATFrmEditor* pEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pEditor)
	{
		return;
	}
	CATDocument * pDrwDoc = pEditor -> GetDocument();
	if (pDrwDoc!=NULL)
	{
		CATIADocument *pCATIADoc = NULL;
		rc = pDrwDoc->QueryInterface(IID_CATIADocument,(void**)&pCATIADoc);
		if (pCATIADoc!=NULL)
		{
			CATIASelection *oSelection = NULL;
			pCATIADoc->get_Selection(oSelection);
			if (oSelection!=NULL)
			{
				CATIABase *iObject = NULL;
				rc = pBUSelect->QueryInterface(IID_CATIABase,(void**)&iObject);
				if (iObject!=NULL)
				{
					//oSelection->Clear();
					oSelection->Add(iObject);
				}
			}
		}

	}

	//get_Selection(out /*IDLRETVAL*/ CATIASelection oSelection);

	return;

	//CATHSO* pHSO = pEditor->GetHSO();
	//if (NULL == pHSO)
	//{
	//	return;
	//}

	//CATBaseUnknown * iElement = NULL;
	//iElement = spSpecObj;
	//if (iElement != NULL)
	//{
	//	pHSO->AddElements(iElement);
	//	pHSO->EndAddElements();
	//}

}

//从选择Agent返回对应的路径字符串
void GeneralClass::PathElementString(CATFeatureImportAgent *ipFeatImpAgt,CATUnicodeString &strPathName)
{
	//cout<<"==> Output String of PathElement"<<endl;
	HRESULT rc =E_FAIL;
	//
	CATPathElement* ipPath = NULL;
	ipPath = ipFeatImpAgt->GetValue();
	//
	strPathName = "";
	int NumOfPath = ipPath->GetSize();
	for(int i=0;i<NumOfPath;i++)  
	{
		CATBaseUnknown *pElt=(*ipPath)[i];
		if(pElt != NULL) 
		{
			CATIAlias *piAlias = NULL;
			rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
			if(SUCCEEDED(rc) && piAlias!=NULL)
			{
				CATUnicodeString Name = piAlias->GetAlias();
				strPathName.Append(Name) ;
				if(i<=(NumOfPath-2)) 
				{
					strPathName.Append("/");
				}
				piAlias->Release(); piAlias = NULL;
			}
		}
	}
}

//从PathElement返回对应路径字符串
void GeneralClass::PathElementString(CATPathElement *ipPathElem, CATUnicodeString &ostrPath)
{
	HRESULT rc =S_OK;

	ostrPath = "";
	int NumOfPath = ipPathElem->GetSize();
	for(int i=0;i<NumOfPath;i++)  
	{
		CATBaseUnknown *pElt=(*ipPathElem)[i];
		if(pElt != NULL) 
		{
			CATIAlias *piAlias = NULL;
			rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
			if(SUCCEEDED(rc) && piAlias!=NULL)
			{
				CATUnicodeString Name = piAlias->GetAlias();
				ostrPath.Append(Name) ;
				if(i<=(NumOfPath-2)) 
				{
					ostrPath.Append("/");
				}
				piAlias->Release(); piAlias = NULL;
			}
		}
	}
}

//获得输入节点下的所有存储信息
HRESULT GeneralClass::YFGetSpecAttrInfo(CATISpecObject_var ispiSpecOnObject)
{
	HRESULT rc=E_FAIL;

	//Check the input parameter
	if( !ispiSpecOnObject )  return rc;

	CATISpecAttrAccess_var spiSpecAttrAccess=ispiSpecOnObject;
	CATListValCATISpecAttrKey_var listAttrKey;
	//rc = spiSpecAttrAccess->ListAttrKeys(listAttrKey);
	spiSpecAttrAccess->ListAttrKeys(listAttrKey);
	//if( FAILED(rc) || listAttrKey.Size() < 1 ) return rc;
	if( listAttrKey.Size() < 1 ) return rc;

	CATISpecAttrKey_var spiSpecAttrKey=NULL_var;
	CATAttrKind attType,attListType;
	CATUnicodeString strAttName,strValue,strValueInList;
	CATUnicodeString strAttType,strAttListType,strAttQuality;
	int number;
	CATBoolean isBRepFeature;

	for(int i=1;i<=listAttrKey.Size();i++) 
	{
		spiSpecAttrKey = listAttrKey[i];
		if( !spiSpecAttrKey ) continue;

		strAttName = spiSpecAttrKey->GetName();

		if( sp_IN == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_IN";
		else if( sp_OUT == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_OUT";
		else if( sp_NEUTRAL == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_NEUTRAL";
		else 
			strAttQuality = "Unknown";

		attType = spiSpecAttrKey->GetType();
		strAttType = YFGetSpecAttType(attType);
		if( tk_list == attType ) {
			attListType = spiSpecAttrKey->GetListType();
			strAttListType = YFGetSpecAttType(attListType);
			strAttType = strAttType+CATUnicodeString("(")+strAttListType+CATUnicodeString(")");
			number = spiSpecAttrAccess->GetListSize(strAttName.ConvertToChar());

			strValue = "";
			for(int j=1;j<=number;j++) {
				strValueInList = YFGetSpecAttrValue(spiSpecAttrAccess,strAttName,j,attListType,isBRepFeature);
				if( j == 1 )
					strValue = strValueInList;
				else
					strValue = strValue + CATUnicodeString(";")+strValueInList;
			}

			cout << "==> Attribute Name: " << strAttName.ConvertToChar() << endl;
			cout << "              Type: " << strAttType.ConvertToChar() << endl;
			cout << "           Quality: " << strAttQuality.ConvertToChar() << endl;
			cout << "         List Size: " << number << endl;
			cout << "             Value: " << strValue.ConvertToChar() << endl;
			cout <<"============================================================="<<endl;
			if(tk_specobject == attListType || tk_component == attListType) 
			{
				//if( isBRepFeature )
				//	//cout << "      BRep Feature: TRUE " << endl;
				//else
				//	//cout << "      BRep Feature: FALSE " << endl;
			}
		}
		else 
		{
			strValue = YFGetSpecAttrValue(spiSpecAttrAccess,strAttName,0,attType,isBRepFeature);
			cout << "==> Attribute name: " << strAttName.ConvertToChar() << endl;
			cout << "              Type: " << strAttType.ConvertToChar() << endl;
			cout << "           Quality: " << strAttQuality.ConvertToChar() << endl;
			cout << "             Value: " << strValue.ConvertToChar() << endl;
			cout <<"===================================================="<<endl;
			if(tk_specobject == attType || tk_component == attType)
			{
				//	if( isBRepFeature )
				//		//cout << "      BRep Feature: TRUE " << endl;
				//	else
				//		//cout << "      BRep Feature: FALSE " << endl;
			}
		}
	}
	listAttrKey.RemoveAll();

	return rc;
}

//根据属性类型返回类型的字符串
CATUnicodeString GeneralClass::YFGetSpecAttType(CATAttrKind iAttrType)
{
	CATUnicodeString oStrType;
	if( tk_specobject == iAttrType )
		oStrType = "tk_specobject";
	else if( tk_string == iAttrType )
		oStrType = "tk_string";
	else if( tk_double == iAttrType )
		oStrType = "tk_double";
	else if( tk_integer == iAttrType )
		oStrType = "tk_integer";
	else if( tk_list == iAttrType )
		oStrType = "tk_list";
	else if( tk_boolean == iAttrType )
		oStrType = "tk_boolean";
	else if( tk_component == iAttrType )
		oStrType = "tk_component";
	else if( tk_external == iAttrType )
		oStrType = "tk_external";
	else if( tk_octet == iAttrType )
		oStrType = "tk_octet";
	else if( tk_any == iAttrType )
		oStrType = "tk_any";
	else
		oStrType = "Unknown";

	return oStrType;
}

//////////////////////////////////////////////////////
//说明：iIndex不为 0，则是从List中取值
/////////////////////////////////////////////////////
CATUnicodeString GeneralClass::YFGetSpecAttrValue(CATISpecAttrAccess_var spiSpecAttrAccess,CATUnicodeString iStrAttrName,int iIndex,CATAttrKind iAttrType,CATBoolean &oIsBRepFeature)
{
	CATUnicodeString oStrValue;
	oIsBRepFeature=FALSE;

	//Check the  input parameter
	if( !spiSpecAttrAccess || iStrAttrName.GetLengthInChar() < 1 || iIndex < 0 )  return oStrValue;

	//Get the attribute key
	CATISpecAttrKey *piAttrKey=spiSpecAttrAccess->GetAttrKey(iStrAttrName.ConvertToChar());
	if( !piAttrKey ) return oStrValue;

	CATIAlias_var spiAlias=NULL_var;
	CATBoolean valueBoolean=FALSE;
	int iValue;
	double dValue;
	CATISpecObject *piSpecValue=NULL;
	CATIMfBRep_var spiBRepObject=NULL_var;

	if( tk_specobject == iAttrType || tk_component == iAttrType ) {
		if( !iIndex )
			piSpecValue = spiSpecAttrAccess->GetSpecObject(piAttrKey);
		else
			piSpecValue = spiSpecAttrAccess->GetSpecObject(piAttrKey,iIndex);
		spiAlias = piSpecValue;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		spiBRepObject = piSpecValue;
		if( !!spiBRepObject ) { oIsBRepFeature = TRUE; }
		if( !!piSpecValue ) { piSpecValue->Release(); piSpecValue = NULL; }
	}
	else if( tk_string == iAttrType ) {
		if( !iIndex )
			oStrValue = spiSpecAttrAccess->GetString(piAttrKey);
		else
			oStrValue = spiSpecAttrAccess->GetString(piAttrKey,iIndex);
	}
	else if( tk_double == iAttrType ) {
		if( !iIndex )
			dValue = spiSpecAttrAccess->GetDouble(piAttrKey);
		else
			dValue = spiSpecAttrAccess->GetDouble(piAttrKey,iIndex);
		oStrValue.BuildFromNum(dValue);
	}
	else if( tk_integer == iAttrType ) {
		if( !iIndex )
			iValue = spiSpecAttrAccess->GetInteger(piAttrKey);
		else
			iValue = spiSpecAttrAccess->GetInteger(piAttrKey,iIndex);
		oStrValue.BuildFromNum(iValue);
	}
	else if( tk_boolean == iAttrType ) {
		if( !iIndex )
			valueBoolean = spiSpecAttrAccess->GetBoolean(piAttrKey);
		else
			valueBoolean = spiSpecAttrAccess->GetBoolean(piAttrKey,iIndex);
		if( valueBoolean )
			oStrValue = "TRUE";
		else
			oStrValue = "FALSE";
	}
	else if( tk_external == iAttrType ) {
		HRESULT rc=E_FAIL;
		CATILinkableObject *piLinkableObject=NULL;
		if( !iIndex )
			rc = spiSpecAttrAccess->GetExternalObject(piAttrKey,ANYWHERE,&piLinkableObject);
		else
			rc = spiSpecAttrAccess->GetExternalObject(piAttrKey,ANYWHERE,&piLinkableObject,iIndex);
		spiAlias = piLinkableObject;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		if( !!piLinkableObject ) { piLinkableObject->Release(); piLinkableObject = NULL; }
	}
	else if( tk_octet == iAttrType )
		oStrValue = "Octet";
	else if( tk_any == iAttrType ) {
		CATISpecAttrKey *piRealAttrKey=NULL;
		CATISpecObject_var spiSpecOnRealValue=NULL_var;
		if( !iIndex )
			piRealAttrKey = spiSpecAttrAccess->GetSpecAttribute(piAttrKey,spiSpecOnRealValue);
		else
			piRealAttrKey = spiSpecAttrAccess->GetSpecAttribute(piAttrKey,spiSpecOnRealValue,iIndex);
		spiAlias = spiSpecOnRealValue;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		if( !!piRealAttrKey ) { piRealAttrKey->Release(); piRealAttrKey = NULL; }
	}
	else
		oStrValue = "Unknown";

	//Release
	if( !!piAttrKey ) { piAttrKey->Release(); piAttrKey = NULL; }

	return oStrValue;
}

//描述：获取整个装配体的包围盒
//输入：Product对象
//输出：3D包围盒
//返回：HRESULT
HRESULT GeneralClass::Get3DBoundingBoxFromProduct(CATIProduct_var ispiProduct, CATMathBox &omathBox)
{
	HRESULT rc = S_OK;
	CATListValCATBaseUnknown_var *lstAllChildren = ispiProduct->GetAllChildren();
	if (lstAllChildren == NULL)
	{
		return E_FAIL;
	}
	//过滤出Part
	CATIProduct_var spChild = NULL_var;
	CATLISTP(CATIProduct) lstCATPart = NULL;
	for (int i = 1; i <= lstAllChildren->Size(); i++)
	{
		spChild = (*lstAllChildren)[i];
		if (IsProduct(spChild))
		{	
			continue;
		}
		lstCATPart.Append(spChild);
	}
	if (lstCATPart.Size()==0)
	{
		return E_FAIL;
	}
	//
	CATMathBox mathBoxAll;
	for (int i=1; i <= lstCATPart.Size(); i++)
	{
		CATUnicodeString strPartName = lstCATPart[i]->GetPartNumber();
		cout<<strPartName<<" : "<<endl;
		CATMathBox mathBoxSingle = Get3DBoundingBoxOfSinglePart(lstCATPart[i]);
		if (mathBoxSingle.IsEmpty())
		{
			cout<<"Mathbox empty!"<<endl;
			continue;
		}
		CATMathPoint mathPointHigh;
		CATMathPoint mathPointLow;
		mathBoxSingle.GetHighLimit(mathPointHigh);
		mathBoxSingle.GetLowLimit(mathPointLow);
		mathPointHigh.Dump();
		mathPointLow.Dump();
		mathBoxAll.AddInside(mathBoxSingle);
	}
	//
	omathBox = mathBoxAll;
	return rc;
}

//描述：获取对象的包围盒-------CATBody转成CATCell，再去获取
//输入：CATISpecObject对象
//输出：CATMathBox
//返回：CATMathBox
CATMathBox GeneralClass::Get3DBoundingBoxOfSinglePart(CATISpecObject_var ispiSpecProd)
{
	HRESULT rc=E_FAIL;
	CATMathBox oMathBox;

	if (ispiSpecProd == NULL_var)
	{
		cout<<"Get3DBoundingBox Failed"<<endl;
		return oMathBox;
	}
	CATIPrtContainer_var  spRootContainer = GetPrtContainer((CATIProduct_var)ispiSpecProd);
	if( spRootContainer == NULL_var )
	{
		cout <<"# Get Container error !" << endl;
		return oMathBox;
	}

	CATISpecObject_var spiSpecOnPart = spRootContainer -> GetPart();
	if (spiSpecOnPart == NULL_var)
	{
		cout<<"Get Part Failed!"<<endl;
		return oMathBox;
	}
	//cout<<"Part Name: "<<CATIAlias_var(spiSpecOnPart)->GetAlias()<<endl;

	//*******************************************************************************************
	//**********CATIDescendants会获取body下包含的布尔运算操作的别的body，从而影响最终的包围盒计算
	CATIDescendants *spDescendants = NULL;
	CATListValCATISpecObject_var  ListOfTriDimObjects;
	rc = spiSpecOnPart->QueryInterface(IID_CATIDescendants,(void**) &spDescendants);
	if( FAILED(rc) || spDescendants == NULL )
	{
		cout << "# Get CATIDescendants error !" << endl;
		return oMathBox;
	}

	spDescendants -> GetDirectChildren("CATIMechanicalTool",ListOfTriDimObjects);	//CATIMfTriDimResult , CATIMechanicalTool
	//用CATIMfTriDimResult，会获取到实体下的每一步带参操作，如果是类似pocket的去料操作，算包围盒会出错，在CATCreateDirBodyExtremum方法下会出错
	spDescendants->Release();
	spDescendants = NULL;
	//******************************************************************************************

	//***************改用CATIPartRequest，可以只获取所有最高一级的body，直接计算布尔运算以后的结果。
	CATIPartRequest *piPartRequest = NULL;
	CATListValCATBaseUnknown_var lstBodies = NULL;
	rc = spiSpecOnPart->QueryInterface(IID_CATIPartRequest,(void**) &piPartRequest);
	if (FAILED(rc) || piPartRequest == NULL)
	{
		return oMathBox;
	}
	piPartRequest->GetSolidBodies("",lstBodies);
	piPartRequest->Release();
	piPartRequest = NULL;

	//定义包络面方向
	CATMathVector mathVectorX(1,0,0);
	CATMathVector mathVectorY(0,1,0);
	CATMathVector mathVectorZ(0,0,1);

	if(lstBodies.Size()>0)
	{
		for (int i=1;i<=lstBodies.Size();i++)
		{
			CATISpecObject_var spCurrObj = lstBodies[i];
			if (NULL_var == spCurrObj) continue;

			//先判断当前的Body是否隐藏
			CATBoolean bShow = CheckShowState(spCurrObj);
			if (bShow == FALSE)
			{
				continue;
			}
			else	//当Body没有隐藏，再判断Body内的的solid是否隐藏
			{
				CATIDescendants *piDescendants = NULL;
				CATListValCATISpecObject_var  ListOfChildrenObjects;
				rc = spCurrObj->QueryInterface(IID_CATIDescendants,(void**) &piDescendants);
				if( FAILED(rc) || piDescendants == NULL )
				{
					cout << "# Get CATIDescendants error !" << endl;
					continue;
				}
				piDescendants->GetDirectChildren("CATIMfTriDimResult",ListOfChildrenObjects);
				piDescendants->Release();
				piDescendants = NULL;
				//判断该body下是否是空的，若空，直接返回
				if (ListOfChildrenObjects.Size() == 0)
				{
					continue;
				}
				//再检查子集是否隐藏
				bShow = CheckShowState(ListOfChildrenObjects[1]);
				if (bShow == FALSE)
				{
					continue;
				}
			}

			cout<<i<<" element "<<CATIAlias_var(spCurrObj)->GetAlias()<<endl;

			CATBody_var spBody = GetBodyFromFeature(spCurrObj);
			if(spBody != NULL_var)
			{
				CATMathBox tempBox;
				rc = GetBodyBoxFromExtremePt(spBody, (CATIProduct_var)ispiSpecProd, mathVectorX,mathVectorY,mathVectorZ,tempBox);
				if (SUCCEEDED(rc))
				{
					oMathBox.AddInside(tempBox);
				}
				//tempBox.Dump();
			}
		}
	}
	return oMathBox;
}

//描述：获取对象的包围盒-------CATBody转成CATCell，再去获取
//输入：CATISpecObject对象
//输出：CATMathBox
//返回：CATMathBox
HRESULT GeneralClass::Get3DBoundingBoxOfSinglePart(CATISpecObject_var ispiSpecProd, 
												   CATMathVector imathVecX,
												   CATMathVector imathVecY,
												   CATMathVector imathVecZ,
												   vector<CATMathPoint> &olstBoundingPts)
{
	HRESULT rc=S_OK;
	CATMathBox oMathBox;

	if (ispiSpecProd == NULL_var)
	{
		cout<<"Get3DBoundingBox Failed"<<endl;
		return E_FAIL;
	}
	CATIPrtContainer_var  spRootContainer = GetPrtContainer((CATIProduct_var)ispiSpecProd);
	if( spRootContainer == NULL_var )
	{
		cout <<"# Get Container error !" << endl;
		return E_FAIL;
	}

	CATISpecObject_var spiSpecOnPart = spRootContainer -> GetPart();
	if (spiSpecOnPart == NULL_var)
	{
		cout<<"Get Part Failed!"<<endl;
		return E_FAIL;
	}
	//cout<<"Part Name: "<<CATIAlias_var(spiSpecOnPart)->GetAlias()<<endl;

	//*******************************************************************************************
	//**********CATIDescendants会获取body下包含的布尔运算操作的别的body，从而影响最终的包围盒计算
	CATIDescendants *spDescendants = NULL;
	CATListValCATISpecObject_var  ListOfTriDimObjects;
	rc = spiSpecOnPart->QueryInterface(IID_CATIDescendants,(void**) &spDescendants);
	if( FAILED(rc) || spDescendants == NULL )
	{
		cout << "# Get CATIDescendants error !" << endl;
		return E_FAIL;
	}

	spDescendants -> GetDirectChildren("CATIMechanicalTool",ListOfTriDimObjects);	//CATIMfTriDimResult , CATIMechanicalTool
	//用CATIMfTriDimResult，会获取到实体下的每一步带参操作，如果是类似pocket的去料操作，算包围盒会出错，在CATCreateDirBodyExtremum方法下会出错
	spDescendants->Release();
	spDescendants = NULL;
	//******************************************************************************************

	//***************改用CATIPartRequest，可以只获取所有最高一级的body，直接计算布尔运算以后的结果。
	CATIPartRequest *piPartRequest = NULL;
	CATListValCATBaseUnknown_var lstBodies = NULL;
	rc = spiSpecOnPart->QueryInterface(IID_CATIPartRequest,(void**) &piPartRequest);
	if (FAILED(rc) || piPartRequest == NULL)
	{
		return E_FAIL;
	}
	piPartRequest->GetSolidBodies("",lstBodies);
	piPartRequest->Release();
	piPartRequest = NULL;

	//定义包络面方向
	//CATMathVector mathVectorX(1,0,0);
	//CATMathVector mathVectorY(0,1,0);
	//CATMathVector mathVectorZ(0,0,1);

	if(lstBodies.Size()>0)
	{
		for (int i=1;i<=lstBodies.Size();i++)
		{
			CATISpecObject_var spCurrObj = lstBodies[i];
			if (NULL_var == spCurrObj) continue;

			//先判断当前的Body是否隐藏
			CATBoolean bShow = CheckShowState(spCurrObj);
			if (bShow == FALSE)
			{
				continue;
			}
			else	//当Body没有隐藏，再判断Body内的的solid是否隐藏
			{
				CATIDescendants *piDescendants = NULL;
				CATListValCATISpecObject_var  ListOfChildrenObjects;
				rc = spCurrObj->QueryInterface(IID_CATIDescendants,(void**) &piDescendants);
				if( FAILED(rc) || piDescendants == NULL )
				{
					cout << "# Get CATIDescendants error !" << endl;
					continue;
				}
				piDescendants->GetDirectChildren("CATIMfTriDimResult",ListOfChildrenObjects);
				piDescendants->Release();
				piDescendants = NULL;
				//判断该body下是否是空的，若空，直接返回
				if (ListOfChildrenObjects.Size() == 0)
				{
					continue;
				}
				//再检查子集是否隐藏
				bShow = CheckShowState(ListOfChildrenObjects[1]);
				if (bShow == FALSE)
				{
					continue;
				}
			}

			cout<<i<<" element "<<CATIAlias_var(spCurrObj)->GetAlias()<<endl;

			CATBody_var spBody = GetBodyFromFeature(spCurrObj);
			if(spBody != NULL_var)
			{
				vector<CATMathPoint> lstExtremePts;
				rc = GetBodyBoxFromExtremePt(spBody, (CATIProduct_var)ispiSpecProd, imathVecX,imathVecY,imathVecZ,lstExtremePts);
				if (SUCCEEDED(rc))
				{
					//oMathBox.AddInside(tempBox);
					for (int j=0; j < lstExtremePts.size(); j++)
					{
						olstBoundingPts.push_back(lstExtremePts[j]);
					}
				}
				//tempBox.Dump();
			}
		}
	}
	return rc;
}


//描述：从CATBody转到CATCell再获取每个Cell的包围盒-------转到2维面获取每个2维面的包围盒，再叠加-----该方式求出的包络体偏大
//输入：Body对象
//输出：3D包围盒
//返回：HRESULT
HRESULT GeneralClass::GetBodyBox(CATBody_var  spBody,  CATIProduct_var ispiProduct, CATMathBox&  oMathBox)
{
	//HRESULT  HR_END  =  E_FAIL;

	////增加坐标变换系数
	//CATMathTransformation transAbs = GetAbsTransformation(ispiProduct);

	//CATVertex_var  spCell;
	//CATPoint_var  spPoint;
	//CATMathPoint  iMathPoint;
	//CATLISTP(CATCell)  iCellList  =  NULL;
	//spBody  ->  GetAllCells(iCellList,0);
	//if  (iCellList  !=  NULL  &&  iCellList.Size()  >  0)
	//{
	//	int  nums  =  iCellList.Size();
	//	for  (int  i  =  1  ;  i<=nums;  i++)
	//	{
	//		spCell  =  NULL_var;
	//		spCell  =  iCellList[i]; 
	//		spPoint  =  NULL_var;
	//		spPoint  =  spCell->GetPoint();
	//		iMathPoint  =  NULL;
	//		spPoint->GetMathPoint(iMathPoint);
	//		//
	//		iMathPoint = transAbs * iMathPoint;

	//		oMathBox.AddInside(iMathPoint);
	//	}
	//	HR_END  =  S_OK;
	//}
	//return  HR_END;

	HRESULT rc = S_OK;
	CATLISTP(CATCell) LISTCell; 
	spBody->GetAllCells( LISTCell, 2 ); 
	for( int index = 1; index <= LISTCell.Size(); index++ )
	{ 
		CATCell * pCell = LISTCell[index]; 
		if(pCell == NULL) 
		{
			cout<<"CATCell is NULL."<<endl;
			continue;
		}
		CATBody *pBody = NULL;
		rc = CreateBodyFromCell(pCell,ispiProduct,pBody);
		if (FAILED(rc) || pBody == NULL)
		{
			continue;
		}
		CATMathBox mathBoxFace;
		pBody->GetBoundingBox(mathBoxFace);
		//CATCell_var spCell = pCell;
		//if(spCell == NULL_var) 
		//{
		//	cout<<"CATCell_var is NULL_var."<<endl;
		//	continue;
		//}

		//CATFace_var spFace = spCell;
		//if(spFace == NULL_var) 
		//{
		//	cout<<"CATFace_var is NULL_var."<<endl;
		//	continue;
		//}

		//const CATMathBox *pmathBoxFace = spFace->Get3DBoundingBox();
		CATMathBox mathBoxFaceAbs;
		rc = GetAbsMathBox(ispiProduct,mathBoxFace,mathBoxFaceAbs);
		oMathBox.AddInside(mathBoxFaceAbs);

		//CATSurface_var spSurface = spFace->GetSurface();
		//if(spSurface == NULL_var)
		//{
		//	cout<<"CATSurface_var is NULL_var."<<endl;
		//	continue;
		//}
		//CATBody *pBodyOnSurface = NULL;
		//rc = GetBodyFromSurface(spSurface,ispiProduct,pBodyOnSurface);
		//if (SUCCEEDED(rc)&&pBodyOnSurface != NULL)
		//{
		//	CATMathBox mathBoxSurface = pBodyOnSurface->GetBoundingBox();
		//	CATMathBox mathBoxSurfaceAbs;
		//	rc = GetAbsMathBox(ispiProduct,mathBoxSurface,mathBoxSurfaceAbs);
		//	oMathBox.AddInside(mathBoxSurfaceAbs);
		//}
	}
	return rc;
}

//描述：求出Body的6个方向的极值，以此推导出包络体----------该方式求出的包络体较精确
//输入：Body对象
//输出：3D包围盒
//返回：HRESULT
HRESULT GeneralClass::GetBodyBoxFromExtremePt(CATBody_var  spBody,  CATIProduct_var ispiProduct, 
											  CATMathVector VAxeX, CATMathVector VAxeY, 
											  CATMathVector VAxeZ, CATMathBox&  oMathBox)
{
	HRESULT rc = S_OK;

	CATGeoFactory_var spGeoFac=spBody->GetContainer();

	if (spGeoFac==NULL_var)

	{

		return E_FAIL;

	}

	CATMathTransformation transAbs = GetAbsTransformation(ispiProduct);

	//获得特征的6个方向极值点

	CATBody_var spxyzmaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,1,spxyzmaxBody);



	CATBody_var spxyzminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,2,spxyzminBody);



	CATBody_var spyzxmaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,1,spyzxmaxBody);



	CATBody_var spyzxminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,2,spyzxminBody);



	CATBody_var spzxymaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,1,spzxymaxBody);



	CATBody_var spzxyminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,2,spzxyminBody);



	//过6个极值点做6个平面

	CATMathPoint zxymaxMathPoint;

	CATMathPoint zxyminMathPoint;

	GetMathPoint(spzxymaxBody,zxymaxMathPoint);

	GetMathPoint(spzxyminBody,zxyminMathPoint);

	CATMathPlane zxymaxXYPlane(zxymaxMathPoint,VAxeZ);

	CATMathPlane zxyminXYPlane(zxyminMathPoint,VAxeZ);




	CATMathPoint xyzmaxMathPoint;

	CATMathPoint xyzminMathPoint;

	GetMathPoint(spxyzmaxBody,xyzmaxMathPoint);

	GetMathPoint(spxyzminBody,xyzminMathPoint);

	CATMathPlane xyzmaxYZPlane(xyzmaxMathPoint,VAxeX);

	CATMathPlane xyzminYZPlane(xyzminMathPoint,VAxeX);




	CATMathPoint yzxmaxMathPoint;

	CATMathPoint yzxminMathPoint;

	GetMathPoint(spyzxmaxBody,yzxmaxMathPoint);

	GetMathPoint(spyzxminBody,yzxminMathPoint);

	CATMathPlane yzxmaxZXPlane(yzxmaxMathPoint,VAxeY);

	CATMathPlane yzxminZXPlane(yzxminMathPoint,VAxeY);

	zxymaxMathPoint.Dump();
	zxyminMathPoint.Dump();
	xyzmaxMathPoint.Dump();
	xyzminMathPoint.Dump();
	yzxmaxMathPoint.Dump();
	yzxminMathPoint.Dump();

	//平面求相交线

	CATMathLine zxymaxXYAndxyzmaxYZ;

	zxymaxXYPlane.Intersect(xyzmaxYZPlane,zxymaxXYAndxyzmaxYZ);

	CATMathPoint zxymaxXYAndxyzmaxYZPt;

	zxymaxXYAndxyzmaxYZ.GetOrigin(zxymaxXYAndxyzmaxYZPt);



	CATMathLine zxymaxXYAndxyzminYZ;

	zxymaxXYPlane.Intersect(xyzminYZPlane,zxymaxXYAndxyzminYZ);

	CATMathPoint zxymaxXYAndxyzminYZPt;

	zxymaxXYAndxyzminYZ.GetOrigin(zxymaxXYAndxyzminYZPt);



	CATMathLine zxymaxXYAndyzxmaxZX;

	zxymaxXYPlane.Intersect(yzxmaxZXPlane,zxymaxXYAndyzxmaxZX);

	CATMathPoint zxymaxXYAndyzxmaxZXPt;

	zxymaxXYAndyzxmaxZX.GetOrigin(zxymaxXYAndyzxmaxZXPt);



	CATMathLine zxymaxXYAndyzxminZX;

	zxymaxXYPlane.Intersect(yzxminZXPlane,zxymaxXYAndyzxminZX);

	CATMathPoint zxymaxXYAndyzxminZXPt;

	zxymaxXYAndyzxminZX.GetOrigin(zxymaxXYAndyzxminZXPt);



	//求出相交点，即为包围盒上表面的四个端点

	CATMathPoint projectMathPt1;

	zxymaxXYAndyzxmaxZX.Project(zxymaxXYAndxyzmaxYZPt,

		projectMathPt1);





	CATMathPoint projectMathPt2;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxmaxZXPt,

		projectMathPt2);





	CATMathPoint projectMathPt3;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt3);





	CATMathPoint projectMathPt4;

	zxymaxXYAndxyzmaxYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt4);





	//将四个投影点投影到zxyminXYPlane

	CATMathPoint projectMathPt5,projectMathPt6,projectMathPt7,projectMathPt8;

	zxyminXYPlane.Project(projectMathPt1,projectMathPt5);

	zxyminXYPlane.Project(projectMathPt2,projectMathPt6);

	zxyminXYPlane.Project(projectMathPt3,projectMathPt7);

	zxyminXYPlane.Project(projectMathPt4,projectMathPt8);



	projectMathPt1=transAbs*projectMathPt1;

	projectMathPt2=transAbs*projectMathPt2;

	projectMathPt3=transAbs*projectMathPt3;

	projectMathPt4=transAbs*projectMathPt4;

	projectMathPt5=transAbs*projectMathPt5;

	projectMathPt6=transAbs*projectMathPt6;

	projectMathPt7=transAbs*projectMathPt7;

	projectMathPt8=transAbs*projectMathPt8;

	//
	oMathBox.AddInside(projectMathPt1);
	oMathBox.AddInside(projectMathPt2);
	oMathBox.AddInside(projectMathPt3);
	oMathBox.AddInside(projectMathPt4);
	oMathBox.AddInside(projectMathPt5);
	oMathBox.AddInside(projectMathPt6);
	oMathBox.AddInside(projectMathPt7);
	oMathBox.AddInside(projectMathPt8);

	return rc;
}

//描述：求出Body的6个方向的极值，以此推导出包络体----------该方式求出的包络体较精确
//输入：Body对象
//输出：3D包围盒
//返回：HRESULT
HRESULT GeneralClass::GetBodyBoxFromExtremePt(CATBody_var  spBody,  CATIProduct_var ispiProduct, 
											  CATMathVector VAxeX, CATMathVector VAxeY, 
											  CATMathVector VAxeZ, vector<CATMathPoint> &olstEtremePts)
{
	HRESULT rc = S_OK;

	CATGeoFactory_var spGeoFac=spBody->GetContainer();

	if (spGeoFac==NULL_var)

	{

		return E_FAIL;

	}

	CATMathTransformation transAbs = GetAbsTransformation(ispiProduct);

	//获得特征的6个方向极值点

	CATBody_var spxyzmaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,1,spxyzmaxBody);



	CATBody_var spxyzminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,2,spxyzminBody);



	CATBody_var spyzxmaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,1,spyzxmaxBody);



	CATBody_var spyzxminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,2,spyzxminBody);



	CATBody_var spzxymaxBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,1,spzxymaxBody);



	CATBody_var spzxyminBody=NULL_var;

	CreateExtremePoint(spBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,2,spzxyminBody);



	//过6个极值点做6个平面

	CATMathPoint zxymaxMathPoint;

	CATMathPoint zxyminMathPoint;

	GetMathPoint(spzxymaxBody,zxymaxMathPoint);

	GetMathPoint(spzxyminBody,zxyminMathPoint);

	CATMathPlane zxymaxXYPlane(zxymaxMathPoint,VAxeZ);

	CATMathPlane zxyminXYPlane(zxyminMathPoint,VAxeZ);




	CATMathPoint xyzmaxMathPoint;

	CATMathPoint xyzminMathPoint;

	GetMathPoint(spxyzmaxBody,xyzmaxMathPoint);

	GetMathPoint(spxyzminBody,xyzminMathPoint);

	CATMathPlane xyzmaxYZPlane(xyzmaxMathPoint,VAxeX);

	CATMathPlane xyzminYZPlane(xyzminMathPoint,VAxeX);




	CATMathPoint yzxmaxMathPoint;

	CATMathPoint yzxminMathPoint;

	GetMathPoint(spyzxmaxBody,yzxmaxMathPoint);

	GetMathPoint(spyzxminBody,yzxminMathPoint);

	CATMathPlane yzxmaxZXPlane(yzxmaxMathPoint,VAxeY);

	CATMathPlane yzxminZXPlane(yzxminMathPoint,VAxeY);

	zxymaxMathPoint.Dump();
	zxyminMathPoint.Dump();
	xyzmaxMathPoint.Dump();
	xyzminMathPoint.Dump();
	yzxmaxMathPoint.Dump();
	yzxminMathPoint.Dump();

	//平面求相交线

	CATMathLine zxymaxXYAndxyzmaxYZ;

	zxymaxXYPlane.Intersect(xyzmaxYZPlane,zxymaxXYAndxyzmaxYZ);

	CATMathPoint zxymaxXYAndxyzmaxYZPt;

	zxymaxXYAndxyzmaxYZ.GetOrigin(zxymaxXYAndxyzmaxYZPt);



	CATMathLine zxymaxXYAndxyzminYZ;

	zxymaxXYPlane.Intersect(xyzminYZPlane,zxymaxXYAndxyzminYZ);

	CATMathPoint zxymaxXYAndxyzminYZPt;

	zxymaxXYAndxyzminYZ.GetOrigin(zxymaxXYAndxyzminYZPt);



	CATMathLine zxymaxXYAndyzxmaxZX;

	zxymaxXYPlane.Intersect(yzxmaxZXPlane,zxymaxXYAndyzxmaxZX);

	CATMathPoint zxymaxXYAndyzxmaxZXPt;

	zxymaxXYAndyzxmaxZX.GetOrigin(zxymaxXYAndyzxmaxZXPt);



	CATMathLine zxymaxXYAndyzxminZX;

	zxymaxXYPlane.Intersect(yzxminZXPlane,zxymaxXYAndyzxminZX);

	CATMathPoint zxymaxXYAndyzxminZXPt;

	zxymaxXYAndyzxminZX.GetOrigin(zxymaxXYAndyzxminZXPt);



	//求出相交点，即为包围盒上表面的四个端点

	CATMathPoint projectMathPt1;

	zxymaxXYAndyzxmaxZX.Project(zxymaxXYAndxyzmaxYZPt,

		projectMathPt1);





	CATMathPoint projectMathPt2;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxmaxZXPt,

		projectMathPt2);





	CATMathPoint projectMathPt3;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt3);





	CATMathPoint projectMathPt4;

	zxymaxXYAndxyzmaxYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt4);





	//将四个投影点投影到zxyminXYPlane

	CATMathPoint projectMathPt5,projectMathPt6,projectMathPt7,projectMathPt8;

	zxyminXYPlane.Project(projectMathPt1,projectMathPt5);

	zxyminXYPlane.Project(projectMathPt2,projectMathPt6);

	zxyminXYPlane.Project(projectMathPt3,projectMathPt7);

	zxyminXYPlane.Project(projectMathPt4,projectMathPt8);



	projectMathPt1=transAbs*projectMathPt1;

	projectMathPt2=transAbs*projectMathPt2;

	projectMathPt3=transAbs*projectMathPt3;

	projectMathPt4=transAbs*projectMathPt4;

	projectMathPt5=transAbs*projectMathPt5;

	projectMathPt6=transAbs*projectMathPt6;

	projectMathPt7=transAbs*projectMathPt7;

	projectMathPt8=transAbs*projectMathPt8;

	//
	olstEtremePts.push_back(projectMathPt1);
	olstEtremePts.push_back(projectMathPt2);
	olstEtremePts.push_back(projectMathPt3);
	olstEtremePts.push_back(projectMathPt4);
	olstEtremePts.push_back(projectMathPt5);
	olstEtremePts.push_back(projectMathPt6);
	olstEtremePts.push_back(projectMathPt7);
	olstEtremePts.push_back(projectMathPt8);

	return rc;
}

//从Cell转到Body------2维曲面
HRESULT GeneralClass::CreateBodyFromCell(CATCell *ipCell,CATIProduct_var ispiProduct,CATBody *&opBodyOnCell)
{
	HRESULT rc = S_OK;
	//
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata

	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=GetProductGeoFactoryAndPrtCont(ispiProduct,ospiCont);
	if (ospiCont==NULL_var||pGeoFactory==NULL)
	{
		cout<<"GetProductGeoFactoryAndPrtCont Failed"<<endl;
		return E_FAIL;
	}
	//
	CATBody *pBody = pGeoFactory->CreateBody();
	CATDomain *pDomain = pBody->CreateDomain(2);
	pDomain->AddCell(ipCell);
	pBody->AddDomain(pDomain);
	if (pBody == NULL)
	{
		return E_FAIL;
	}
	//
	opBodyOnCell = pBody;
	return rc;
}


//描述：获取矩阵
//输入：CATISpecObject对象1，CATMathBox包围盒
//输出：CATMathBox
//返回：HRESULT
HRESULT GeneralClass::GetAbsMathBox(CATISpecObject_var ispiSpecObj,
									CATMathBox iBox,
									CATMathBox &oAbsBox)
{
	HRESULT rc=S_OK;

	double iMinPoint[3]={DBL_MAX, DBL_MAX, DBL_MAX};
	double iMaxPoint[3]={-DBL_MAX, -DBL_MAX, -DBL_MAX};
	iBox.GetLimits(iMinPoint[0],iMaxPoint[0],iMinPoint[1],iMaxPoint[1],iMinPoint[2],iMaxPoint[2]); 

	CATMathTransformation pMathTrans = GetAbsTransformation(ispiSpecObj);  
	CATMathPoint iTempPt1=CATMathPoint(iMinPoint[0],iMinPoint[1],iMinPoint[2]);
	CATMathPoint iTempPt2=CATMathPoint(iMaxPoint[0],iMinPoint[1],iMinPoint[2]);
	CATMathPoint iTempPt3=CATMathPoint(iMaxPoint[0],iMaxPoint[1],iMinPoint[2]);
	CATMathPoint iTempPt4=CATMathPoint(iMinPoint[0],iMaxPoint[1],iMinPoint[2]);
	CATMathPoint iTempPt5=CATMathPoint(iMaxPoint[0],iMinPoint[1],iMaxPoint[2]);
	CATMathPoint iTempPt6=CATMathPoint(iMaxPoint[0],iMaxPoint[1],iMaxPoint[2]);
	CATMathPoint iTempPt7=CATMathPoint(iMinPoint[0],iMaxPoint[1],iMaxPoint[2]);
	CATMathPoint iTempPt8=CATMathPoint(iMinPoint[0],iMinPoint[1],iMaxPoint[2]);
	iTempPt1=pMathTrans*iTempPt1;
	iTempPt2=pMathTrans*iTempPt2;
	iTempPt3=pMathTrans*iTempPt3;
	iTempPt4=pMathTrans*iTempPt4;
	iTempPt5=pMathTrans*iTempPt5;
	iTempPt6=pMathTrans*iTempPt6;
	iTempPt7=pMathTrans*iTempPt7;
	iTempPt8=pMathTrans*iTempPt8;

	oAbsBox.AddInside(iTempPt1);
	oAbsBox.AddInside(iTempPt2);
	oAbsBox.AddInside(iTempPt3);
	oAbsBox.AddInside(iTempPt4);
	oAbsBox.AddInside(iTempPt5);
	oAbsBox.AddInside(iTempPt6);
	oAbsBox.AddInside(iTempPt7);
	oAbsBox.AddInside(iTempPt8);

	return rc;
}


//描述：获取PartContainer
//输入：CATIProduct产品对象
//输出：CATIPrtContainer
//返回：CATIPrtContainer
CATIPrtContainer_var GeneralClass::GetPrtContainer(CATIProduct_var  ispiObject)
{
	HRESULT rc;

	CATIPrtContainer_var spRootCont=NULL_var;
	if (ispiObject ==NULL_var)
	{
		cout<<"GetPrtContainer Failed"<<endl;
		return spRootCont;
	}
	CATIProduct_var spRefProduct =ispiObject->GetReferenceProduct();
	if( NULL_var == spRefProduct ) return spRootCont;

	CATILinkableObject *piLinkableObject = NULL;
	rc = spRefProduct ->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObject);
	if( FAILED(rc) || piLinkableObject == NULL ) return  spRootCont;

	// Do not release this pointer
	// Get the document.
	CATDocument * pDoc = NULL ;
	pDoc = piLinkableObject->GetDocument();
	piLinkableObject->Release();        piLinkableObject = NULL ;
	if( pDoc == NULL )
	{
		return spRootCont;
	}
	//Get Init
	CATInit_var spInitOnDoc(pDoc);
	if(NULL_var == spInitOnDoc)
	{
		return spRootCont;
	}
	CATIPrtContainer *piPrtContainerOnRoot  = (CATIPrtContainer*)spInitOnDoc->GetRootContainer("CATIPrtContainer");	
	if(piPrtContainerOnRoot!=NULL)
	{
		spRootCont=piPrtContainerOnRoot;
		piPrtContainerOnRoot->Release();
		piPrtContainerOnRoot=NULL;
	}
	return spRootCont;
}

//描述：查看特征的显示类型
//输入：CATISpecObject对象
//输出：CATBoolean
//返回：CATBoolean
CATBoolean GeneralClass::CheckShowState(CATISpecObject_var spSpec)
{
	HRESULT rc=S_OK;
	CATBoolean bHide=TRUE;
	CATIVisProperties* piVisProp=NULL;
	if(SUCCEEDED(spSpec->QueryInterface(IID_CATIVisProperties,(void**)&piVisProp)))
	{
		CATVisPropertiesValues ioValues;
		rc=piVisProp->GetPropertiesAtt(ioValues,CATVPShow,CATVPGlobalType);
		CATShowAttribut oShow;
		ioValues.GetShowAttr(oShow);
		if(oShow==CATNoShowAttr)
		{
			bHide=FALSE;
		}
		piVisProp->Release();
		piVisProp=NULL;
	}
	return bHide;
}


//计算整车绝对坐标系下的transformation
CATMathTransformation GeneralClass::GetAbsTransformation(CATIProduct_var ispCurrentProduct)
{
	if (ispCurrentProduct==NULL_var)
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATIMovable_var spiMovableTwo(ispCurrentProduct);
	if(spiMovableTwo == NULL_var)
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATMathTransformation pMathTrans;
	spiMovableTwo->GetAbsPosition( pMathTrans);

	return pMathTrans;
}

//从Product获取对应的CATGeoFactory和PrtContainer
CATGeoFactory* GeneralClass::GetProductGeoFactoryAndPrtCont(CATIProduct_var ispProduct,CATIPrtContainer_var &ospiCont)
{
	CATIProduct_var spiRefProduct=ispProduct->GetReferenceProduct();
	CATILinkableObject_var spiRefLink=spiRefProduct;
	//CATILinkableObject_var spiRefLink=ispProduct;		注：Instance Product不能直接赋给LinkableObj，后面取到的Document即使不为空，也会影响后续转到Container（会失败)
	CATDocument *opDocument=NULL;
	if( !!spiRefLink ) 
	{
		opDocument = spiRefLink->GetDocument();
	}
	CATGeoFactory*pGeoFactory=GetCATGeoFactory(opDocument);
	GetPrtContFromPrd(ispProduct,ospiCont);
	return pGeoFactory;
}

//从Product获取对应的PrtContainer
void GeneralClass::GetPrtContFromPrd(CATIProduct_var ispiPrd, CATIPrtContainer_var & ospiCont)
{
	//获取Container
	CATDocument * pPrdDocument = NULL;
	GetReferencePrdDocument(ispiPrd, pPrdDocument);
	CATIPrtContainer_var  spiPrtCont = NULL_var;
	GetContOfPartDocument(pPrdDocument, spiPrtCont);
	ospiCont = spiPrtCont;
}

//从Product获取对应的Document
HRESULT GeneralClass::GetReferencePrdDocument(CATIProduct_var ispiInstanceProduct,CATDocument *&opDocument)
{
	HRESULT rc=E_FAIL;
	opDocument = NULL;

	if(ispiInstanceProduct==NULL_var) return rc;

	CATIProduct_var spiRefProduct=ispiInstanceProduct->GetReferenceProduct();

	CATILinkableObject_var spiRefLink=spiRefProduct;

	if( !!spiRefLink ) 
	{
		opDocument = spiRefLink->GetDocument();
		rc = S_OK;
	}

	return rc;
}

//从Document获取PrtContainer
HRESULT GeneralClass::GetContOfPartDocument(CATDocument *ipDocument,CATIPrtContainer_var &opiCont)
{
	HRESULT rc=E_FAIL;

	if( !ipDocument ) return rc;

	CATInit_var spInit = ipDocument;
	CATIPrtContainer *piPrtContainer=NULL;
	if( !!spInit )
		piPrtContainer = (CATIPrtContainer *)spInit->GetRootContainer("CATIPrtContainer");
	opiCont = piPrtContainer;
	return rc;
}

//从Document获取CATGeoFactory
CATGeoFactory*GeneralClass::GetCATGeoFactory(CATDocument * ipDoc)
{
	HRESULT rc;
	CATGeoFactory * pGeoFactory = NULL;	
	if ( NULL != ipDoc )
	{
		CATIContainerOfDocument * pIContainerOfDocument = NULL ;
		rc = ipDoc->QueryInterface(IID_CATIContainerOfDocument, (void**)& pIContainerOfDocument );
		if ( SUCCEEDED(rc) )
		{
			CATIContainer * pIContainerOnGeomContainer = NULL ;
			rc = pIContainerOfDocument->GetResultContainer(pIContainerOnGeomContainer);
			if ( SUCCEEDED(rc) )
			{
				rc = pIContainerOnGeomContainer->QueryInterface( IID_CATGeoFactory, (void**)&pGeoFactory );
				if(pGeoFactory==NULL || FAILED(rc))
				{
					cout<<"QueryInterface pGeoFactory FAILED"<<endl;
					return NULL;
				}
			}
		}
	}
	else
	{
		cout<<"pDoc is NULL"<<endl;
		return NULL;
	}

	return pGeoFactory;
}

//Body根据3个方向获得6个极值点的Body
void GeneralClass::CreateExtremePoint(CATBody_var ispBody,CATGeoFactory_var ispGeoFac ,
									  CATMathVector iFirstVT,CATMathVector iSecondVT,
									  CATMathVector iThirdVT,int iMaxOrMin,CATBody_var &ospPointBody)

{

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();

	CATTopData topdata(pConfig);

	CATMinMax minormax;

	if (iMaxOrMin==1)//最大

	{

		minormax=CATMaximum;

	}

	else//最小

	{

		minormax=CATMinimum;

	}



	CATMathPoint Origin(0,0,0);

	CATTopBodyExtremum  *pOption1  =  CATCreateDirBodyExtremum(ispGeoFac,  

		&topdata,ispBody,minormax,iFirstVT,Origin)  ; 

	CATBody_var spOptionBody1=NULL_var;

	if  (pOption1)

	{

		pOption1->Run();

		cout << "Min along X " << pOption1->GetExtremum() << endl;

		spOptionBody1 =  pOption1->GetResult();

		//pOption1->Release();

		//pOption1  =  NULL;





		CATTopBodyExtremum  *pOption2  =  CATCreateDirBodyExtremum(ispGeoFac,  

			&topdata,spOptionBody1,minormax,iSecondVT,Origin)  ; 

		CATBody_var spOptionBody2=NULL_var;

		if  (pOption2)

		{

			pOption2->Run();

			cout << "Min along X " << pOption2->GetExtremum() << endl;

			spOptionBody2 =  pOption2->GetResult();

			//pOption2->Release();

			//pOption2  =  NULL;



			//最后得到点

			CATTopBodyExtremum  *pOption3  =  CATCreateDirBodyExtremum(ispGeoFac,  

				&topdata,spOptionBody2,minormax,iThirdVT,Origin)  ; 

			CATBody_var spOptionBody3=NULL_var;

			if  (pOption3)

			{

				pOption3->Run();

				cout << "Min along X " << pOption3->GetExtremum() << endl;

				spOptionBody3 =  pOption3->GetResult();

				//pOption3->Release();

				//pOption3  =  NULL;

				ospPointBody=spOptionBody3;

			}

		}

	}

}

//从body获得MathPoint
HRESULT GeneralClass::GetMathPoint(CATBody_var ispPointBody,CATMathPoint& oMathPoint)

{

	if(ispPointBody != NULL_var)

	{

		//计算所有点的角度

		CATLISTP(CATCell) LISTCell;

		ispPointBody->GetAllCells( LISTCell, 0 );

		for( int index = 1; index <= LISTCell.Size(); index++ )

		{

			CATCell * pCell = LISTCell[index];

			if(pCell == NULL)

			{

				cout<<"CATCell is NULL."<<endl;

				continue;

			}



			CATCell_var spCell = pCell;



			CATVertex_var spVertex = spCell;

			if(spVertex == NULL_var)

			{

				cout<<"CATVertex is NULL_var."<<endl;

				continue;

			}



			CATPoint *pPoint = spVertex->GetPoint();

			if(pPoint == NULL)

			{

				cout<<"GetPoint failed."<<endl;

				continue;

			}



			pPoint->GetMathPoint(oMathPoint);

			return S_OK;

		}

	}

	return E_FAIL;

}

//获得曲面的中点-------CATCell和CATFace的两个直接计算中点的方法结果一样，都有缺陷，月牙形的一半环形平面所获得的计算中点仍然在曲面外
CATBoolean GeneralClass::GetMidPtOfSurface(CATBody_var ispObjectBody,
										   CATMathPoint &omathPoint,
										   CATMathVector  &omathVector)
{
	CATLISTP(CATCell) LISTCell; 
	ispObjectBody->GetAllCells(LISTCell, 2 ); 
	if (LISTCell.Size()==0)
	{
		cout<<"GetAllCells Surface Failed"<<endl;
		return FALSE;
	}

	for( int index = 1; index <= LISTCell.Size(); index++ )
	{ 
		CATCell * pCell = LISTCell[index]; 
		if(pCell == NULL) 
		{
			continue;
		}

		CATCell_var spCell = pCell;
		if (spCell==NULL_var)
		{
			continue;
		}
		//该方法求出的曲面中点和下面的CATFace中的方法结果一样，都是有缺陷的
		CATMathPoint mathPointCenter;
		pCell->EstimateCenter(mathPointCenter);

		CATFace_var spFace = spCell;
		if(spFace == NULL_var)
		{
			continue;
		}

		CATSurParam oCenterParam;
		spFace->EstimateCenterParam(oCenterParam);

		CATSurface_var spSurface = spFace->GetSurface();
		if(spSurface == NULL_var) 
		{
			continue;
		}

		CATMathPoint mathPoint = spSurface->EvalPoint(oCenterParam);
		CATMathVector  mathVector;
		spFace->EvalNormal(oCenterParam,  mathVector); 

		omathPoint=mathPoint;
		omathVector=mathVector;

		double areaValue;
		areaValue = spFace->CalcArea();
		cout<<"areaValue:"<<areaValue<<endl;

		return TRUE;
	}
	return FALSE;
}

//从Inertia测量中获取零件边界的8个顶点-----------没有直接方法获得测量结果内的长宽高，所以该方法暂时舍弃
HRESULT GeneralClass::GetBoundingPtsFromInertia(CATIProduct_var ispiProd,vector<CATMathPoint> &olstBoundingPts)
{
	HRESULT rc = S_OK;
	//
	CATIInertia* piInertiaOnProduct = NULL;
	rc = ispiProd->QueryInterface(IID_CATIInertia,(void**)&piInertiaOnProduct);
	if (FAILED(rc) || piInertiaOnProduct == NULL)
	{
		return E_FAIL;
	}
	//获取重心点
	double arrayCOG[3];
	piInertiaOnProduct->GetCOGPosition(arrayCOG);
	for (int i=0; i<=2; i++)
	{
		arrayCOG[i] = 1000 * arrayCOG[i];
	}
	//获取计算轴系方向
	double arrayAxes[9];
	piInertiaOnProduct->GetPrincipalAxes(arrayAxes);
	//获取长宽高
	double arrayXYZ[3];
	double dblDensity;
	//piInertiaOnProduct->GetInertiaVolume(arrayXYZ);
	piInertiaOnProduct->GetPrincipalMoments(&dblDensity,arrayXYZ);
	//获取局部坐标系的3个方向
	double arrayXdirMax[3] = {0.5*arrayXYZ[0]*arrayAxes[0],0.5*arrayXYZ[0]*arrayAxes[1],0.5*arrayXYZ[0]*arrayAxes[2]};
	double arrayXdirMin[3] = {-0.5*arrayXYZ[0]*arrayAxes[0],-0.5*arrayXYZ[0]*arrayAxes[1],-0.5*arrayXYZ[0]*arrayAxes[2]};
	double arrayYdirMax[3] = {0.5*arrayXYZ[1]*arrayAxes[3],0.5*arrayXYZ[1]*arrayAxes[4],0.5*arrayXYZ[1]*arrayAxes[5]};
	double arrayYdirMin[3] = {-0.5*arrayXYZ[1]*arrayAxes[3],-0.5*arrayXYZ[1]*arrayAxes[4],-0.5*arrayXYZ[1]*arrayAxes[5]};
	double arrayZdirMax[3] = {0.5*arrayXYZ[2]*arrayAxes[6],0.5*arrayXYZ[2]*arrayAxes[7],0.5*arrayXYZ[2]*arrayAxes[8]};
	double arrayZdirMin[3] = {-0.5*arrayXYZ[2]*arrayAxes[6],-0.5*arrayXYZ[2]*arrayAxes[7],-0.5*arrayXYZ[2]*arrayAxes[8]};
	//计算8个顶点
	double arrTemp1[3], arrTemp2[3], arrTemp3[3];
	double arrLow1[3],arrLow2[3],arrLow3[3],arrLow4[3],arrHigh1[3],arrHigh2[3],arrHigh3[3],arrHigh4[3];
	//Low
	D3PointMove(arrayCOG,arrayXdirMin,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMin,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMin,arrTemp3);
	D3ArrayCopy(arrTemp3,arrLow1);

	D3PointMove(arrayCOG,arrayXdirMin,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMax,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMin,arrTemp3);
	D3ArrayCopy(arrTemp3,arrLow2);

	D3PointMove(arrayCOG,arrayXdirMax,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMin,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMin,arrTemp3);
	D3ArrayCopy(arrTemp3,arrLow3);

	D3PointMove(arrayCOG,arrayXdirMax,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMax,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMin,arrTemp3);
	D3ArrayCopy(arrTemp3,arrLow4);

	//High
	D3PointMove(arrayCOG,arrayXdirMin,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMin,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMax,arrTemp3);
	D3ArrayCopy(arrTemp3,arrHigh1);

	D3PointMove(arrayCOG,arrayXdirMin,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMax,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMax,arrTemp3);
	D3ArrayCopy(arrTemp3,arrHigh2);

	D3PointMove(arrayCOG,arrayXdirMax,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMin,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMax,arrTemp3);
	D3ArrayCopy(arrTemp3,arrHigh3);

	D3PointMove(arrayCOG,arrayXdirMax,arrTemp1);
	D3PointMove(arrTemp1,arrayYdirMax,arrTemp2);
	D3PointMove(arrTemp2,arrayZdirMax,arrTemp3);
	D3ArrayCopy(arrTemp3,arrHigh4);

	olstBoundingPts.push_back(CATMathPoint(arrLow1));
	olstBoundingPts.push_back(CATMathPoint(arrLow2));
	olstBoundingPts.push_back(CATMathPoint(arrLow3));
	olstBoundingPts.push_back(CATMathPoint(arrLow4));
	olstBoundingPts.push_back(CATMathPoint(arrHigh1));
	olstBoundingPts.push_back(CATMathPoint(arrHigh2));
	olstBoundingPts.push_back(CATMathPoint(arrHigh3));
	olstBoundingPts.push_back(CATMathPoint(arrHigh4));

	return rc;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATLISTV(CATUnicodeString)属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATLISTV(CATUnicodeString) iLstStrings)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_string),sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetListString(pKey,iLstStrings);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATLISTV(CATUnicodeString属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATLISTV(CATUnicodeString) &oLstStrings)
{
	if (oLstStrings.Size()>0) 
	{
		oLstStrings.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListValCATUnicodeString* pList=spiMPAc->GetListString (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL;
	//
	oLstStrings=*pList;
	delete pList;
	pList=NULL;

	//
	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATListOfDouble属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,CATUnicodeString istrKey,CATListOfDouble  iValueList)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	//创建新的属性
	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_double),sp_NEUTRAL);//sp_NEUTRAL sp_IN sp_OUT
		if(pAttr==NULL) return E_FAIL;
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}

	spiMPAc->SetListDouble(pKey,iValueList);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATListOfDouble属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATListOfDouble &oLstDouble)
{
	if (oLstDouble.Size()>0) 
	{
		oLstDouble.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListOfDouble* pList=spiMPAc->GetListDouble (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL;
	//
	oLstDouble=*pList;
	delete pList;
	pList=NULL;

	//

	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATListOfInt属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,CATUnicodeString istrKey,CATListOfInt  iValueList)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	//创建新的属性
	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_integer),sp_NEUTRAL);//sp_NEUTRAL sp_IN sp_OUT
		if(pAttr==NULL) return E_FAIL;
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}

	spiMPAc->SetListInteger(pKey,iValueList);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATListOfInt属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATListOfInt &oLstInteger)
{
	if (oLstInteger.Size()>0) 
	{
		oLstInteger.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListOfInt* pList=spiMPAc->GetListInteger (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL;
	//
	oLstInteger=*pList;
	delete pList;
	pList=NULL;

	//
	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，int属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  int iValue)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_integer,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetInteger(pKey,iValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：int属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  int &oValue)
{
	oValue = 0;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	oValue=spiMPAc->GetInteger (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，double属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  double iValue)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_double,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetDouble(pKey,iValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：double属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  double &oValue)
{
	oValue = 0;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	oValue=spiMPAc->GetDouble (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATUnicodeString属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATUnicodeString istrValue)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_string,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetString(pKey,istrValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATUnicodeString属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
											  CATUnicodeString istrKey,
											  CATUnicodeString &ostrValue)
{
	ostrValue = "";

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	ostrValue=spiMPAc->GetString (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}


//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATBoolean属性值
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
												CATUnicodeString istrKey,
												CATBoolean ibBool)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_boolean,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetBoolean(pKey,ibBool);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATBoolean属性值
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
												CATUnicodeString istrKey,
												CATBoolean obBool)
{
	obBool = FALSE;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATBoolean bBool =spiMPAc->GetBoolean (pKey);

	pKey->Release();
	pKey=NULL;

	//
	obBool=bBool;

	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATISpecObject对象属性
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::YFSetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
												CATUnicodeString istrKey,
												CATISpecObject_var ispiSpecSetObj)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_specobject,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetSpecObject(pKey,ispiSpecSetObj);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATISpecObject对象属性
//返回：HRESULT
HRESULT GeneralClass::YFGetSpecObjectAttrEx(CATISpecObject_var ispiSpecObject,
												CATUnicodeString istrKey,
												CATISpecObject_var &ospiSpecGetObj)
{
	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATISpecObject *piSpecObj;
	piSpecObj=spiMPAc->GetSpecObject(pKey);

	ospiSpecGetObj = piSpecObj;

	pKey->Release();
	pKey=NULL;

	return S_OK;
}


//获取当前屏幕所在平面
void GeneralClass::GetPlaneFromScreen(CATMathPlane &omathPlaneScreen)
{
	CATFrmLayout * pCurrentLayout = CATFrmLayout::GetCurrentLayout();
	if ( NULL != pCurrentLayout )
	{
		CATFrmWindow * pCurrentWindow = pCurrentLayout->GetCurrentWindow();
		if ( NULL != pCurrentWindow )
		{
			CATICamera * piICamera = NULL;
			piICamera = pCurrentWindow->GetCurrentCamera();

			if (NULL != piICamera) 
			{
				CATI3DCamera * pi3DCamera = NULL;
				HRESULT rc = piICamera->QueryInterface(IID_CATI3DCamera,(void **)& pi3DCamera);

				if ( SUCCEEDED(rc) )
				{
					CATMathPoint SightOrg = pi3DCamera->GetOrigin();
					CATMathDirection SightDir = pi3DCamera->GetDirection();	//视线方向是垂直屏幕，并且默认是朝内，不是朝外
					CATMathDirection SightUD = pi3DCamera->GetZenith();		//屏幕的上下方向，默认朝上
					CATMathDirection SightLR = SightDir ^ SightUD;
					SightLR.Normalize();
					SightUD.Normalize();
					CATMathPlane mathPlaneSight(SightOrg,SightLR,SightUD);
					CATMathVector mathVecNormal;
					mathPlaneSight.GetNormal(mathVecNormal);
					cout<<"SightOrg: "<<endl;
					SightOrg.Dump();
					cout<<"SightDir: "<<endl;
					SightDir.Dump();
					cout<<"SightUD: "<<endl;
					SightUD.Dump();
					cout<<"SightLR: "<<endl;
					SightLR.Dump();
					cout<<"Screen Normal Dir: "<<endl;
					mathVecNormal.Dump();

					omathPlaneScreen = mathPlaneSight;

					pi3DCamera->Release(); 
					pi3DCamera=NULL;
				}
				piICamera->Release();
				piICamera= NULL ;
			}
		}
	}

}


//***********************************************************************************************************************************
//***********************************************************************************************************************************
//************************************              2D图纸相关公共函数        *******************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************
//描述：获取图纸的所有Sheet
//输入：CATDocument文档
//输出：vector<CATIDftSheet>
//返回：HRESULT
HRESULT GeneralClass::GetAllSheets(CATDocument * pDftDoc, vector<CATIDftSheet*> &olstSheets)
{
	HRESULT rc = S_OK;

	if (pDftDoc == NULL)
	{
		return E_FAIL;
	}

	CATIDftDocumentServices *piDftDocServices = NULL;
	rc = pDftDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL)
	{
		return E_FAIL;
	}

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) 
	{
		return E_FAIL;
	}

	CATIUnknownList* pListOfSheet = NULL;
	rc = piDftDrawing->GetSheets(&pListOfSheet);
	if (FAILED(rc) || pListOfSheet == NULL)
	{
		return E_FAIL;
	}

	IUnknown* pItem = NULL;
	unsigned int nbSheet = 0;
	pListOfSheet->Count(&nbSheet);
	for(unsigned int i = 0;i < nbSheet;i++)
	{
		rc = pListOfSheet->Item(i,&pItem);
		if(SUCCEEDED(rc) && pItem != NULL)
		{
			CATIDftSheet * piDftSheet=NULL;
			rc = pItem->QueryInterface(IID_CATIDftSheet,(void**)&piDftSheet);
			if (SUCCEEDED(rc) && piDftSheet != NULL)
			{
				//CATBoolean bDetSheet=FALSE;
				//piDftSheet->IsDetail(&bDetSheet);
				//if (bDetSheet)
				//{
				//	opiDeatilSheet = piDftSheet;						
				//	break;
				//}
				olstSheets.push_back(piDftSheet);

				CATISheet *piSheet = NULL;
				rc = piDftSheet->QueryInterface(IID_CATISheet,(void**)&piSheet);
				if (SUCCEEDED(rc) && piSheet != NULL)
				{
					cout<<CATIAlias_var(piSheet)->GetAlias()<<endl;
				}
				//该处指针不能释放
				//piDftSheet->Release();
				//piDftSheet=NULL;
			}
		}
	}
	return rc;
}

//描述：获取所有View
//输入：CATUnicodeString图纸路径
//输出：CATLISTV(CATISpecObject_var) View列表
//返回：HRESULT
HRESULT GeneralClass::GetAllViews(CATUnicodeString istrPath, CATLISTV(CATISpecObject_var) &oListOfViews)
{
	HRESULT rc = S_OK;

	//文件是否存在
	if((_access(istrPath, 0)) == -1 )
	{
		CAAMessageBox(CAAUStringBuildFromChar("图纸文件不存在，请重新选择存储路径！"),"Error");
		return E_FAIL;
	}

	CATDocument * pDoc = NULL;
	rc=CATDocumentServices::OpenDocument(istrPath,pDoc);//打开二维图文档
	if (NULL == pDoc) return E_FAIL;


	CATIDftDocumentServices *piDftDocServices = NULL;
	rc = pDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL) return E_FAIL;

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) return E_FAIL;

	CATIUnknownList *pLstResult=NULL;
	rc=piDftDrawing->GetViews(&pLstResult);
	if(SUCCEEDED(rc) && pLstResult!=NULL)
	{
		unsigned int iNumberView=0;
		pLstResult->Count(&iNumberView);
		for(unsigned int i=0 ; i<iNumberView ; i++)
		{
			IUnknown * item = NULL;
			if( SUCCEEDED( pLstResult->Item(i, &item) ) )
			{
				if (item!=NULL)
				{
					CATIDftView *piThisView=NULL;
					rc=item->QueryInterface(IID_CATIDftView, (void**)&piThisView);
					if (SUCCEEDED(rc) && piThisView!=NULL)
					{
						CATIView* piCurrView=NULL;
						rc=piThisView->QueryInterface(IID_CATIView, (void**)&piCurrView);
						if (SUCCEEDED(rc) && piCurrView!=NULL)
						{
							oListOfViews.Append(CATISpecObject_var(piCurrView));

							piCurrView->Release();
							piCurrView=NULL;
						}
						piThisView->Release();
						piThisView=NULL;
					}
					item->Release();
					item=NULL;
				}
			}
		}
	}

	piDftDrawing->Release();
	piDftDrawing=NULL;

	return rc;
}

//描述：获取所有View
//输入：CATDocument图纸文档
//输出：CATLISTV(CATISpecObject_var) View列表
//返回：HRESULT
HRESULT GeneralClass::GetAllViews(CATDocument *ipDoc, CATLISTV(CATISpecObject_var) &oListOfViews)
{
	HRESULT rc = S_OK;

	if (ipDoc == NULL)
	{
		return E_FAIL;
	}

	CATIDftDocumentServices *piDftDocServices = NULL;
	rc = ipDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL) return E_FAIL;

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) return E_FAIL;

	CATIUnknownList *pLstResult=NULL;
	rc=piDftDrawing->GetViews(&pLstResult);
	if(SUCCEEDED(rc) && pLstResult!=NULL)
	{
		unsigned int iNumberView=0;
		pLstResult->Count(&iNumberView);
		for(unsigned int i=0 ; i<iNumberView ; i++)
		{
			IUnknown * item = NULL;
			if( SUCCEEDED( pLstResult->Item(i, &item) ) )
			{
				if (item!=NULL)
				{
					CATIDftView *piThisView=NULL;
					rc=item->QueryInterface(IID_CATIDftView, (void**)&piThisView);
					if (SUCCEEDED(rc) && piThisView!=NULL)
					{
						CATIView* piCurrView=NULL;
						rc=piThisView->QueryInterface(IID_CATIView, (void**)&piCurrView);
						if (SUCCEEDED(rc) && piCurrView!=NULL)
						{
							oListOfViews.Append(CATISpecObject_var(piCurrView));

							piCurrView->Release();
							piCurrView=NULL;
						}
						piThisView->Release();
						piThisView=NULL;
					}
					item->Release();
					item=NULL;
				}
			}
		}
	}

	piDftDrawing->Release();
	piDftDrawing=NULL;

	return rc;
}


//描述：获取图纸大小和具体的长宽
//输入：CATIDftSheet图纸页
//输出：CATUnicodeString图纸大小，double图纸具体长宽尺寸
//返回：HRESULT
HRESULT GeneralClass::GetSheetFormatAndSize(CATIDftSheet *ipiDftSheet, CATUnicodeString &ostrSheetFormat, double &odblWidth, double &odblHeight)
{
	HRESULT rc = S_OK;
	//判断图纸规格
	CATIDftSheetFormat *piDftSheetFormat = NULL;
	rc=ipiDftSheet->QueryInterface(IID_CATIDftSheetFormat,(void **)&piDftSheetFormat);
	if (FAILED(rc)||piDftSheetFormat==NULL)
	{
		cout<<"QI CATIDftSheetFormat Failed"<<endl;
		//_pYFDatumGeneralClass->WriteErrorLog(_strErrorPath,"QI CATIDftSheetFormat Failed");
		return E_FAIL;
	}

	CATIDftFormat *piDftFormat = NULL;
	rc=piDftSheetFormat->GetSheetFormat(IID_CATIDftFormat,(IUnknown **)&piDftFormat);
	if (FAILED(rc)||piDftFormat==NULL)
	{
		cout<<"QI CATIDftFormat Failed"<<endl;
		//_pYFDatumGeneralClass->WriteErrorLog(_strErrorPath,"QI CATIDftFormat Failed");
		return E_FAIL;
	}

	CATUnicodeString  strFormatName;
	piDftFormat->GetFormatName(strFormatName);
	//cout<<"Format Name:"<<strFormatName<<endl;

	ostrSheetFormat = strFormatName;

	double oFmtWidth = 0;
	double oFmtHeight = 0;

	rc = piDftFormat->GetFormatWidth(oFmtWidth);
	rc = piDftFormat->GetFormatHeight(oFmtHeight);
	piDftFormat->Release();
	piDftFormat=NULL;

	//cout<<"Format Width:"<<oFmtWidth<<endl;
	//cout<<"Format Height:"<<oFmtHeight<<endl;

	odblWidth = oFmtWidth;
	odblHeight = oFmtHeight;

	/*
	CATSheetOrientation oSheetOrient;
	CATBoolean oSheetDisplayMode;
	piDftSheetFormat->GetSheetOrientation(oSheetOrient);
	piDftSheetFormat->GetSheetDisplayMode(oSheetDisplayMode);

	piDftSheetFormat->Release();
	piDftSheetFormat=NULL;
	*/

	return rc;
}

//描述：获取图纸大小和具体的长宽
//输入：CATDocument图纸文档
//输出：CATUnicodeString图纸大小，double图纸具体长宽尺寸
//返回：HRESULT
HRESULT GeneralClass::GetSheetFormatAndSize(CATDocument *ipDoc, CATUnicodeString &ostrSheetFormat, double &odblWidth, double &odblHeight)
{
	HRESULT rc = S_OK;

	if (ipDoc == NULL)
	{
		return E_FAIL;
	}

	CATIDftDocumentServices *piDftDocServices = NULL;
	rc = ipDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL)
	{
		return E_FAIL;
	}

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) 
	{
		return E_FAIL;
	}

	CATIUnknownList* pListOfSheet = NULL;
	rc = piDftDrawing->GetSheets(&pListOfSheet);
	if (FAILED(rc) || pListOfSheet == NULL)
	{
		return E_FAIL;
	}

	IUnknown* pItem = NULL;
	unsigned int nbSheet = 0;
	pListOfSheet->Count(&nbSheet);

	rc = pListOfSheet->Item(0,&pItem);
	if (FAILED(rc) || pItem == NULL)
	{
		return E_FAIL;
	}

	CATIDftSheet * piDftSheet=NULL;
	rc = pItem->QueryInterface(IID_CATIDftSheet,(void**)&piDftSheet);
	if (FAILED(rc) || piDftSheet == NULL)
	{
		return E_FAIL;
	}

	//判断图纸规格
	CATIDftSheetFormat *piDftSheetFormat = NULL;
	rc=piDftSheet->QueryInterface(IID_CATIDftSheetFormat,(void **)&piDftSheetFormat);
	if (FAILED(rc)||piDftSheetFormat==NULL)
	{
		cout<<"QI CATIDftSheetFormat Failed"<<endl;
		//_pYFDatumGeneralClass->WriteErrorLog(_strErrorPath,"QI CATIDftSheetFormat Failed");
		return E_FAIL;
	}

	CATIDftFormat *piDftFormat = NULL;
	rc=piDftSheetFormat->GetSheetFormat(IID_CATIDftFormat,(IUnknown **)&piDftFormat);
	if (FAILED(rc)||piDftFormat==NULL)
	{
		cout<<"QI CATIDftFormat Failed"<<endl;
		//_pYFDatumGeneralClass->WriteErrorLog(_strErrorPath,"QI CATIDftFormat Failed");
		return E_FAIL;
	}

	CATUnicodeString  strFormatName;
	piDftFormat->GetFormatName(strFormatName);
	//cout<<"Format Name:"<<strFormatName<<endl;

	ostrSheetFormat = strFormatName;

	double oFmtWidth = 0;
	double oFmtHeight = 0;

	rc = piDftFormat->GetFormatWidth(oFmtWidth);
	rc = piDftFormat->GetFormatHeight(oFmtHeight);
	piDftFormat->Release();
	piDftFormat=NULL;

	//cout<<"Format Width:"<<oFmtWidth<<endl;
	//cout<<"Format Height:"<<oFmtHeight<<endl;

	odblWidth = oFmtWidth;
	odblHeight = oFmtHeight;

	/*
	CATSheetOrientation oSheetOrient;
	CATBoolean oSheetDisplayMode;
	piDftSheetFormat->GetSheetOrientation(oSheetOrient);
	piDftSheetFormat->GetSheetDisplayMode(oSheetDisplayMode);

	piDftSheetFormat->Release();
	piDftSheetFormat=NULL;
	*/

	return rc;
}

//描述：获取当前SHEET的背景图纸
//输入：CATDocument图纸文档
//输出：CATIView
//返回：CATBoolean
CATBoolean GeneralClass::GetBackgroundViewOfActiveSheet(CATDocument * pDoc,CATIView_var &ospView)
{
	//CATFrmEditor * pEditor;
	//pEditor = CATFrmEditor::GetCurrentEditor();
	//CATDocument * pDoc = NULL;
	//pDoc = pEditor ->GetDocument();
	if (NULL != pDoc)
	{
		CATIDftDocumentServices *piDftDocServices = NULL;
		HRESULT rc = pDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
		if (SUCCEEDED(rc) && piDftDocServices!=NULL)
		{
			CATIDftDrawing *piDftDrawing = NULL;
			rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
			piDftDocServices->Release();
			piDftDocServices=NULL;
			if (SUCCEEDED(rc) && piDftDrawing!=NULL)
			{
				CATIDftSheet* pDftSheet=NULL;
				rc=piDftDrawing->GetActiveSheet(&pDftSheet);              //获取当前激活图纸
				if (SUCCEEDED(rc) && pDftSheet!=NULL)
				{
					CATISheet * piSheet=NULL;
					rc=pDftSheet->QueryInterface(IID_CATISheet,(void**)&piSheet);
					if (SUCCEEDED(rc)&&NULL!=piSheet)
					{
						cout<<"Sheet : "<<CATIAlias_var(piSheet)->GetAlias()<<endl;

						CATLISTV(CATISpecObject_var) ViewList = piSheet->GetViewList();
						for (int i=1;i<=ViewList.Size();i++)
						{
							CATIView_var spView = ViewList[i];
							if (NULL_var != spView)
							{
								CATUnicodeString strViewName = CATIAlias_var(spView)->GetAlias();
								//cout<<i<<" "<<strViewName<<endl;
								if (strViewName.SearchSubString("Background")>=0)
								{
									ospView = spView;
								}
							}
						}

						pDftSheet->Release();
						pDftSheet = NULL;
					}
				}
			}
		}
	}

	return TRUE;
}

//描述：获取指定SHEET的背景图纸
//输入：CATIDftSheet
//输出：CATIView
//返回：CATBoolean
CATBoolean GeneralClass::GetBackgroundViewOfSheet(CATIDftSheet* ipDftSheet,CATIView_var &ospView)
{
	if (ipDftSheet==NULL) return FALSE;

	CATISheet * piSheet=NULL;
	HRESULT rc=ipDftSheet->QueryInterface(IID_CATISheet,(void**)&piSheet);
	if (SUCCEEDED(rc)&&NULL!=piSheet)
	{
		cout<<"Sheet : "<<CATIAlias_var(piSheet)->GetAlias()<<endl;

		CATLISTV(CATISpecObject_var) ViewList = piSheet->GetViewList();
		for (int i=1;i<=ViewList.Size();i++)
		{
			CATIView_var spView = ViewList[i];
			if (NULL_var != spView)
			{
				CATUnicodeString strViewName = CATIAlias_var(spView)->GetAlias();
				//cout<<i<<" "<<strViewName<<endl;
				if (strViewName.SearchSubString("Background")>=0)
				{
					ospView = spView;
					break;
				}
			}
		}
		piSheet->Release();
		piSheet = NULL;
	}

	return TRUE;
}

//描述：获取Detail Sheet
//输入：CATDocument文档
//输出：CATIDftSheet
//返回：CATIDftSheet
CATIDftSheet * GeneralClass::GetDetailSheet(CATDocument * pDftDoc)
{
	CATIDftSheet * opiDeatilSheet=NULL;
	if (pDftDoc == NULL) return opiDeatilSheet;

	CATIDftDocumentServices *piDftDocServices = NULL;
	HRESULT rc = pDftDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL) return opiDeatilSheet;

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) return opiDeatilSheet;

	CATIUnknownList* pListOfSheet = NULL;
	rc = piDftDrawing->GetSheets(&pListOfSheet);
	if (FAILED(rc) || pListOfSheet == NULL) return opiDeatilSheet;

	IUnknown* pItem = NULL;
	unsigned int nbSheet = 0;
	pListOfSheet->Count(&nbSheet);
	for(unsigned int i = 0;i < nbSheet;i++)
	{
		rc = pListOfSheet->Item(i,&pItem);
		if(SUCCEEDED(rc) && pItem != NULL)
		{
			CATIDftSheet * piDftSheet=NULL;
			rc = pItem->QueryInterface(IID_CATIDftSheet,(void**)&piDftSheet);
			if (SUCCEEDED(rc) && piDftSheet != NULL)
			{
				CATBoolean bDetSheet=FALSE;
				piDftSheet->IsDetail(&bDetSheet);
				if (bDetSheet)
				{
					opiDeatilSheet = piDftSheet;						
					break;
				}
				piDftSheet->Release();
				piDftSheet=NULL;
			}
		}
	}

	return opiDeatilSheet;
}

//描述：新建Detail Sheet
//输入：CATDocument文档
//输出：CATIDftSheet
//返回：HRESULT
HRESULT GeneralClass::CreateDetailSheet(CATDocument *ipDoc, CATUnicodeString istrSheetName, CATIDftSheet *&opiDetailSheet)
{
	HRESULT rc = S_OK;
	//
	if (ipDoc == NULL)
	{
		return E_FAIL;
	}

	CATIDftDocumentServices *piDftDocServices = NULL;
	rc = ipDoc->QueryInterface(IID_CATIDftDocumentServices, (void **)&piDftDocServices);
	if (FAILED(rc) || piDftDocServices==NULL)
	{
		return E_FAIL;
	}

	CATIDftDrawing *piDftDrawing = NULL;
	rc=piDftDocServices->GetDrawing(IID_CATIDftDrawing, (void **)&piDftDrawing);      
	piDftDocServices->Release();
	piDftDocServices=NULL;
	if (FAILED(rc) || piDftDrawing==NULL) 
	{
		return E_FAIL;
	}
	//
	CATIDftSheet *piDftNewSheet = NULL;
	wchar_t pSheetName;
	CAAUStringConvertToWChar(istrSheetName,&pSheetName);
	rc = piDftDrawing->AddSheet(&piDftNewSheet,&pSheetName);
	if (FAILED(rc) || piDftNewSheet == NULL)
	{
		return E_FAIL;
	}
	rc = piDftNewSheet->SetAsDetail();
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	//
	opiDetailSheet = piDftNewSheet;

	return rc;
}

//描述：创建View
//输入：CATIDftSheet视图
//输出：CATIView
//返回：CATIView
CATIView_var GeneralClass::CreateView(CATIDftSheet *ipiDftSheet)
{
	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateViewWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	CATISpecObject_var spViewSpec = piViewMU;
	if(spViewSpec==NULL_var) {
		cout<<"Failed to GetSpecView."<<endl;
		return NULL_var;
	}

	//piView->SetViewType(DetailView);
	ipiDftSheet->AddView(piViewMU);
	CATIDftView *opDftView = NULL;
	rc = piView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;
	return piView;
}

//描述：创建Detail View
//输入：CATIDftSheet, CATIView所属视图，double* 详图圆圈区域位置，double 详图圆圈半径，double 详图比例，double* 详图位置，CATUnicodeString 详图名称前缀，CATUnicodeString 详图名称ID，CATUnicodeString 详图名称后缀
//输出：CATIView
//返回：CATIView
CATIView_var GeneralClass::CreateDetailView(CATIDftSheet *ipiDftSheet, 
											CATIView_var ispiMotherView, 
											double *idCirclePos, 
											double idblRadius, 
											double idblScale,
											double *idViewPos,
											CATUnicodeString istrViewPrefix, 
											CATUnicodeString istrViewID, 
											CATUnicodeString istrViewSuffix)
{
	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateViewWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	CATISpecObject_var spViewSpec = piViewMU;
	if(spViewSpec==NULL_var) {
		cout<<"Failed to GetSpecView."<<endl;
		return NULL_var;
	}

	piView->SetViewType(DetailView);
	ipiDftSheet->AddView(piViewMU);
	//
	CATIDftView *opDftView = NULL;
	rc = ispiMotherView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	//wchar_t *wcharViewName = L"Detail AAA";
	//opDftView->SetViewName(wcharViewName);
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;

	//
	CATIADrawingView_var spiaDrwViewMother = ispiMotherView;
	if (spiaDrwViewMother == NULL_var)
	{
		cout<<"CATIADrawingView is NULL_var"<<endl;
		return NULL_var;
	}

	CATIAGenerativeViewBehavior* oPiGenerativeBehaviorMother=NULL;
	rc=spiaDrwViewMother->get_GenerativeBehavior(oPiGenerativeBehaviorMother);
	if (FAILED(rc) || oPiGenerativeBehaviorMother == NULL)
	{
		cout<<"Get CATIAGenerativeViewBehavior Failed!"<<endl;
		return NULL_var;
	}
	//
	CATIADrawingView_var spiaDrwView = piView;
	if (spiaDrwView == NULL_var)
	{
		cout<<"CATIADrawingView is NULL_var"<<endl;
		return NULL_var;
	}

	CATIAGenerativeViewBehavior* oPiGenerativeBehavior=NULL;
	rc=spiaDrwView->get_GenerativeBehavior(oPiGenerativeBehavior);
	if (FAILED(rc) || oPiGenerativeBehavior == NULL)
	{
		cout<<"Get CATIAGenerativeViewBehavior Failed!"<<endl;
		return NULL_var;
	}
	//
	rc = oPiGenerativeBehavior->DefineCircularDetailView(idCirclePos[0],idCirclePos[1],idblRadius,oPiGenerativeBehaviorMother);
	if (FAILED(rc))
	{
		return NULL_var;
	}
	CATIAGenerativeViewLinks *piaGenViewLinksMother = NULL;
	CATIAGenerativeViewLinks *piaGenViewLinks = NULL;
	rc = spiaDrwViewMother->get_GenerativeLinks(piaGenViewLinksMother);
	if (FAILED(rc) || piaGenViewLinksMother == NULL)
	{
		return NULL_var;
	}
	rc = spiaDrwView->get_GenerativeLinks(piaGenViewLinks);
	if (FAILED(rc) || piaGenViewLinks == NULL)
	{
		return NULL_var;
	}
	rc = piaGenViewLinksMother->CopyLinksTo(piaGenViewLinks);

	spiaDrwView->put_x(idViewPos[0]);
	spiaDrwView->put_y(idViewPos[1]);
	spiaDrwView->put_Scale(idblScale);

	CATBSTR bstrViewPrefix = NULL;
	istrViewPrefix.ConvertToBSTR(&bstrViewPrefix);
	CATBSTR bstrViewID = NULL;
	istrViewID.ConvertToBSTR(&bstrViewID);
	CATBSTR bstrViewSuffix = NULL;
	istrViewSuffix.ConvertToBSTR(&bstrViewSuffix);
	spiaDrwView->SetViewName(bstrViewPrefix,bstrViewID,bstrViewSuffix);

	//
	oPiGenerativeBehavior->Update();

	CATIView_var spiView = piView;

	return spiView;
}

//描述：创建ISO View
//输入：CATIDftSheet, CATIView所属视图，double* 详图圆圈区域位置，double 详图圆圈半径，double 详图比例，double* 详图位置，CATUnicodeString 详图名称前缀，CATUnicodeString 详图名称ID，CATUnicodeString 详图名称后缀
//输出：CATIView
//返回：CATIView
CATIView_var GeneralClass::CreateISOView(CATIDftSheet *ipiDftSheet, 
											CATIProduct_var ispiProduct)
{
	if (ipiDftSheet == NULL || ispiProduct == NULL_var)
	{
		return NULL_var;
	}
	CATILinkableObject_var spiLinkObj = ispiProduct;
	//HRESULT rc = ispiProduct->QueryInterface(IID_CATILinkableObject,(void**)piLinkObj);
	if (spiLinkObj== NULL_var)
	{
		return NULL_var;
	}
	
	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateViewWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	//设置视图类型和链接
	piView->SetViewType(IsomView);
	piView->SetDoc(spiLinkObj);


	//设置投影面
	CATMathPoint mathPoint1(1,0,0);
	CATMathPoint mathPoint2(0,1,0);
	CATMathPoint mathPoint3(0,0,1);
	CATMathPlane mathProPlane(mathPoint1,mathPoint2,mathPoint3);
	CATIGenerSpec_var spiGenerSpec = piView->GetGenerSpec();
	if (spiGenerSpec == NULL_var)
	{
		return NULL_var;
	}
	spiGenerSpec->SetProjPlane(mathProPlane);

	//把View加入Sheet中
	ipiDftSheet->AddView(piViewMU);

	//设置View放置位置以及比例等
	piViewMU->SetAxisData(0,0);
	piViewMU->SetScale(1);
	piViewMU->SetFrameVisibility(FALSE);
	//
	CATIDftView *opDftView = NULL;
	rc = piView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	//wchar_t *wcharViewName = L"Detail AAA";
	//opDftView->SetViewName(wcharViewName);
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;

	CATIView_var spiView = piView;
	CATISpecObject_var(spiView)->Update();

	return spiView;
}

//描述：创建ISO View
//输入：CATIDftSheet, CATIView所属视图，double* 详图圆圈区域位置，double 详图圆圈半径，double 详图比例，double* 详图位置，CATUnicodeString 详图名称前缀，CATUnicodeString 详图名称ID，CATUnicodeString 详图名称后缀
//输出：CATIView
//返回：CATIView
CATIView_var GeneralClass::CreateISOView(CATIDftSheet *ipiDftSheet, 
										 CATIProduct_var ispiProduct,
										 CATMathPlane imathPlaneProject)
{
	if (ipiDftSheet == NULL || ispiProduct == NULL_var)
	{
		return NULL_var;
	}
	CATILinkableObject_var spiLinkObj = ispiProduct;
	//HRESULT rc = ispiProduct->QueryInterface(IID_CATILinkableObject,(void**)piLinkObj);
	if (spiLinkObj== NULL_var)
	{
		return NULL_var;
	}

	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateViewWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	//设置视图类型和链接
	piView->SetViewType(IsomView);
	piView->SetDoc(spiLinkObj);


	//设置投影面
	//CATMathPoint mathPoint1(1,0,0);
	//CATMathPoint mathPoint2(0,1,0);
	//CATMathPoint mathPoint3(0,0,1);
	//CATMathPlane mathProPlane(mathPoint1,mathPoint2,mathPoint3);
	CATMathPlane mathProPlane = imathPlaneProject;
	CATIGenerSpec_var spiGenerSpec = piView->GetGenerSpec();
	if (spiGenerSpec == NULL_var)
	{
		return NULL_var;
	}
	spiGenerSpec->SetProjPlane(mathProPlane);

	//把View加入Sheet中
	ipiDftSheet->AddView(piViewMU);

	//设置View放置位置以及比例等
	piViewMU->SetAxisData(0,0);
	piViewMU->SetScale(1);
	piViewMU->SetFrameVisibility(FALSE);
	//
	CATIDftView *opDftView = NULL;
	rc = piView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	//wchar_t *wcharViewName = L"Detail AAA";
	//opDftView->SetViewName(wcharViewName);
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;

	CATIView_var spiView = piView;
	CATISpecObject_var(spiView)->Update();

	return spiView;
}

CATIView_var GeneralClass::CreateISOView(CATIDftSheet *ipiDftSheet, 
										 CATLISTP(CATIProduct) ilstProd,
										 CATMathPlane imathPlaneProject)
{
	if (ipiDftSheet == NULL || ilstProd.Size() == 0)
	{
		return NULL_var;
	}
	//CATILinkableObject_var spiLinkObj = ispiProduct;
	////HRESULT rc = ispiProduct->QueryInterface(IID_CATILinkableObject,(void**)piLinkObj);
	//if (spiLinkObj== NULL_var)
	//{
	//	return NULL_var;
	//}

	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateViewWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	//设置视图类型和链接
	piView->SetViewType(IsomView);
	for (int i=1; i <= ilstProd.Size(); i++)
	{
		CATILinkableObject_var spiLinkObj = ilstProd[i];
		//HRESULT rc = ispiProduct->QueryInterface(IID_CATILinkableObject,(void**)piLinkObj);
		if (spiLinkObj== NULL_var)
		{
			continue;;
		}
		piView->SetDoc(spiLinkObj);
	}

	//设置投影面
	//CATMathPoint mathPoint1(1,0,0);
	//CATMathPoint mathPoint2(0,1,0);
	//CATMathPoint mathPoint3(0,0,1);
	//CATMathPlane mathProPlane(mathPoint1,mathPoint2,mathPoint3);
	CATMathPlane mathProPlane = imathPlaneProject;
	CATIGenerSpec_var spiGenerSpec = piView->GetGenerSpec();
	if (spiGenerSpec == NULL_var)
	{
		return NULL_var;
	}
	spiGenerSpec->SetProjPlane(mathProPlane);

	//把View加入Sheet中
	ipiDftSheet->AddView(piViewMU);

	//设置View放置位置以及比例等
	piViewMU->SetAxisData(0,0);
	piViewMU->SetScale(1);
	piViewMU->SetFrameVisibility(FALSE);
	//
	CATIDftView *opDftView = NULL;
	rc = piView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	//wchar_t *wcharViewName = L"Detail AAA";
	//opDftView->SetViewName(wcharViewName);
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;

	CATIView_var spiView = piView;
	CATISpecObject_var(spiView)->Update();

	return spiView;
}

//描述：在指定Detail Sheet中创建DetailView
//输入：CATIDftSheet视图
//输出：CATIView
//返回：CATIView
CATIView_var GeneralClass::CreateViewInDetailSheet(CATIDftSheet *ipiDftSheet)
{
	CATIDftDrawing *pDftDrawing = NULL;
	HRESULT rc = ipiDftSheet->GetDrawing(&pDftDrawing);
	if(FAILED(rc) || pDftDrawing==NULL)
	{
		cout<<"# Failed to GetDrawing."<<endl;
		return NULL_var;
	}
	CATISpecObject *piSpecObj=NULL;
	rc=pDftDrawing->QueryInterface(IID_CATISpecObject,(void **)&piSpecObj);
	if (FAILED(rc) || piSpecObj == NULL)
	{
		cout<<"# Get Drafting Drawing Error"<<endl;
		return NULL_var;
	}
	CATIContainer_var spDrwCont=piSpecObj->GetFeatContainer();
	piSpecObj->Release();
	piSpecObj=NULL;
	if (spDrwCont==NULL_var)
	{
		cout<<"# Get Container failed"<<endl;
		return NULL_var;
	}

	CATIDrwFactory_var spDrwFact=spDrwCont;
	if (spDrwFact==NULL_var)
	{
		cout<<"get the spDrwCont failed!"<<endl;
		return NULL_var;
	}

	CATIDftViewMakeUp *piViewMU=NULL;
	rc=spDrwFact->CreateDetailWithMakeUp(IID_CATIDftViewMakeUp,(void **)&piViewMU);
	if (FAILED(rc)||piViewMU==NULL)
	{
		cout<<"create view with make up error!"<<endl;
		piViewMU->Release();piViewMU=NULL;
		ipiDftSheet->Release();ipiDftSheet=NULL;
		return NULL_var;
	}

	CATIView *piView=NULL;
	rc=piViewMU->GetView(&piView);
	if (FAILED(rc)||piView==NULL)
	{
		cout<<"get view failed!"<<endl;
		return NULL_var;
	}

	CATISpecObject_var spViewSpec = piViewMU;
	if(spViewSpec==NULL_var) {
		cout<<"Failed to GetSpecView."<<endl;
		return NULL_var;
	}

	//piView->SetViewType(DetailView);
	ipiDftSheet->AddView(piViewMU,FALSE);
	CATIDftView *opDftView = NULL;
	rc = piView->QueryInterface(IID_CATIDftView,(void **)&opDftView);
	if(FAILED(rc) || opDftView == NULL)
	{
		cout<<"Failed to QI to CATIDftView."<<endl;
		return NULL_var;
	}
	ipiDftSheet->SetDefaultActiveView(opDftView);
	opDftView->Release();
	opDftView=NULL;
	return piView;
}

//描述：删除Detail Sheet中的指定名称的View
//输入：CATIDftSheet，CATUnicodeString视图名称
//输出：
//返回：CATBoolean
CATBoolean GeneralClass::RemoveDetailView(CATIDftSheet * piDetailSheet,CATUnicodeString strViewName)
{
	cout<<"RemoveDetailView"<<endl;

	if (piDetailSheet==NULL)
		return FALSE;

	HRESULT rc=E_FAIL;

	CATISheet *opSheet = NULL;
	rc = piDetailSheet->QueryInterface(IID_CATISheet,(void **)&opSheet);
	if(FAILED(rc) || opSheet == NULL)
	{
		cout<<"CATISheet is null"<<endl;
		return FALSE;
	}

	CATISpecObject * piSpecOnActiveSheet = NULL;
	rc = opSheet->QueryInterface(IID_CATISpecObject,(void**)&piSpecOnActiveSheet);
	if(FAILED(rc) || piSpecOnActiveSheet == NULL)
	{
		cout<<"CATISpecObject is null"<<endl;
		return FALSE;
	}

	CATLISTV(CATISpecObject_var) LstView=opSheet->GetViewList( );

	CATUnicodeString strOldName=strViewName;
	strOldName.ReplaceAll("_","");

	for (int i=1;i<=LstView.Size();i++)
	{
		CATIAlias_var spAliasOnView = LstView[i];
		if (NULL_var == spAliasOnView)
			continue;

		CATUnicodeString strName=spAliasOnView->GetAlias();

		if (strName.SearchSubString(strViewName)!=-1||
			strOldName==strName)
		{
			piSpecOnActiveSheet->Remove(LstView[i]);
		}

	}

	LstView.RemoveAll();
	LstView=opSheet->GetViewList( );

	return TRUE;
}

//描述：插入符号(实例化部件)
//输入：CATIView视图，CATMathPoint2D点，CATBaseUnknown 2DDetail，double比例
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::InsertSymbol(CATIView_var ispiView,
									 CATUnicodeString strSymbolName,
									 CATMathPoint2D iPickingPt,
									 CATBaseUnknown* oExternalObject,
									 double iScale)
{
	HRESULT rc=S_OK;

	if (NULL == oExternalObject) return E_FAIL;

	CATI2DDetail *pi2DDetail=NULL;
	rc=oExternalObject->QueryInterface(IID_CATI2DDetail,(void**)&pi2DDetail);
	if(FAILED(rc)||pi2DDetail==NULL)
	{
		cout<<"# Get CATI2DDetail Error!"<<endl;
		return rc;
	}
	CATI2DWFFactory *pi2DWFFact=NULL;
	rc = ispiView->QueryInterface(IID_CATI2DWFFactory,(void**)&pi2DWFFact);
	if(FAILED(rc)||pi2DWFFact==NULL)
	{
		cout<<"# Get CATI2DWFFactory Error!"<<endl;
		return rc;
	}

	//创建2D符号
	CATISpecObject *piObj=NULL;
	rc=pi2DWFFact->InstanciateDitto(pi2DDetail,IID_CATISpecObject,(IUnknown**)&piObj);
	if(SUCCEEDED(rc)&&piObj!=NULL)
	{
		CATIAlias_var spAlias=piObj;
		spAlias->SetAlias(strSymbolName);

		CATIMove2D *pMove=NULL;
		rc=piObj->QueryInterface(IID_CATIMove2D,(void **)&pMove);
		if(SUCCEEDED(rc)&&pMove!=NULL)
		{
			//缩放
			CATMathTransformation2D iTrans2D;
			iTrans2D=CATMathTransformation2D(CATMath2x2Matrix(iScale,CATMathScaling),CATMathVector2D(0.0,0.0));
			pMove->Move(iTrans2D);
			//平移
			iTrans2D=CATMathTransformation2D(CATMathVector2D(iPickingPt.GetX(),iPickingPt.GetY()));
			pMove->Move(iTrans2D);
			pMove->Release();
			pMove=NULL;
		}
	}


	return S_OK;
}

//描述：插入KCDS符号-----含有可编辑的text框
//输入：CATIView视图，CATMathPoint2D点，CATBaseUnknown 2DDetail，CATListOfCATUnicodeString输入内容,double比例
//输出：HRESULT
//返回：HRESULT
HRESULT GeneralClass::InsertKCDSSymbol(CATIView_var ispiView,
										 CATMathPoint2D iPickingPt,
										 CATBaseUnknown* oExternalObject,
										 CATListOfCATUnicodeString iListOfText,
										 CATUnicodeString strSymbolName,
										 double iScale)
{
	HRESULT rc=S_OK;

	if (NULL == oExternalObject) return E_FAIL;

	CATI2DDetail *pi2DDetail=NULL;
	rc=oExternalObject->QueryInterface(IID_CATI2DDetail,(void**)&pi2DDetail);
	if(FAILED(rc)||pi2DDetail==NULL)
	{
		cout<<"# Get CATI2DDetail Error!"<<endl;
		return rc;
	}
	CATI2DWFFactory *pi2DWFFact=NULL;
	rc = ispiView->QueryInterface(IID_CATI2DWFFactory,(void**)&pi2DWFFact);
	if(FAILED(rc)||pi2DWFFact==NULL)
	{
		cout<<"# Get CATI2DWFFactory Error!"<<endl;
		return rc;
	}

	//创建2D符号
	CATISpecObject *piObj=NULL;
	rc=pi2DWFFact->InstanciateDitto(pi2DDetail,IID_CATISpecObject,(IUnknown**)&piObj);
	if(SUCCEEDED(rc)&&piObj!=NULL)
	{
		CATIAlias_var spAlias=piObj;
		spAlias->SetAlias(strSymbolName);

		CATIMove2D *pMove=NULL;
		rc=piObj->QueryInterface(IID_CATIMove2D,(void **)&pMove);
		if(SUCCEEDED(rc)&&pMove!=NULL)
		{
			//缩放
			CATMathTransformation2D iTrans2D;
			iTrans2D=CATMathTransformation2D(CATMath2x2Matrix(iScale,CATMathScaling),CATMathVector2D(0.0,0.0));
			pMove->Move(iTrans2D);
			//平移
			iTrans2D=CATMathTransformation2D(CATMathVector2D(iPickingPt.GetX(),iPickingPt.GetY()));
			pMove->Move(iTrans2D);
			pMove->Release();
			pMove=NULL;
		}

		CATIADrawingComponent * piMyDrawComp = NULL;
		rc = piObj -> QueryInterface (IID_CATIADrawingComponent,(void**)&piMyDrawComp);
		if ( SUCCEEDED(rc) )
		{
			long Count = 0;
			int iCountOfText=0;
			piMyDrawComp -> GetModifiableObjectsCount (Count);
			for ( int Idx = 1; Idx<=Count; Idx++ )
			{
				//cout<<"  ---"<<Idx<<endl;
				CATVariant Variant;
				rc = BuildVariant ((long)Idx, Variant);
				if ( SUCCEEDED(rc) )
				{
					CATIABase * piABase = NULL;
					rc = piMyDrawComp -> GetModifiableObject (Variant, piABase);
					if ( SUCCEEDED(rc) )
					{
						CATIDftText * piDftText=NULL;
						rc = piABase->QueryInterface(IID_CATIDftText,(void **)&piDftText);
						if (SUCCEEDED(rc) && piDftText != NULL)
						{
							iCountOfText++;
							if (iListOfText.Size()>=iCountOfText)
							{
								//cout<<"  ---SetString"<<endl;
								wchar_t* pTxtChar = new wchar_t[iListOfText[iCountOfText].GetLengthInChar()+1];
								iListOfText[iCountOfText].ConvertToWChar(pTxtChar);
								piDftText->SetString(pTxtChar);
								delete [] pTxtChar;pTxtChar = NULL; 
							}

						}
					}
				}
			}
		}
	}


	return S_OK;
}

//描述：获取指定名称的Component所在的Sheet页
//输入：CATDocument图纸文档，CATUnicodeString实例化表格名称
//输出：
//返回：CATIDftSheet
CATIDftSheet* GeneralClass::GetSheetFromComponentName(CATDocument *ipDoc, CATUnicodeString istrAlias)
{
	CATIDftSheet *opiDftSheet = NULL;
	//先获取所有sheet
	vector<CATIDftSheet*> lstSheets;
	HRESULT rc = GetAllSheets(ipDoc,lstSheets);
	if (lstSheets.size() == 0)
	{
		return NULL;
	}
	//获取每个sheet页中BackgroundView
	for (int i=0; i < lstSheets.size(); i++)
	{
		CATIView_var spiViewBackground = NULL_var;
		CATBoolean bBackgroundView = GetBackgroundViewOfSheet(lstSheets[i],spiViewBackground);
		if (bBackgroundView == FALSE || spiViewBackground == NULL_var)
		{
			continue;
		}
		//在背景视图中获取所有的component
		CATIADrawingView_var spiaView = spiViewBackground;
		if (spiaView == NULL_var)
		{
			continue;
		}
		CATIADrawingComponents *pComps = NULL;
		rc = spiaView->get_Components(pComps);
		if (FAILED(rc) || pComps == NULL)
		{
			continue;
		}
		CATLONG lNums=0;
		pComps->get_Count(lNums);
		for (int j=1; j <= lNums; j++)
		{
			CATVariant variant;
			rc = BuildVariant((long)j, variant);
			if (SUCCEEDED(rc))
			{
				CATIADrawingComponent * pComp=NULL;
				pComps->Item(variant,pComp);
				if (pComp != NULL)
				{
					CATISpecObject_var spiSpecObj = pComp;
					if (spiSpecObj != NULL_var)
					{
						CATIAlias_var spiAlias = spiSpecObj;
						CATUnicodeString strAlias = spiAlias->GetAlias();
						if (strAlias == istrAlias)
						{
							opiDftSheet = lstSheets[i];
							break;
						}
					}
				}
			}
		}
	}
	return opiDftSheet;
}

//描述：获取指定名称的Ditto所在的Sheet页，并返回Ditto的Axis位置
//输入：CATDocument图纸文档，CATUnicodeString实例化表格名称
//输出：CATIDftSheet图纸页，CATI2DDitto实例化对象，double实例化对象的坐标位置
//返回：HRESULT
HRESULT GeneralClass::GetSheetFromDittoName(CATDocument *ipDoc, CATUnicodeString istrAlias, CATIDftSheet *&opiDftSheet, CATI2DDitto *&opiDitto,double oarrPos[2])
{
	HRESULT rc = S_OK;
	//先获取所有sheet
	vector<CATIDftSheet*> lstSheets;
	rc = GetAllSheets(ipDoc,lstSheets);
	if (lstSheets.size() == 0)
	{
		return E_FAIL;
	}
	//获取每个sheet页中BackgroundView
	for (int i=0; i < lstSheets.size(); i++)
	{
		CATIView_var spiViewBackground = NULL_var;
		CATBoolean bBackgroundView = GetBackgroundViewOfSheet(lstSheets[i],spiViewBackground);
		if (bBackgroundView == FALSE || spiViewBackground == NULL_var)
		{
			continue;
		}
		//在背景视图中获取所有的Ditto
		CATIDescendants_var spiDesc = spiViewBackground;
		if (spiDesc == NULL_var)
		{
			continue;
		}
		//CATIDrwDressUp_var spiDrwDressUp = spiViewBackground->GetDressUp();
		//if (spiDrwDressUp == NULL_var)
		//{
		//	continue;
		//}
		CATLISTV(CATISpecObject_var) lstSpecOnDitto = NULL;
		//rc = spiDrwDressUp->GetComponents(IID_CATI2DDitto,lstSpecOnDitto);
		//if (FAILED(rc) || lstSpecOnDitto == NULL)
		//{
		//	continue;
		//}
		spiDesc->GetAllChildren("CATI2DDitto",lstSpecOnDitto);
		if (lstSpecOnDitto.Size() == 0)
		{
			continue;
		}
		for (int j=1; j <= lstSpecOnDitto.Size(); j++)
		{
			CATIAlias_var spiAlias = lstSpecOnDitto[j];
			CATUnicodeString strAlias = spiAlias->GetAlias();
			if (strAlias == istrAlias)
			{
				opiDftSheet = lstSheets[i];
				CATI2DDitto *piDitto = NULL;
				rc = lstSpecOnDitto[j]->QueryInterface(IID_CATI2DDitto,(void**)&piDitto);
				if (SUCCEEDED(rc) && piDitto != NULL)
				{
					opiDitto = piDitto;
					double arrPos[6];
					piDitto->Get2DAxisMatrix(arrPos);	//取最后两位数字作为坐标系位置
					oarrPos[0]=arrPos[4];
					oarrPos[1]=arrPos[5];
				}
				break;
			}
		}
	}
	return rc;
}

//描述：根据输入的表格实例化部件，返回表格在详图页视图中的位置
//输入：CATI2DDitto图纸实例化部件
//输出：double表格左上角位置
//返回：HRESULT
HRESULT GeneralClass::GetTablePosInView(CATI2DDitto *ipiDittoTable, double oarrPos[2])
{
	HRESULT rc = S_OK;
	IUnknown *piUnknown = NULL;
	rc = ipiDittoTable->GetDetail(IID_CATIView,&piUnknown);	//获得Ditto的参考视图
	if (FAILED(rc) && piUnknown == NULL)
	{
		return E_FAIL;
	}
	CATIView_var spiView = NULL_var;
	rc = piUnknown->QueryInterface(IID_CATIView,(void**)&spiView);
	if (FAILED(rc) || spiView == NULL_var)
	{
		return E_FAIL;
	}
	CATIADrawingView_var spDrwView= spiView;
	if(spDrwView == NULL_var) 
	{
		cout<<"Failed to Get CATIADrawingView."<<endl;
		return E_FAIL;
	}

	CATIADrawingTables *opDrwTables=NULL;
	rc = spDrwView->get_Tables(opDrwTables);
	if(FAILED(rc))
	{
		cout<<"Failed to get CATIADrawingTables."<<endl;
		return E_FAIL;
	}
	CATIADrawingTable *piaDrwTable = NULL;
	opDrwTables->Item(1,piaDrwTable);
	if (piaDrwTable == NULL)
	{
		return E_FAIL;
	}
	double dblX, dblY;
	piaDrwTable->get_x(dblX);
	piaDrwTable->get_y(dblY);

	//
	oarrPos[0] = dblX;
	oarrPos[1] = dblY;

	return rc;
}

//描述：获取字符串中的英文字符
//输入： CATUnicodeString字符串
//输出：CATListOfCATUnicodeString英文字符集合
//返回：CATBoolean
void GeneralClass::SeparateEnZhString(CATUnicodeString istrString,CATListOfCATUnicodeString &oListOfENString,CATListOfCATUnicodeString &oListOfZhString)
{
	if (istrString.GetLengthInChar() == 0 ) return ;

	//const char * generalnotes;
	//generalnotes = istrString.ConvertToChar();

	//wchar_t generalnotes[10000] ;
	//CAAUStringConvertToWChar(istrString,generalnotes);
	//string s;
	//Wchar_tToString(s,generalnotes);

	char generalnotes[10000] ;
	CAAUStringConvertToChar(istrString,generalnotes);
	string s(generalnotes);

	std::vector<string> vect;
	std::vector<string> vectch;
	string eng;
	string ch;
	for(int i=0; i<s.length(); i++)
	{
		int lcode = s[i];
		if((lcode<255 && lcode>0))//扩充的ASCII字符范围为0-255,如是,处理一个字节
		{
			ch="";
			eng.append(s.substr(i,1));
			if( ((i+1<s.length()) &&  (s[i+1]<=0)) || (i+1 == s.length()))
			{
				vect.push_back(eng);
			}
		}
		else//<0,>255的是汉字,处理两个字节
		{
			eng="";
			ch.append(s.substr(i,2));
			if( ((i+2<s.length()) &&  (s[i+2]<255 && s[i+2]>0))|| (i+2 == s.length()))
			{
				vectch.push_back(ch);
			}
			i = i + 1;
		}
	}

	for (int i=0;i<vect.size();i++)
	{
		string sss=vect[i];
		const char *c_s = sss.c_str();
		CATUnicodeString strString(c_s); 
		oListOfENString.Append(strString);
	}

	for (int i=0;i<vectch.size();i++)
	{
		string sss=vectch[i];
		const char *c_s = sss.c_str(); 
		char strchar1[10000] ;
		strcpy(strchar1,c_s);
		CATUnicodeString strString = CAAUStringBuildFromChar(strchar1); 
		oListOfZhString.Append(strString);
	}

	return ;
}

// wchar_t to string
void GeneralClass::Wchar_tToString(string& szDst, wchar_t *wchar)
{
	wchar_t * wText = wchar;
	DWORD dwNum = WideCharToMultiByte(CP_OEMCP,NULL,wText,-1,NULL,0,NULL,FALSE);// 
	char *psText; //
	psText = new char[dwNum];
	WideCharToMultiByte (CP_OEMCP,NULL,wText,-1,psText,dwNum,NULL,FALSE);//
	szDst = psText;// 
	delete []psText;//
}

////描述：写入错误信息
////输入：CATUnicodeString
////输出：void
////返回：void
//CATBoolean GeneralClass::WriteTestTxt(CATUnicodeString strPath,CATUnicodeString strContent)
//{
//	ofstream errorfile(strPath.ConvertToChar(),ios::app);
//	char strchar[1000];
//	CAAUStringConvertToChar(strContent,strchar);
//	errorfile<<strchar<<"\n";
//	errorfile.close();
//	return TRUE;
//}


//描述：创建零件信息表格
//输入：CATIView 视图，double放置位置x坐标，double放置位置y坐标，int行数，int列数，CATUnicodeString表格名称，vector<CATListOfCATUnicodeString>表格内容
//输出：CATIADrawingTable生成的表格
//返回：CATBoolean
CATBoolean GeneralClass::CreatePartInfoTable(CATIView_var ispiCurrentView,
											double iPositionX, 
											double iPositionY,
											int iRow,
											int iCol,
											CATUnicodeString istrTableName,
											vector<CATListOfCATUnicodeString> iListOfCellString,
											CATIADrawingTable *&opiaDrwTable)
{
	//cout<<"CteateTabel begin."<<endl;

	HRESULT rc = S_OK;

	//double Point[2] = {0,0};

	CATIAlias_var spAlias=NULL_var;

	CATIADrawingView_var spDrwView= ispiCurrentView;
	if(spDrwView == NULL_var) 
	{
		cout<<"Failed to Get CATIADrawingView."<<endl;
		return FALSE;
	}

	CATIADrawingTables *opDrwTables=NULL;
	rc = spDrwView->get_Tables(opDrwTables);
	if(FAILED(rc))
	{
		cout<<"Failed to get CATIADrawingTables."<<endl;
		return FALSE;
	}

	CATIADrawingTable *opNewDrwTable=NULL;
	rc = opDrwTables->Add(iPositionX,iPositionY,iRow,iCol,1.,30.,opNewDrwTable);

	//opNewDrwTable->SetColumnSize(3, 90);
	//opNewDrwTable->SetColumnSize(1, 25);
	//opNewDrwTable->SetColumnSize(4, 35);

	spAlias=opNewDrwTable;
	spAlias->SetAlias(istrTableName);

	//CATIDrwTextProperties *pTextProp = NULL;
	//rc  = opNewDrwTable->QueryInterface(IID_CATIDrwTextProperties,(void**)&pTextProp);
	//if(SUCCEEDED(rc)&&pTextProp!=NULL) 
	//{
	//	//rc=pTextProp->SetScaleMode(CATDrwScaleLinkedToView);

	//}

	//设置信息
	CATBSTR ioString;
	for(int i=1;i<=iRow;i++)
	{	
		CATListOfCATUnicodeString lstOneRowContents = iListOfCellString[i-1];
		for (int j=1;j<=iCol;j++)
		{
			//int num=numofrow*iCol-(iCol-j);

			//if (num>iListOfCellString.Size())
			//	continue;

			CATUnicodeString strCellString=lstOneRowContents[j];

			//strCellString.ToUpper();

			//if (strCellString.SearchSubString("_TOREMOVE")!=-1)
			//{
			//	strCellString="SUB DATUM";
			//}

			strCellString.ConvertToBSTR(&ioString);

			rc = opNewDrwTable->SetCellString(i,j,ioString);
			rc = opNewDrwTable->SetCellAlignment(i,j,CatTableMiddleCenter);

			//设置字体
			CATIADrawingText  *opText = NULL;
			rc = opNewDrwTable->GetCellObject(i, j,opText);
			if(opText == NULL) 
			{
				cout<<"failed to get opText."<<endl;
				continue;
			}
			ChangeFontType(opText,strCellString);

			/*
			//设置字体
			if (i==iRow)
			{
				//标题
				//ChangeFontType(opNewDrwTable,i,j,2,TRUE);

				CATIADrawingText  *opText = NULL;
				rc = opNewDrwTable->GetCellObject(i, j,opText);
				if(opText == NULL) 
				{
					cout<<"failed to get opText."<<endl;
					continue;
				}

				ChangeTitleFontType(opText ,iListOfCellString[numofrow*iCol-(iCol-j)],1);

			}
			else
			{
				ChangeFontType(opNewDrwTable,i,j,1,TRUE);
			}
			*/
			
		}
	}

	/*
	//合并单元格
	for(int i=1;i<=iMergeRows.Size();i++)
	{
		int rownumber=iMergeRows[i];
		opNewDrwTable->MergeCells(rownumber, 1, 1, iCol);
	}

	*/


	//cout<<"CreateTabel end."<<endl;

	return TRUE;
}

//描述：更改表格内容的格式
//输入：CATIADrawingText文本，CATUnicodeString文本内容
//输出：
//返回：void
void GeneralClass::ChangeFontType(CATIADrawingText *ipText ,CATUnicodeString istrText)
{
	//cout<<"ChangeFontType!~"<<endl;

	HRESULT rc = S_OK;

	if (istrText == "")
	{
		return;
	}

	//居中
	ipText->put_AnchorPosition(catMiddleLeft);

	CATIDrwText *pDrwText = NULL;
	rc = ipText->QueryInterface(IID_CATIDrwText,(void**)&pDrwText);
	if(FAILED(rc) || pDrwText==NULL) 
	{
		cout<<"failed to get pDrwText."<<endl;
		return ;
	}
	pDrwText->InsertSymbol("\u00B1",0,1,"SSS1");

	CATIDrwTextProperties *pTextProp = NULL;
	rc  = pDrwText->QueryInterface(IID_CATIDrwTextProperties,(void**)&pTextProp);
	if(FAILED(rc) || pTextProp==NULL) 
	{
		cout<<"failed to get pTextProp."<<endl;
		return ;
	}

	if (TRUE)
	{	
		//字间距
		double dbFontSpacing=0.2;
		rc=pTextProp->SetCharacterSpacing(dbFontSpacing);
	}

	//rc=pTextProp->SetScaleMode(CATDrwScaleLinkedToView);

	//rc = pTextProp->SetFontName("FangSong_GB2312 (TrueType)");

	char szGBK[] = "";//new char[istrText.GetLengthInChar() + 1]; 
	CAAUStringConvertToChar(istrText,szGBK);
	//wchar_t *wcharZH = new wchar_t[1000];
	//istrText.ConvertToWChar(wcharZH);
	//WideCharToMultiByte(CP_ACP,0,wcharZH,wcslen(wcharZH)+1,szGBK,256,NULL,NULL);
	string str(szGBK); 
	//if (szGBK) delete[] szGBK; 
	for (int i=0; i<str.length(); i++)
	{
		int iASCII = str[i];
		if (iASCII < 255 && iASCII >0)
		{
			CATUnicodeString strFrontName="SSS1";
			CATBSTR bstrFrontName;
			strFrontName.ConvertToBSTR(&bstrFrontName);
			ipText->SetFontSize(i+1,1,5);
			ipText->SetFontName(i+1,1,bstrFrontName);
		}
		else
		{
			CATUnicodeString strFrontName="SICH";
			CATBSTR bstrFrontName;
			strFrontName.ConvertToBSTR(&bstrFrontName);
			ipText->SetFontSize(i+1,1,7);
			ipText->SetFontName(i+1,1,bstrFrontName);
			//i++;
		}
	}
	pTextProp->Refresh();

	//pDrwText->Release();
	//pDrwText=NULL;

	//pTextProp->Release();
	//pTextProp=NULL;

	//ipText->Release();
	//ipText=NULL;

}

//描述：将3D点转化为2D点
//输入：CATIView视图对象，CATMathPoint数学点
//输出：double
//返回：CATBoolean
CATBoolean GeneralClass::Coord3DTransformTo2D(CATIView_var spiView,
												  CATMathPoint  i3DPositin,
												  double* op2DPt)
{
	HRESULT rc = S_OK;

	CATIGenerSpec_var spGenerSpec=spiView->GetGenerSpec();	
	if(FAILED(rc)||spGenerSpec==NULL_var) return FALSE;

	CATMathPlane PrjPlane=spGenerSpec->GetProjPlane();

	CATMathVector iMathVect1,iMathVect2;
	PrjPlane.GetDirections(iMathVect1,iMathVect2);
	CATMathPoint iMathOrigin=PrjPlane.GetOrigin();

	op2DPt[0]=i3DPositin.GetX()*iMathVect1.GetX()+i3DPositin.GetY()*iMathVect1.GetY()+i3DPositin.GetZ()*iMathVect1.GetZ()-
		(iMathOrigin.GetX()*iMathVect1.GetX()+iMathOrigin.GetY()*iMathVect1.GetY()+iMathOrigin.GetZ()*iMathVect1.GetZ());
	op2DPt[1]=i3DPositin.GetX()*iMathVect2.GetX()+i3DPositin.GetY()*iMathVect2.GetY()+i3DPositin.GetZ()*iMathVect2.GetZ()-
		(iMathOrigin.GetX()*iMathVect2.GetX()+iMathOrigin.GetY()*iMathVect2.GetY()+iMathOrigin.GetZ()*iMathVect2.GetZ());
	return TRUE;
}

//描述：创建标注
//输入：CATIDrwAnnotationFactory对象，CATISpecObject标注对象1，CATISpecObject标注对象2，CATDrwDimType标注类型，CATDrwDimRepresentation，CATMathPoint2D定位点1，CATMathPoint2D定位点2，
//输出：CATIDrwDimDimension
//返回：CATBoolean
CATBoolean GeneralClass::Create2DDrwDimension(CATIDrwAnnotationFactory_var spAnnFact,
													   CATISpecObject_var spSpecOn2DElem1,
													   CATISpecObject_var spSpecOn2DElem2,
													   CATDrwDimType dimType,
													   CATDrwDimRepresentation dimRep,
													   CATMathPoint2D iMathAnchorPt1,
													   CATMathPoint2D iMathAnchorPt2,
													   CATIDrwDimDimension_var &spiDim)
{
	HRESULT rc=S_OK;

	//创建尺寸
	CATIUnknownList * piSelectionsList =NULL;
	CATIUnknownListImpl * piListsel = new CATIUnknownListImpl();
	piSelectionsList = (CATIUnknownList *)piListsel;
	//piListsel->QueryInterface(IID_CATIUnknownList, (void **) &piSelectionsList);
	//piListsel->Release();
	//piListsel=NULL;

	IUnknown * piUI1 = NULL;
	IUnknown * piUI2 = NULL;
	double iPosition1[2];
	double iPosition2[2];
	double  * pts[4];

	CATIDrwDimDimension* piDim=NULL;
	CATDimDefinition dimDef;
	dimDef.Orientation = dimRep;
	dimDef.OrientationReference = ParallelDim;

	if(spSpecOn2DElem1!=NULL_var&&spSpecOn2DElem2!=NULL_var)
	{
		rc=spSpecOn2DElem1->QueryInterface(IID_IUnknown, (void **)&piUI1);
		piSelectionsList->Add(0, piUI1);
		iPosition1[0]=iMathAnchorPt1.GetX();
		iPosition1[1]=iMathAnchorPt1.GetY();
		rc=spSpecOn2DElem2->QueryInterface(IID_IUnknown, (void **)&piUI2);
		piSelectionsList->Add(1, piUI2);
		iPosition2[0]=iMathAnchorPt2.GetX();
		iPosition2[1]=iMathAnchorPt2.GetY();
		pts[0] = iPosition1;
		pts[1] = iPosition1+1;
		pts[2] = iPosition2;
		pts[3] = iPosition2+1;

		rc=spAnnFact->CreateDimension(piSelectionsList,pts,dimType,&dimDef,&piDim);

	}
	else if(spSpecOn2DElem1!=NULL_var)
	{
		rc=spSpecOn2DElem1->QueryInterface(IID_IUnknown, (void **)&piUI1);
		piSelectionsList->Add(0, piUI1);
		iPosition1[0]=iMathAnchorPt1.GetX();
		iPosition1[1]=iMathAnchorPt1.GetY();
		pts[0] = iPosition2;
		pts[1] = iPosition2+1;
		rc=spAnnFact->CreateDimension(piSelectionsList,pts,dimType,&dimDef,&piDim);
	}
	spiDim=piDim;
	if(piDim!=NULL)
	{
		piDim->Release();
		piDim=NULL;
	}
	return TRUE;
}

//***********************************************************************************************************************************
//***********************************************************************************************************************************
//************************************              读写Excel的相关公共函数        **************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************
//描述：在Excel文件中根据表头具体列名，获取对应列的内容
//输入：CATUnicodeString路径, long初始搜索行， CATUnicodeString表头列名
//输出：CATListOfCATUnicodeString内容
//返回：void
void GeneralClass::GetStringOfInputSheet(CATUnicodeString strInputSheetPath,
										 long ilRow,
										 CATUnicodeString istrColName,
										 CATListOfCATUnicodeString &oListOfCellsData)
{
	char strchar[1000];
	CAAUStringConvertToChar(strInputSheetPath,strchar);

	if (strInputSheetPath != "" &&((_access(strchar,0)) != -1))
	{
		//cout<<"The File is exist"<<endl;

		// 1-获取Input Excel文件中的内容
		CATListOfCATUnicodeString ListOfCellsData;
		// 1.1.打开Excel文件
		YFExcelClass* pExcelClass = new YFExcelClass();
		pExcelClass->OpenExcel(strInputSheetPath);

		// 1.2.获取当前Sheet已经使用的行数和列数	
		long lngFormatRows = pExcelClass->GetUsedRowNum();
		long lngFormatColumns = pExcelClass->GetUsedColNum();
		cout<<"行："<<lngFormatRows<<endl;
		cout<<"列："<<lngFormatColumns<<endl;

		// 直接读取表头的那一行，然后根据输入的关键字定位到对应的列
		// 该代码根据YFAI的BOM表头，直接搜索第9行
		int iKeyColIndex = 1;
		for (int i=1; i <= lngFormatColumns; i++)
		{
			CATUnicodeString strColName = pExcelClass->ReadOneCellValue(ilRow,i);
			if (-1 != strColName.SearchSubString(istrColName))
			{
				iKeyColIndex = i;
				break;
			}
		}
		
		//根据所获得的列获取该列的全部内容		
		pExcelClass->GetSheetCellsData(1,10,iKeyColIndex,lngFormatRows,iKeyColIndex,oListOfCellsData,2);
		//cout<<"单元格："<<ListOfCellsData.Size()<<endl;

		//for (int i = 1;i<=lngFormatRows;i++)
		//{
		//	cout<<i<<endl;
		//	for (int j = 1;j<=lngFormatColumns;j++)
		//	{
		//		cout<<i<<","<<j<<": "<<oListOfCellsData[(i-1)*lngFormatColumns+j]<<endl;
		//	}
		//}
		for (int i=1; i <= oListOfCellsData.Size(); i++)
		{
			cout<<oListOfCellsData[i]<<endl;
		}

		// 1.4.保存
		pExcelClass->CloseExcelFile(strInputSheetPath.ConvertToChar());

		// 1.5.释放excel对象
		delete pExcelClass;
		pExcelClass = NULL;
	}


	return ;
}

//描述：在Excel文件中获取指定cell的内容值，并返回该cell对应的合并单元格的信息
//输入：CATUnicodeString路径, long列，long行
//输出：CATUnicodeString单元格值,long合并行数，long合并列数，long合并起始行，long合并起始列
//返回：void
void GeneralClass::GetCellValueAndMergeInfo(CATUnicodeString strInputSheetPath,
											  long ilRow,
											  long ilCol,
											  CATUnicodeString &ostrCellValue,
											  long &oMergeRowCount,
											  long &oMergeColumnCount,
											  long &oMergeStartRow,
											  long &oMergeStartColumn)
{
	char strchar[1000];
	CAAUStringConvertToChar(strInputSheetPath,strchar);

	if (strInputSheetPath != "" &&((_access(strchar,0)) != -1))
	{
		//cout<<"The File is exist"<<endl;

		// 1-获取Input Excel文件中的内容
		CATListOfCATUnicodeString ListOfCellsData;
		// 1.1.打开Excel文件
		YFExcelClass* pExcelClass = new YFExcelClass();
		pExcelClass->OpenExcel(strInputSheetPath);

		// 直接读取表头的那一行，然后根据输入的关键字定位到对应的列
		// 该代码根据YFAI的BOM表头，直接搜索第9行

		CATUnicodeString strCellValue = pExcelClass->ReadOneCellValueAndMergeInfo(ilRow,ilCol,oMergeRowCount,oMergeColumnCount,oMergeStartRow,oMergeStartColumn);

		ostrCellValue = strCellValue;

		// 1.4.保存
		pExcelClass->CloseExcelFile(strInputSheetPath.ConvertToChar());

		// 1.5.释放excel对象
		delete pExcelClass;
		pExcelClass = NULL;
	}
	return ;
}

//描述：读取Excel文件中的指定行的所有内容---------主要用于读取表头
//输入：CATUnicodeString路径, long初始搜索行
//输出：CATListOfCATUnicodeString内容
//返回：void
void GeneralClass::GetRowContents(CATUnicodeString strInputSheetPath,
								  long ilRow,
								  CATListOfCATUnicodeString &oListOfRowContents)
{
	char strchar[1000];
	CAAUStringConvertToChar(strInputSheetPath,strchar);

	if (strInputSheetPath != "" &&((_access(strchar,0)) != -1))
	{
		//cout<<"The File is exist"<<endl;

		// 1-获取Input Excel文件中的内容
		CATListOfCATUnicodeString ListOfCellsData;
		// 1.1.打开Excel文件
		YFExcelClass* pExcelClass = new YFExcelClass();
		pExcelClass->OpenExcel(strInputSheetPath);

		// 1.2.获取当前Sheet已经使用的行数和列数	
		long lngFormatRows = pExcelClass->GetUsedRowNum();
		long lngFormatColumns = pExcelClass->GetUsedColNum();
		cout<<"行："<<lngFormatRows<<endl;
		cout<<"列："<<lngFormatColumns<<endl;

		//判断输入的行是否比excel中已有的行数多
		if (ilRow > lngFormatRows)
		{
			CAAMessageBox("The input Row index outnumbers the selected files. Please modify the input","Error");
			return;
		}

		//根据输入行获取该行的全部内容		
		pExcelClass->GetSheetCellsData(1,ilRow,1,ilRow,lngFormatColumns,oListOfRowContents,1);
		//cout<<"单元格："<<ListOfCellsData.Size()<<endl;

		//for (int i = 1;i<=lngFormatRows;i++)
		//{
		//	cout<<i<<endl;
		//	for (int j = 1;j<=lngFormatColumns;j++)
		//	{
		//		cout<<i<<","<<j<<": "<<oListOfCellsData[(i-1)*lngFormatColumns+j]<<endl;
		//	}
		//}
		for (int i=1; i <= oListOfRowContents.Size(); i++)
		{
			cout<<oListOfRowContents[i]<<endl;
		}

		// 1.4.保存
		pExcelClass->CloseExcelFile(strInputSheetPath.ConvertToChar());

		// 1.5.释放excel对象
		delete pExcelClass;
		pExcelClass = NULL;
	}

	return ;
}

//描述：读取Excel文件中的指定列的所有内容
//输入：CATUnicodeString路径, long初始搜索行
//输出：CATListOfCATUnicodeString内容
//返回：void
void GeneralClass::GetColumnContents(CATUnicodeString strInputSheetPath,
									 long ilCol,
									 CATListOfCATUnicodeString &oListOfColContents)
{
	char strchar[1000];
	CAAUStringConvertToChar(strInputSheetPath,strchar);

	if (strInputSheetPath != "" &&((_access(strchar,0)) != -1))
	{
		//cout<<"The File is exist"<<endl;

		// 1-获取Input Excel文件中的内容
		CATListOfCATUnicodeString ListOfCellsData;
		// 1.1.打开Excel文件
		YFExcelClass* pExcelClass = new YFExcelClass();
		pExcelClass->OpenExcel(strInputSheetPath);

		// 1.2.获取当前Sheet已经使用的行数和列数	
		long lngFormatRows = pExcelClass->GetUsedRowNum();
		long lngFormatColumns = pExcelClass->GetUsedColNum();
		cout<<"行："<<lngFormatRows<<endl;
		cout<<"列："<<lngFormatColumns<<endl;

		//判断输入的行是否比excel中已有的行数多
		if (ilCol > lngFormatColumns)
		{
			CAAMessageBox("The input Column index outnumbers the selected files. Please modify the input","Error");
			return;
		}

		//根据输入行获取该行的全部内容		
		pExcelClass->GetSheetCellsData(1,1,ilCol,lngFormatRows,ilCol,oListOfColContents,2);
		//cout<<"单元格："<<ListOfCellsData.Size()<<endl;

		//for (int i = 1;i<=lngFormatRows;i++)
		//{
		//	cout<<i<<endl;
		//	for (int j = 1;j<=lngFormatColumns;j++)
		//	{
		//		cout<<i<<","<<j<<": "<<oListOfCellsData[(i-1)*lngFormatColumns+j]<<endl;
		//	}
		//}
		for (int i=1; i <= oListOfColContents.Size(); i++)
		{
			cout<<oListOfColContents[i]<<endl;
		}

		// 1.4.保存
		pExcelClass->CloseExcelFile(strInputSheetPath.ConvertToChar());

		// 1.5.释放excel对象
		delete pExcelClass;
		pExcelClass = NULL;
	}

	return ;
}


//***********************************************************************************************************************************
//***********************************************************************************************************************************
//************************************             XML相关 公共函数        *******************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************
//描述：获取配置文件的路径 
//输入：CATUnicodeString文件名称
//输出：CATUnicodeString文件路径
//返回：int
int GeneralClass::GetResourcePath(CATUnicodeString istrFileName,CATUnicodeString &oPath)
{
	const char * cValue = "YFAIResourcePath";
	char * strPath = NULL;
	CATLibStatus sStatus = CATGetEnvValue(cValue,&strPath);
	if ((sStatus ==CATLibError)||(strPath==NULL))
	{
		CATUnicodeString strMessage = "No Environment Parameter : YFAIResourcePath";
		CATUnicodeString strTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strMessage ,strTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return -1;
	}

	CATUnicodeString strSTToolsDir(CATFindPath(CATUnicodeString("ST_Tools"),strPath));
	if(strSTToolsDir == "")
	{
		CATUnicodeString strMessage = "No Folder : ST_Tools";
		CATUnicodeString strTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strMessage ,strTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return  -1;
	}

	strSTToolsDir.Append("\\Resource");
	CATUnicodeString strUsPath(CATFindPath(CATUnicodeString("YFAirventWsp_Resources"),strSTToolsDir));
	if(strUsPath == "")
	{
		CATUnicodeString strMessage = "No Folder : ST_Tools\\Resource\\YFAirventWsp_Resources";
		CATUnicodeString strTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strMessage ,strTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return  -1;
	}

	strUsPath.Append("\\");
	strUsPath.Append(istrFileName);

	if((_access(strUsPath, 0))== -1 )
	{
		CATUnicodeString strMessage = "No File : ST_Tools\\Resource\\YFAirventWsp_Resources";
		strMessage.Append("\\");
		strMessage.Append(istrFileName);
		CATUnicodeString strTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strMessage ,strTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return  -1;
	}

	oPath = strUsPath;
	return 1;
}


//描述：读取xml文件中的发布元素的名称
//输入：
//输出：CATListOfCATUnicodeString内容
//返回：HRESULT
HRESULT GeneralClass::GetFeatureNamesFromXML(CATUnicodeString istrFileName, CATListOfCATUnicodeString &olstFeatureNames)
{
	HRESULT rc = S_OK;
	
	YFAirventXMLClass *pXmlCls = new YFAirventXMLClass();
	//打开xml文件
	CATUnicodeString strPath = "";
	int iFindPath = GetResourcePath(istrFileName,strPath);
	if (iFindPath == -1)
	{
		return E_FAIL;
	}
	char pcPath[10000];
	CAAUStringConvertToChar(strPath,pcPath);
	//const char *pszXmlPath = "C:\\Users\\Administrator\\Desktop\\H-Vane.xml";
	bool bOpenXml = pXmlCls->OpenXmlFile(pcPath);
	if (bOpenXml == false)
	{
		CATUnicodeString strErrMessage = "Cannot Open H-Vane Xml File! ";
		CATUnicodeString strErrTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strErrTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strErrMessage ,strErrTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}
	//获得xml根节点
	TiXmlElement *pRootElem = pXmlCls->GetRootElement();
	if (pRootElem == NULL)
	{
		return E_FAIL;
	}
	//获得根节点下第一层节点-------H_Vane
	TiXmlElement *pFeatureNameNode = pXmlCls->GetFirstChildElement(pRootElem);
	if (pFeatureNameNode == NULL)
	{
		return E_FAIL;
	}
	//获得第二层节点
	TiXmlElement *pSecondNode = pXmlCls->GetFirstChildElement(pFeatureNameNode);
	if (pSecondNode == NULL)
	{
		return E_FAIL;
	}
	////获得第三层节点
	//TiXmlElement *pThirdNode = pXmlCls->GetFirstChildElement(pSecondNode);
	//if (pThirdNode == NULL)
	//{
	//	return E_FAIL;
	//}
	//const char *pszValue = pXmlCls->GetElementValue(pThirdNode);
	//olstFeatureNames.Append(CATUnicodeString(pszValue));

	//循环获得每个第二层节点下的第三层节点的Value
	for (;pSecondNode != NULL; pSecondNode = pXmlCls->GetNextChildElement(pSecondNode))
	{
		TiXmlElement *pThirdNode = pXmlCls->GetFirstChildElement(pSecondNode);
		const char *pValue = pXmlCls->GetElementValue(pThirdNode);
		olstFeatureNames.Append(CATUnicodeString(pValue));
	}

	//
	delete pXmlCls;
	pXmlCls = NULL;
	return rc;
}

//描述：读取xml文件中的发布尺寸参数名以及公差
//输入：
//输出：CATListOfCATUnicodeString内容
//返回：HRESULT
HRESULT GeneralClass::GetParmNamesAndTolFromXML(CATUnicodeString istrFileName, CATListOfCATUnicodeString &olstFeatureNames)
{
	HRESULT rc = S_OK;

	YFAirventXMLClass *pXmlCls = new YFAirventXMLClass();
	//打开xml文件
	CATUnicodeString strPath = "";
	int iFindPath = GetResourcePath(istrFileName,strPath);
	if (iFindPath == -1)
	{
		return E_FAIL;
	}
	char pcPath[10000];
	CAAUStringConvertToChar(strPath,pcPath);
	//const char *pszXmlPath = "C:\\Users\\Administrator\\Desktop\\H-Vane.xml";
	bool bOpenXml = pXmlCls->OpenXmlFile(pcPath);
	if (bOpenXml == false)
	{
		CATUnicodeString strErrMessage = "Cannot Open Xml File! ";
		CATUnicodeString strErrTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strErrTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strErrMessage ,strErrTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}
	//获得xml根节点
	TiXmlElement *pRootElem = pXmlCls->GetRootElement();
	if (pRootElem == NULL)
	{
		return E_FAIL;
	}
	//获得根节点下第一层节点-------H_Vane
	TiXmlElement *pFeatureNameNode = pXmlCls->GetFirstChildElement(pRootElem);
	if (pFeatureNameNode == NULL)
	{
		return E_FAIL;
	}
	//获得同级的另一个节点------Parameter
	TiXmlElement *pParmNameNode = pXmlCls->GetNextChildElement(pFeatureNameNode);
	if (pParmNameNode == NULL)
	{
		return E_FAIL;
	}
	//获得Parameter下面的第二层节点
	TiXmlElement *pSecondNode = pXmlCls->GetFirstChildElement(pParmNameNode);
	if (pSecondNode == NULL)
	{
		return E_FAIL;
	}
	////获得第三层节点
	//TiXmlElement *pThirdNode = pXmlCls->GetFirstChildElement(pSecondNode);
	//if (pThirdNode == NULL)
	//{
	//	return E_FAIL;
	//}
	//const char *pszValue = pXmlCls->GetElementValue(pThirdNode);
	//olstFeatureNames.Append(CATUnicodeString(pszValue));

	//循环获得每个第二层节点下的第三层节点的3个Value
	for (;pSecondNode != NULL; pSecondNode = pXmlCls->GetNextChildElement(pSecondNode))
	{
		//尺寸属性名
		TiXmlElement *pParmName = pXmlCls->GetFirstChildElement(pSecondNode);
		const char *pValue = pXmlCls->GetElementValue(pParmName);
		olstFeatureNames.Append(CATUnicodeString(pValue));
		//尺寸上公差
		TiXmlElement *pTolUpper = pXmlCls->GetNextChildElement(pParmName);
		if (pTolUpper == NULL)
		{
			continue;
		}
		const char *pTolValueUpper = pXmlCls->GetElementValue(pTolUpper);
		//尺寸下公差
		TiXmlElement *pTolLower = pXmlCls->GetNextChildElement(pTolUpper);
		const char *pTolValueLower = pXmlCls->GetElementValue(pTolLower);
		//
		olstFeatureNames.Append(CATUnicodeString(pTolValueUpper));
		olstFeatureNames.Append(CATUnicodeString(pTolValueLower));
	}

	//
	delete pXmlCls;
	pXmlCls = NULL;
	return rc;
}

//描述：读取xml文件中的比例信息
//输入：
//输出：vector<CATListOfDouble> 比例
//返回：HRESULT
HRESULT GeneralClass::GetScaleFromXML(CATUnicodeString istrFileName, vector<CATListOfDouble> &ovecScale)
{
	HRESULT rc = S_OK;

	YFAirventXMLClass *pXmlCls = new YFAirventXMLClass();
	//打开xml文件
	CATUnicodeString strPath = "";
	int iFindPath = GetResourcePath(istrFileName,strPath);
	if (iFindPath == -1)
	{
		return E_FAIL;
	}
	char pcPath[10000];
	CAAUStringConvertToChar(strPath,pcPath);
	//const char *pszXmlPath = "C:\\Users\\Administrator\\Desktop\\H-Vane.xml";
	bool bOpenXml = pXmlCls->OpenXmlFile(pcPath);
	if (bOpenXml == false)
	{
		CATUnicodeString strErrMessage = "Cannot Open ISO Scale Xml File! ";
		CATUnicodeString strErrTitle = "Error";
		CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), strErrTitle.ConvertToChar(),CATDlgNfyError);
		if (NULL != pNotifyDlg)
		{
			pNotifyDlg->DisplayBlocked(strErrMessage ,strErrTitle);
			pNotifyDlg->RequestDelayedDestruction(); 
			pNotifyDlg = NULL;
		}
		return E_FAIL;
	}
	//获得xml根节点
	TiXmlElement *pRootElem = pXmlCls->GetRootElement();
	if (pRootElem == NULL)
	{
		return E_FAIL;
	}
	//获得根节点下第一层节点-------H_Vane_Scale
	TiXmlElement *pFirstNode = pXmlCls->GetFirstChildElement(pRootElem);	//H_Vane_Scale
	if (pFirstNode == NULL)
	{
		return E_FAIL;
	}
	for (;pFirstNode != NULL; pFirstNode = pXmlCls->GetNextChildElement(pFirstNode))
	{
		//获得第二层节点
		TiXmlElement *pSecondNode = pXmlCls->GetFirstChildElement(pFirstNode);
		if (pSecondNode == NULL)
		{
			continue;
		}
		const char *pValue = pXmlCls->GetElementValue(pSecondNode);
		CATListOfCATUnicodeString lstStrScale = NULL;
		SplitString(CATUnicodeString(pValue),",",lstStrScale);
		CATListOfDouble lstScale = NULL;
		for (int i=1; i<=lstStrScale.Size();i++)
		{
			//cout<<lstStrScale[i]<<endl;
			double dblScale = 0;
			lstStrScale[i].ConvertToNum(&dblScale /*,"%.6f"*/);
			lstScale.Append(dblScale);
		}
		ovecScale.push_back(lstScale);

	}
	//
	delete pXmlCls;
	pXmlCls = NULL;
	return rc;
}

CATBoolean GeneralClass::SplitString(CATUnicodeString iStrString, CATUnicodeString iStrSplit, CATListOfCATUnicodeString &oStrList)
{
	CATUnicodeString strTemp, strTemp2;
	int iLocation = iStrString.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);
	int iSize;
	strTemp = iStrString;
	while(iLocation != -1)
	{
		strTemp2 = strTemp.SubString(0, iLocation);
		oStrList.Append(strTemp2);
		iSize = strTemp.GetLengthInChar();

		strTemp2 = strTemp.SubString(iLocation+iStrSplit.GetLengthInChar(), iSize-iLocation-iStrSplit.GetLengthInChar());
		strTemp = strTemp2;
		iLocation = strTemp.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);

		if(iLocation == -1 && strTemp2 != "")
			oStrList.Append(strTemp2);
	}	

	return TRUE;
}

//描述：判断是否是大众零件号
//输入：CATIProduct
//输出：
//返回：CATBOOLEAN
CATBoolean GeneralClass::IsVWPartNumber(CATIProduct_var ispiProd)
{
	CATIProduct_var spiProdRef = ispiProd->GetReferenceProduct();
	CATUnicodeString strPartName = spiProdRef->GetPartNumber();
	//判断第4位字符是否是下划线，是下划线说明是大众号
	if (strPartName.GetLengthInChar() != 63)	//标准大众零件号63个字符
	{
		return FALSE;
	}
	else
	{
		if (3 == strPartName.SearchSubString("_"))
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
}

//描述：从PartName中获取大众零件号
//输入：CATUnicodeString完整零件名
//输出：
//返回：CATUnicodeString大众零件号
CATUnicodeString GeneralClass::GetVWPartNum(CATUnicodeString istrFullName)
{
	CATUnicodeString strVWPartNum = "";
	//取前15位字符
	CATUnicodeString strSubString = istrFullName.SubString(0,15);
	//从最后开始，把连续的末端的下划线去掉
	int iIndexLast = strSubString.GetLengthInChar() - 1;
	for (;iIndexLast == strSubString.SearchSubString("_",0,CATUnicodeString::CATSearchModeBackward);iIndexLast--)
	{
		strSubString = strSubString.SubString(0,iIndexLast);
	}
	strVWPartNum = strSubString;
	return strVWPartNum;
}

//描述：从PartName中获取非大众零件号
//输入：CATUnicodeString完整零件名
//输出：
//返回：CATUnicodeString非大众零件号
CATUnicodeString GeneralClass::GetNonVWPartNum(CATUnicodeString istrFullName)
{
	//判断零件号长度是否大于等于7
	int iLength = istrFullName.GetLengthInChar();
	if (iLength < 7)
	{
		return istrFullName;
	}
	else		//大于等于7位，取前7位作为零件号
	{
		CATUnicodeString strSubString = istrFullName.SubString(0,7);
		return strSubString;
	}
}

//描述：从PartName中获取大众零件名
//输入：CATUnicodeString完整零件名
//输出：
//返回：CATUnicodeString大众零件名
CATUnicodeString GeneralClass::GetVWPartName(CATUnicodeString istrFullName)
{
	CATUnicodeString strVWPartName = "";
	//取第32位字符开始的19位字符
	CATUnicodeString strSubString = istrFullName.SubString(31,19);
	//从最后开始，把连续的末端的下划线去掉
	int iIndexLast = strSubString.GetLengthInChar() - 1;
	for (;iIndexLast == strSubString.SearchSubString("_",0,CATUnicodeString::CATSearchModeBackward);iIndexLast--)
	{
		strSubString = strSubString.SubString(0,iIndexLast);
	}
	//从头开始，把前段连续的下划线也去掉
	for (int i=0; i == strSubString.SearchSubString("_");)
	{
		strSubString.ReplaceSubString(0,1,"");
	}
	strVWPartName = strSubString;
	return strVWPartName;
}

//描述：从PartName中获取非大众零件名
//输入：CATUnicodeString完整零件名
//输出：
//返回：CATUnicodeString非大众零件名
CATUnicodeString GeneralClass::GetNonVWPartName(CATUnicodeString istrFullName)
{
	//判断零件号长度是否大于等于7
	int iLength = istrFullName.GetLengthInChar();
	if (iLength < 7)				//小于7位，直接以全名作为零件名
	{
		return istrFullName;
	}
	else		//大于等于7位，以获取到的第一个英文字之后的所有的字符串作为零件名
	{
		int iPosSplit = IsAlpha(istrFullName);
		if (iPosSplit == -1)
		{
			return istrFullName;
		}
		else
		{
			//istrFullName.ReplaceSubString(0,iPosSplit+1,"");
			CATUnicodeString strSubString = istrFullName.SubString(iPosSplit,iLength - iPosSplit);
			return strSubString;
		}
		////先把PartName末尾最后的连续下划线去掉
		//int iIndexLast = istrFullName.GetLengthInChar() - 1;
		//for (;iIndexLast == istrFullName.SearchSubString("_",0,CATUnicodeString::CATSearchModeBackward);iIndexLast--)
		//{
		//	istrFullName = istrFullName.SubString(0,iIndexLast);
		//}
		////再开始计算最后的下划线或者点的的序号
		//int iPosUnderLine = istrFullName.SearchSubString("_",0,CATUnicodeString::CATSearchModeBackward);
		//int iPosDot = istrFullName.SearchSubString(".",0,CATUnicodeString::CATSearchModeBackward);
		//int iPosSplit = 0;
		//if (iPosUnderLine > iPosDot)
		//{
		//	iPosSplit = iPosUnderLine;
		//} 
		//else
		//{
		//	iPosSplit = iPosDot;
		//}
		//istrFullName.ReplaceSubString(0,iPosSplit+1,"");
		//CATUnicodeString strSubString = istrFullName;
		//return strSubString;
	}
}

//描述：获得Product的零件号和零件名
//输入：CATIProduct
//输出：CATUnicodeString零件号，CATUnicodeString零件名
//返回：CATUnicodeString零件号
HRESULT GeneralClass::GetPartNumAndNameFromProduct(CATIProduct_var ispiProd, CATUnicodeString &ostrPartNum, CATUnicodeString &ostrPartName)
{
	HRESULT rc = S_OK;
	//获取完整PartName
	CATIProduct_var spiProdRef = ispiProd->GetReferenceProduct();
	CATUnicodeString strPartNameFull = spiProdRef->GetPartNumber();
	//判断是否是大众零件号
	CATBoolean bIsVWPart = IsVWPartNumber(spiProdRef);
	//先从Properties的Definition中直接获取零件号
	CATIInstance *piInstance = NULL;
	rc = spiProdRef->QueryInterface(IID_CATIInstance, (void**)&piInstance);
	if (FAILED(rc) || piInstance == NULL)
	{
		return E_FAIL;
	}
	CATIValue *pValue = piInstance->GetValue("Definition");
	CATUnicodeString strValue = "";
	if (pValue == NULL)
	{
		return E_FAIL;
	} 
	else
	{
		rc = pValue->AsString(strValue);
		if (SUCCEEDED(rc) && strValue != "")	//如果获取到了，该字符串直接作为PartNumber
		{
			ostrPartNum = strValue;
		}
		else									//如果没有获取到，需要判断是否是VW的零件号，然后从PartName内获取
		{
			if (bIsVWPart == TRUE)				//如果是大众号
			{
				ostrPartNum = GetVWPartNum(strPartNameFull);
			}
			else								//如果是非大众号
			{
				ostrPartNum = GetNonVWPartNum(strPartNameFull);
			}
		}
	}
	//从PartName中根据判断是否是大众号来获取零件名称
	if (bIsVWPart == TRUE)
	{
		ostrPartName = GetVWPartName(strPartNameFull);
	} 
	else
	{
		ostrPartName = GetNonVWPartName(strPartNameFull);
	}
	return rc;
}

//描述：获取UnicodeString下第一个出现的字母的序号
//输入：CATUnicodeString
//输出：
//返回：int序号
int GeneralClass::IsAlpha(CATUnicodeString istrValue)
{
	int iIndex = -1;
	CATUnicodeChar underline('_');
	CATUnicodeChar dot('.');
	CATUnicodeChar hyphen('-');
	for (size_t i=0; i <= istrValue.GetLengthInChar()-1; i++)
	{
		CATUnicodeChar chValue = istrValue[i];
		if (chValue.IsDigit())
		{
			continue;
		}
		else if (chValue == underline)
		{
			continue;
		}
		else if (chValue == dot)
		{
			continue;
		}
		else if (chValue == hyphen)
		{
			continue;
		}
		else
		{
			iIndex = i;
			break;
		}
	}
	return iIndex;
}

//描述：从三个输入的向量中过滤出夹角最接近90度的两个向量
//输入：double[3]，double[3],double[3]
//输出：double[3]，double[3]
//返回：
void GeneralClass::GetTwoVerticalVectors(double iarrX[3],double iarrY[3],double iarrZ[3],double oarrFirst[3], double oarrSecond[3])
{
	vector<double> lstDelta;
	double dblDelta1 = abs(D3VectorAngle(iarrX,iarrY) - CATPI/2);
	double dblDelta2 = abs(D3VectorAngle(iarrX,iarrZ) - CATPI/2);
	double dblDelta3 = abs(D3VectorAngle(iarrY,iarrZ) - CATPI/2);
	lstDelta.push_back(dblDelta1);
	lstDelta.push_back(dblDelta2);
	lstDelta.push_back(dblDelta3);
	double dblMin = DBL_MAX;
	for (int i=0; i <lstDelta.size(); i++)
	{
		if (dblMin > lstDelta[i])
		{
			dblMin = lstDelta[i];
		}
	}
	if (dblMin == dblDelta1)
	{
		D3ArrayCopy(iarrX,oarrFirst);
		D3ArrayCopy(iarrY,oarrSecond);
	}
	else if (dblMin == dblDelta2)
	{
		D3ArrayCopy(iarrX,oarrFirst);
		D3ArrayCopy(iarrZ,oarrSecond);
	}
	else
	{
		D3ArrayCopy(iarrY,oarrFirst);
		D3ArrayCopy(iarrZ,oarrSecond);
	}
}

//描述：根据输入的4点和相对锚点位置，把这4个点转到相应的图纸全局位置上，并排序，输出列表第一个是包围盒最左上角的点，第二个点是顺时针的下一个点
//输入：vector<CATMathPoint2D> 输入的点，double 制定锚点位置
//输出：CATMathPoint2D 全局坐标下的新位置的4个点
//返回：
void GeneralClass::TransferPoint2DToAbsPos(vector<CATMathPoint2D> ivecPt2D, double iarrAnchorpos[2],CATMathPoint2D oPt2Dnew[4])
{
	//在输入中找到最左上角的点，即x坐标最小，如果有2个点的x坐标都是最小的，取y坐标大的那个
	int iPosFirst = 0;
	CATMathPoint2D tempPt(DBL_MAX,-DBL_MAX);
	for (int i=0; i < ivecPt2D.size(); i++)
	{
		if (ivecPt2D[i].GetX() < tempPt.GetX())
		{
			tempPt = ivecPt2D[i];
			iPosFirst = i;
		}
		else if (ivecPt2D[i].GetX() == tempPt.GetX())
		{
			if (ivecPt2D[i].GetY() > tempPt.GetY())
			{
				tempPt = ivecPt2D[i];
				iPosFirst = i;
			}
		}
		else
		{
			continue;
		}
	}
	//然后根据顺时针方向取出这个点的后一个点，判断前后哪个点的

	//先把列表复制3份建立新列表
	vector<CATMathPoint2D> vecPt2Dnew;
	for (int i=1; i <=3; i ++)
	{
		for (int j=0; j < ivecPt2D.size();j++)
		{
			vecPt2Dnew.push_back(ivecPt2D[j]);
		}
	}
	iPosFirst = iPosFirst + ivecPt2D.size();
	//在新列表中根据新的index值找前一位和后一位的点并分别和tempPt组成二维向量
	CATMathPoint2D pt2Dforward = vecPt2Dnew[iPosFirst-1];
	CATMathPoint2D pt2Dbackward = vecPt2Dnew[iPosFirst+1];
	CATMathVector2D mathvecForward = pt2Dforward - tempPt;
	CATMathVector2D mathvecBackward = pt2Dbackward - tempPt;
	//两个二维向量叉乘的结果是正数，说明a到b是逆时针，反之顺时针
	double dblcrossproduct = mathvecForward.GetX()*mathvecBackward.GetY() - mathvecForward.GetY()*mathvecBackward.GetX();
	if (dblcrossproduct >0 )	//说明数组往后是顺时针方向
	{
		for (int i= iPosFirst; i < vecPt2Dnew.size(); i++)
		{
			oPt2Dnew[i-iPosFirst] = vecPt2Dnew[i]; 
		}
	} 
	else		//说明数组往前是顺时针方向
	{
		for (int i= iPosFirst; i >=0 ; i--)
		{
			oPt2Dnew[iPosFirst - i] = vecPt2Dnew[i];
		}
	}
	return;
}

//描述：根据输入的4点进行排序，输出列表第一个是包围盒最左上角的点，第二个点是顺时针的下一个点
//输入：vector<CATMathPoint2D> 输入的点
//输出：CATMathPoint2D 排序好以后的列表
//返回：
void GeneralClass::SortPt2DClockwise(vector<double*> ivecPt2D,vector<double*> &ovecPt2Dnew)
{
	//在输入中找到最左上角的点，即x坐标最小，如果有2个点的x坐标都是最小的，取y坐标大的那个
	int iPosFirst = 0;
	double tempPt[2] = {999999,-999999};
	for (int i=0; i < ivecPt2D.size(); i++)
	{
		if (ivecPt2D[i][0] < tempPt[0])
		{
			D2ArrayCopy(ivecPt2D[i],tempPt);
			iPosFirst = i;
		}
		else if (ivecPt2D[i][0] == tempPt[0])
		{
			if (ivecPt2D[i][1] > tempPt[1])
			{
				D2ArrayCopy(ivecPt2D[i],tempPt);
				iPosFirst = i;
			}
		}
		else
		{
			continue;
		}
	}
	//然后根据顺时针方向取出这个点的后一个点，判断前后哪个点的

	//先把列表复制3份建立新列表
	vector<double*> vecPt2Dnew;
	for (int i=1; i <=3; i++)
	{
		for (int j=0; j < ivecPt2D.size();j++)
		{
			vecPt2Dnew.push_back(ivecPt2D[j]);
		}
	}
	iPosFirst = iPosFirst + ivecPt2D.size();
	//在新列表中根据新的index值找前一位和后一位的点并分别和tempPt组成二维向量
	double pt2Dforward[2],pt2Dbackward[2];
	D2ArrayCopy(vecPt2Dnew[iPosFirst-1],pt2Dforward);
	D2ArrayCopy(vecPt2Dnew[iPosFirst+1],pt2Dbackward);
	double mathvecForward[2],mathvecBackward[2];
	D2VectorSetFromTwoPoint(tempPt,pt2Dforward,mathvecForward);
	D2VectorSetFromTwoPoint(tempPt,pt2Dbackward,mathvecBackward);
	//两个二维向量叉乘的结果是正数，说明a到b是逆时针，反之顺时针
	double dblcrossproduct = mathvecForward[0]*mathvecBackward[1] - mathvecForward[1]*mathvecBackward[0];
	if (dblcrossproduct >0 )	//说明数组往后是顺时针方向
	{
		for (int i= iPosFirst; i < iPosFirst+4; i++)
		{
			ovecPt2Dnew.push_back(vecPt2Dnew[i]); 
		}
	} 
	else		//说明数组往前是顺时针方向
	{
		for (int i= iPosFirst; i >iPosFirst-4 ; i--)
		{
			ovecPt2Dnew.push_back(vecPt2Dnew[i]);
		}
	}
	return;
}

//描述：根据输入的4点进行排序，输出列表第一个是包围盒最左上角的点，第二个点是顺时针的下一个点
//输入：vector<double*> 输入的点
//输出：vector<double*> 输出的点
//返回：
void GeneralClass::SortPt2DClockwise(vector<double*> &iovecPt2D)
{
	//在输入中找到最左上角的点，即x坐标最小，如果有2个点的x坐标都是最小的，取y坐标大的那个
	int iPosFirst = 0;
	double tempPt[2] = {999999,-999999};
	for (int i=0; i < iovecPt2D.size(); i++)
	{
		if (iovecPt2D[i][0] < tempPt[0])
		{
			D2ArrayCopy(iovecPt2D[i],tempPt);
			iPosFirst = i;
		}
		else if (iovecPt2D[i][0] == tempPt[0])
		{
			if (iovecPt2D[i][1] > tempPt[1])
			{
				D2ArrayCopy(iovecPt2D[i],tempPt);
				iPosFirst = i;
			}
		}
		else
		{
			continue;
		}
	}
	//然后根据顺时针方向取出这个点的后一个点，判断前后哪个点的

	//先把列表复制3份建立新列表
	vector<double*> vecPt2Dnew;
	for (int i=1; i <=3; i++)
	{
		for (int j=0; j < iovecPt2D.size();j++)
		{
			vecPt2Dnew.push_back(iovecPt2D[j]);
		}
	}
	iPosFirst = iPosFirst + iovecPt2D.size();
	iovecPt2D.clear();
	//在新列表中根据新的index值找前一位和后一位的点并分别和tempPt组成二维向量
	double pt2Dforward[2],pt2Dbackward[2];
	D2ArrayCopy(vecPt2Dnew[iPosFirst-1],pt2Dforward);
	D2ArrayCopy(vecPt2Dnew[iPosFirst+1],pt2Dbackward);
	double mathvecForward[2],mathvecBackward[2];
	D2VectorSetFromTwoPoint(tempPt,pt2Dforward,mathvecForward);
	D2VectorSetFromTwoPoint(tempPt,pt2Dbackward,mathvecBackward);
	//两个二维向量叉乘的结果是正数，说明a到b是逆时针，反之顺时针
	double dblcrossproduct = mathvecForward[0]*mathvecBackward[1] - mathvecForward[1]*mathvecBackward[0];
	if (dblcrossproduct >0 )	//说明数组往后是顺时针方向
	{
		for (int i= iPosFirst; i < iPosFirst+4; i++)
		{
			iovecPt2D.push_back(vecPt2Dnew[i]); 
		}
	} 
	else		//说明数组往前是顺时针方向
	{
		for (int i= iPosFirst; i >iPosFirst-4 ; i--)
		{
			iovecPt2D.push_back(vecPt2Dnew[i]);
		}
	}
	return;
}

//描述：根据输入的4点进行排序，输出列表第一个是包围盒最左上角的点，第二个点是顺时针的下一个点
//输入：vector<double*> 输入的点
//输出：vector<double*> 输出的点
//返回：
void GeneralClass::SortPt2DClockwise(vector<POINT2D> &iovecPt2D)
{
	//在输入中找到最左上角的点，即x坐标最小，如果有2个点的x坐标都是最小的，取y坐标大的那个
	int iPosFirst = 0;
	double tempPt[2] = {999999,-999999};
	for (int i=0; i < iovecPt2D.size(); i++)
	{
		if (iovecPt2D[i].Coord[0] < tempPt[0])
		{
			D2ArrayCopy(iovecPt2D[i].Coord,tempPt);
			iPosFirst = i;
		}
		else if (iovecPt2D[i].Coord[0] == tempPt[0])
		{
			if (iovecPt2D[i].Coord[1] > tempPt[1])
			{
				D2ArrayCopy(iovecPt2D[i].Coord,tempPt);
				iPosFirst = i;
			}
		}
		else
		{
			continue;
		}
	}
	//然后根据顺时针方向取出这个点的后一个点，判断前后哪个点的

	//先把列表复制3份建立新列表
	vector<POINT2D> vecPt2Dnew;
	for (int i=1; i <=3; i++)
	{
		for (int j=0; j < iovecPt2D.size();j++)
		{
			vecPt2Dnew.push_back(iovecPt2D[j]);
		}
	}
	iPosFirst = iPosFirst + iovecPt2D.size();
	iovecPt2D.clear();
	//在新列表中根据新的index值找前一位和后一位的点并分别和tempPt组成二维向量
	double pt2Dforward[2],pt2Dbackward[2];
	D2ArrayCopy(vecPt2Dnew[iPosFirst-1].Coord,pt2Dforward);
	D2ArrayCopy(vecPt2Dnew[iPosFirst+1].Coord,pt2Dbackward);
	double mathvecForward[2],mathvecBackward[2];
	D2VectorSetFromTwoPoint(tempPt,pt2Dforward,mathvecForward);
	D2VectorSetFromTwoPoint(tempPt,pt2Dbackward,mathvecBackward);
	//两个二维向量叉乘的结果是正数，说明a到b是逆时针，反之顺时针
	double dblcrossproduct = mathvecForward[0]*mathvecBackward[1] - mathvecForward[1]*mathvecBackward[0];
	if (dblcrossproduct >0 )	//说明数组往后是顺时针方向
	{
		for (int i= iPosFirst; i < iPosFirst+4; i++)
		{
			iovecPt2D.push_back(vecPt2Dnew[i]); 
		}
	} 
	else		//说明数组往前是顺时针方向
	{
		for (int i= iPosFirst; i >iPosFirst-4 ; i--)
		{
			iovecPt2D.push_back(vecPt2Dnew[i]);
		}
	}
	return;
}

//描述：根据锚点和比例，把输入的点集移动到该位置，并返回新坐标的点集
//输入：vector<double*> 输入的点集，double锚点位置，double比例
//输出：vector<double*> 新位置的点集
//返回：
void GeneralClass::TransferPt2DToAbsPos(vector<double*> ivecPt2D, double iarrAnchorPos[2],double iScale,vector<double*> &ovecPt2DAbs)
{
	//先根据点集获取正向长方形的MathBox2D
	if (ivecPt2D.size() == 0)
	{
		return;
	}
	//先根据比例，把所有的输入点调整到该比例
	vector<double*> vecPtScaled;
	for (int i=0; i < ivecPt2D.size(); i++)
	{
		//double *temp = new double[2];
		double temp[2];
		D2VectorScal(ivecPt2D[i],iScale,temp);
		vecPtScaled.push_back(temp);
		cout<<temp[0]<<" , "<<temp[1]<<endl;
	}
	//
	CATMathBox2D tempBox2D;
	for (int i=0; i<vecPtScaled.size(); i++)
	{
		tempBox2D.AddInside(CATMathPoint2D(vecPtScaled[i][0],vecPtScaled[i][1]));
	}
	//获得该正向包围盒的左上角的极值点，该值作为输入点集的局部参考锚点
	double dblXmin,dblXmax,dblYmin,dblYmax;
	tempBox2D.GetExtremities(dblXmin,dblXmax,dblYmin,dblYmax);
	double arrLeftUp[2] = {dblXmin,dblYmax};
	//计算局部锚点与输入锚点的差值
	double arrDelta[2] = {iarrAnchorPos[0]-arrLeftUp[0],iarrAnchorPos[1]-arrLeftUp[1]};
	//把输入点集的每个点都加上这个delta值，就是新的坐标
	for (int i=0; i<vecPtScaled.size(); i++)
	{
		//double *tempPt2D = new double[2];
		double tempPt2D[2];
		tempPt2D[0] = vecPtScaled[i][0]+arrDelta[0];
		tempPt2D[1] = vecPtScaled[i][1]+arrDelta[1];
		ovecPt2DAbs.push_back(tempPt2D);
	}
	//
	//for (int i=0; i < vecPtScaled.size(); i++)
	//{
	//	delete vecPtScaled[i];
	//}
	return;
}

//描述：根据锚点和比例，把输入的点集移动到该位置，并返回新坐标的点集，以及对应的长方形包围盒的对角线的两个点
//输入：vector<double*> 输入的点集，double锚点位置，double比例，int 包围盒相对位置点，1表示左上用于A3，2表示左下用于非A3
//输出：vector<double*> 新位置的点集
//返回：
void GeneralClass::MovePt2DToAbsPos(vector<POINT2D> ivecPt2D, double iarrAnchorPos[2],double iScale,int iType,
													 vector<POINT2D> &ovecPt2DAbs,double oPtCorner1[2],double oPtCorner2[2])
{
	ovecPt2DAbs.clear();
	//先根据点集获取正向长方形的MathBox2D
	if (ivecPt2D.size() == 0)
	{
		return;
	}
	//先根据比例，把所有的输入点调整到该比例
	vector<POINT2D> vecPtScaled;
	for (int i=0; i < ivecPt2D.size(); i++)
	{
		POINT2D temp;
		D2VectorScal(ivecPt2D[i].Coord,iScale,temp.Coord);
		vecPtScaled.push_back(temp);
		cout<<temp.Coord[0]<<" , "<<temp.Coord[1]<<endl;
	}
	//
	CATMathBox2D tempBox2D;
	for (int i=0; i<vecPtScaled.size(); i++)
	{
		tempBox2D.AddInside(CATMathPoint2D(vecPtScaled[i].Coord[0],vecPtScaled[i].Coord[1]));
	}
	//获得该正向包围盒的左上角的极值点，该值作为输入点集的局部参考锚点
	double dblXmin,dblXmax,dblYmin,dblYmax;
	tempBox2D.GetExtremities(dblXmin,dblXmax,dblYmin,dblYmax);
	double arrRelativePos[2];
	if (iType == 1)
	{
		arrRelativePos[0] = dblXmin;
		arrRelativePos[1] = dblYmax;
	}
	else
	{
		arrRelativePos[0] = dblXmin;
		arrRelativePos[1] = dblYmin;
	}
	//计算局部锚点与输入锚点的差值
	double arrDelta[2] = {iarrAnchorPos[0]-arrRelativePos[0],iarrAnchorPos[1]-arrRelativePos[1]};
	//把输入点集的每个点都加上这个delta值，就是新的坐标
	for (int i=0; i<vecPtScaled.size(); i++)
	{
		POINT2D tempPt2D;
		tempPt2D.Coord[0] = vecPtScaled[i].Coord[0]+arrDelta[0];
		tempPt2D.Coord[1] = vecPtScaled[i].Coord[1]+arrDelta[1];
		ovecPt2DAbs.push_back(tempPt2D);
	}
	//根据新位置的4个点返回对角线的2个点
	tempBox2D.SetToEmpty();
	for (int i=0; i<ovecPt2DAbs.size();i++)
	{
		tempBox2D.AddInside(CATMathPoint2D(vecPtScaled[i].Coord[0],vecPtScaled[i].Coord[1]));
	}
	tempBox2D.GetExtremities(dblXmin,dblXmax,dblYmin,dblYmax);
	if (iType == 1)	//对于A3来说，需要获得左上和右下角的点
	{
		oPtCorner1[0] = dblXmin;
		oPtCorner1[1] = dblYmax;
		oPtCorner2[0] = dblXmax;
		oPtCorner2[1] = dblYmin;
	} 
	else	//非A3来说，需要获得左下和右上角的点
	{
		oPtCorner1[0] = dblXmin;
		oPtCorner1[1] = dblYmin;
		oPtCorner2[0] = dblXmax;
		oPtCorner2[1] = dblYmax;
	}
	return;
}

//描述：根据输入的三个向量，投影到输入平面后，根据向量的长度，取前2个较长的作为输出方向
//输入：double 方向1，double 方向2，double 方向3
//输出：double 方向，double 方向
//返回：
void GeneralClass::GetTwoLongerDirections(double iarrDir1[3],double iarrDir2[3],double iarrDir3[3],double iarrPlane[3],double oarrDir1[3],double oarrDir2[3])
{
	double len1,len2,len3;
	double temp[3];
	double arrProjDir1[3],arrProjDir2[3],arrProjDir3[3];
	//先把三个输入都投影到输入平面上
	D3CrossProduct(iarrDir1,iarrPlane,temp);
	D3CrossProduct(iarrPlane,temp,arrProjDir1);

	D3CrossProduct(iarrDir2,iarrPlane,temp);
	D3CrossProduct(iarrPlane,temp,arrProjDir2);

	D3CrossProduct(iarrDir3,iarrPlane,temp);
	D3CrossProduct(iarrPlane,temp,arrProjDir3);
	//再计算长度
	len1 = D3VectorLen(arrProjDir1);
	len2 = D3VectorLen(arrProjDir2);
	len3 = D3VectorLen(arrProjDir3);
	if (len1 >= len2)
	{
		D3ArrayCopy(arrProjDir1,oarrDir1);
		if (len2 >= len3)
		{
			D3ArrayCopy(arrProjDir2,oarrDir2);
		} 
		else
		{
			D3ArrayCopy(arrProjDir3,oarrDir2);
		}
	} 
	else
	{
		D3ArrayCopy(arrProjDir2,oarrDir1);
		if (len1 >= len3)
		{
			D3ArrayCopy(arrProjDir1,oarrDir2);
		}
		else
		{
			D3ArrayCopy(arrProjDir3,oarrDir2);
		}
	}
	D3VectorUnit(oarrDir1,oarrDir1);
	D3VectorUnit(oarrDir2,oarrDir2);

}

//描述：根据输入的斜向包围盒的4个点，算出竖直方向的偏移量，然后获得新的参考锚点
//输入：vector<double*> 斜向包围盒的4个点，double 点1，double 点2，double 公差值，int 图纸类型，1表示A3，2表示非A3
//输出：double 移动点
//返回：
void GeneralClass::CalculateVerticalMovePoint(vector<double*> ivecPt2D,double ipt1[2],double ipt2[2],double iTol,int iType,double opt[2])
{
	//
	CATMathPoint2D mathPt1(ivecPt2D[0][0],ivecPt2D[0][1]);
	CATMathPoint2D mathPt2(ivecPt2D[1][0],ivecPt2D[1][1]);
	CATMathPoint2D mathPt3(ivecPt2D[2][0],ivecPt2D[2][1]);
	CATMathPoint2D mathPt4(ivecPt2D[3][0],ivecPt2D[3][1]);
	//点1和点4，点3和点4组成直线
	CATMathLine2D mathLine1(mathPt1,mathPt4);
	CATMathLine2D mathLine2(mathPt3,mathPt4);
	//过点2向下作一根竖直的线
	CATMathLine2D mathLineVertical;
	if (iType == 1)
	{
		CATMathPoint2D tempPt(mathPt2.GetX(),ipt2[1]);
		mathLineVertical.Set(mathPt2,tempPt);
	} 
	else
	{
		CATMathPoint2D tempPt(mathPt2.GetX(),ipt1[1]);
		mathLineVertical.Set(mathPt2,tempPt);
	}
	//分别作相交
	double dblParm, dblParmOther;
	CATMathPoint2D ptIntersect1,ptIntersect2;
	int iIntersect1 = mathLineVertical.Intersect(mathLine1,dblParmOther,dblParm);
	if (iIntersect1 == 1)
	{
		ptIntersect1 = mathLineVertical.EvalPoint(dblParm);
	}
	else
	{
		ptIntersect1.SetCoord(DBL_MAX,DBL_MAX);
	}
	int iIntersect2 = mathLineVertical.Intersect(mathLine2,dblParmOther,dblParm);
	if (iIntersect2 == 1)
	{
		ptIntersect2 = mathLineVertical.EvalPoint(dblParm);
	}
	else
	{
		ptIntersect2.SetCoord(DBL_MAX,DBL_MAX);
	}
	//取距离短的那个
	double moveValue = 0;
	double dblDistance1 = mathPt2.DistanceTo(ptIntersect1);
	double dblDistance2 = mathPt2.DistanceTo(ptIntersect2);
	if (dblDistance1 >= dblDistance2)
	{
		moveValue = dblDistance2;
	}
	else
	{
		moveValue = dblDistance1;
	}
	moveValue = moveValue + iTol;
	//
	if (iType == 1)
	{
		opt[0] = ipt1[0];
		opt[1] = ipt1[1] - moveValue;
	} 
	else
	{
		opt[0] = ipt1[0];
		opt[1] = ipt1[1] + moveValue;
	}
}

//描述：根据输入的4点按顺序创建数学线
//输入：vector<POINT2D> 输入的4点
//输出：vector<CATMathLine2D> 输出的线集
//返回：
void GeneralClass::CreateLinesFromPoints(vector<POINT2D> ivecPt2D, vector<CATMathLine2D> &ovecLine)
{
	//
	CATMathPoint2D mathPt1(ivecPt2D[0].Coord[0],ivecPt2D[0].Coord[1]);
	CATMathPoint2D mathPt2(ivecPt2D[1].Coord[0],ivecPt2D[1].Coord[1]);
	CATMathPoint2D mathPt3(ivecPt2D[2].Coord[0],ivecPt2D[2].Coord[1]);
	CATMathPoint2D mathPt4(ivecPt2D[3].Coord[0],ivecPt2D[3].Coord[1]);
	//
	CATMathLine2D line1(mathPt1,mathPt2);
	CATMathLine2D line2(mathPt2,mathPt3);
	CATMathLine2D line3(mathPt3,mathPt4);
	CATMathLine2D line4(mathPt4,mathPt1);
	//
	ovecLine.clear();
	ovecLine.push_back(line1);
	ovecLine.push_back(line2);
	ovecLine.push_back(line3);
	ovecLine.push_back(line4);
}

//描述：检查输入线与box的4根线的交点
//输入：CATMathLine2D 输入线，vector<CATMathLine2D> box的四根线
//输出：vector<CATMathPoint2D> 相交点
//返回：
void GeneralClass::CheckLineIntersect(CATMathLine2D iLine, vector<CATMathLine2D> ivecLine, vector<CATMathPoint2D> &ovecPt)
{
	for (int i=0; i<ivecLine.size(); i++)
	{
		double parm, parmOther;
		int iIntersect = iLine.Intersect(ivecLine[i],parmOther,parm);
		if (iIntersect == 1)
		{
			if (parmOther>=0 && parmOther <=1 && parm >= 0)
			{
				CATMathPoint2D ptIntersect = iLine.EvalPoint(parm);
				ovecPt.push_back(ptIntersect);
			}
		}
		else if (iIntersect == 2)
		{
			//先算出直线的两个端点
			CATMathPoint2D pt1,pt2;
			pt1 = ivecLine[i].EvalPoint(0);
			pt2 = ivecLine[i].EvalPoint(1);
			//
			CATMathPoint2D ptOrigin;
			ptOrigin = iLine.GetOrigin();
			if (abs(ptOrigin.DistanceTo(pt1)) <= 0.0001 || abs(ptOrigin.DistanceTo(pt2)) <= 0.0001)	//如果与任意端点重合，则加入列表
			{
				ovecPt.push_back(ptOrigin);
			}
			else
			{
				CATMathVector2D dir1, dir2;
				dir1.SetCoord(pt1.GetX()-ptOrigin.GetX(),pt1.GetY()-ptOrigin.GetY());
				dir2.SetCoord(pt2.GetX()-ptOrigin.GetX(),pt2.GetY()-ptOrigin.GetY());
				if (dir1.GetX()/dir2.GetX() < 0)		//如果在直线两个端点之间的，则加入列表
				{
					ovecPt.push_back(ptOrigin);
				}
			}
		}
	}
}


//描述：判断输入点是否在box内部，包括box边线上
//输入：POINT2D 输入点，vector<POINT2D> box4点
//输出：
//返回：CATBoolean
CATBoolean GeneralClass::IsPointInsideBox(POINT2D iPt2D, vector<POINT2D> vecBox)
{
	//通过算叉积，判断点是否在box内，包括在box上
	double cross1,cross2,cross3,cross4;
	cross1 = (vecBox[1].Coord[0]-vecBox[0].Coord[0])*(iPt2D.Coord[1]-vecBox[0].Coord[1]) - (vecBox[1].Coord[1]-vecBox[0].Coord[1])*(iPt2D.Coord[0]-vecBox[0].Coord[0]);
	cross2 = (vecBox[2].Coord[0]-vecBox[1].Coord[0])*(iPt2D.Coord[1]-vecBox[1].Coord[1]) - (vecBox[2].Coord[1]-vecBox[1].Coord[1])*(iPt2D.Coord[0]-vecBox[1].Coord[0]);
	cross3 = (vecBox[3].Coord[0]-vecBox[2].Coord[0])*(iPt2D.Coord[1]-vecBox[2].Coord[1]) - (vecBox[3].Coord[1]-vecBox[2].Coord[1])*(iPt2D.Coord[0]-vecBox[2].Coord[0]);
	cross4 = (vecBox[0].Coord[0]-vecBox[3].Coord[0])*(iPt2D.Coord[1]-vecBox[3].Coord[1]) - (vecBox[0].Coord[1]-vecBox[3].Coord[1])*(iPt2D.Coord[0]-vecBox[3].Coord[0]);
	if ((cross1 >= 0 && cross2 >= 0 && cross3 >= 0 && cross4 >= 0) 
		|| (cross1 <= 0 && cross2 <= 0 && cross3 <= 0 && cross4 <= 0))
	{
		return TRUE;
	}
	return FALSE;
}

//描述：计算点在box内的y向最大干涉量
//输入：int 类型，1代表A3，-1代表非A3，POINT2D 输入点，vector<POINT2D> box的四个点
//输出：
//返回：double 单一的y向最大干涉量
double GeneralClass::CalculateCollisionDistanceMax(int iType,POINT2D iPt,vector<POINT2D> ivecBox)
{
	double dblCollision = -DBL_MAX;
	//先创建box的四根线
	vector<CATMathLine2D> vecline;
	CreateLinesFromPoints(ivecBox,vecline);
	//再把输入点和方向给出
	CATMathPoint2D pt2D(iPt.Coord[0],iPt.Coord[1]);
	CATMathVector2D dirY;
	if (iType == 1) // 如果是A3，相交射线朝下
	{
		dirY.SetCoord(0,-1);
	} 
	else	//非A3，相交射线朝上
	{
		dirY.SetCoord(0,1);
	}
	CATMathLine2D intersectLine(pt2D,dirY);
	//作相交求出相交点list
	vector<CATMathPoint2D> vecPtIntersect;
	CheckLineIntersect(intersectLine,vecline,vecPtIntersect);
	for (int k=0; k<vecPtIntersect.size(); k++)
	{
		double distance = abs(pt2D.DistanceTo(vecPtIntersect[k]));
		if (distance > dblCollision)
		{
			dblCollision = distance;
		}
	}
	return dblCollision;
}

//描述：检查输入的4点与已经存在的点集是否有相交(包括接触)，并求出y向的最大干涉值（即需要移动摆脱干涉的距离）
//输入：int 类型，1代表A3，2代表非A3，vector<POINT2D> 待测量的4点，vector<vector<POINT2D>>视图中已存在的点集
//输出：double y向最大干涉量
//返回：CATBoolean
CATBoolean GeneralClass::CheckBoxIntersect(int iType, vector<POINT2D> ivecPt2D, vector<vector<POINT2D>> ivecLstBox, double &oCollisionY)
{
	CATBoolean bIntersect = FALSE;

	oCollisionY = -DBL_MAX;
	for (int i=0; i<ivecLstBox.size();i++)
	{
		double collisionTemp = -DBL_MAX;
		for (int j=0; j<ivecPt2D.size(); j++)
		{
			CATBoolean bInside = IsPointInsideBox(ivecPt2D[j],ivecLstBox[i]);
			if (bInside == TRUE)
			{
				bIntersect = TRUE;
				////如果点在box内或者上，则做y向射线求交点
				//vector<CATMathLine2D> vecline;
				//CreateLinesFromPoints(ivecLstBox[i],vecline);
				//CATMathPoint2D pt2D(ivecPt2D[j].Coord[0],ivecPt2D[j].Coord[1]);
				//CATMathVector2D dirY;
				//if (iType == 1) // 如果是A3，相交射线朝下
				//{
				//	dirY.SetCoord(0,-1);
				//} 
				//else	//非A3，相交射线朝上
				//{
				//	dirY.SetCoord(0,1);
				//}
				//CATMathLine2D intersectLine(pt2D,dirY);
				////
				//vector<CATMathPoint2D> vecPtIntersect;
				//CheckLineIntersect(intersectLine,vecline,vecPtIntersect);
				//double distanceMax = -DBL_MAX;
				//for (int k=0; k<vecPtIntersect.size(); k++)
				//{
				//	double distance = abs(pt2D.DistanceTo(vecPtIntersect[k]));
				//	if (distance > distanceMax)
				//	{
				//		distanceMax = distance;
				//	}
				//}
				double distanceMax = CalculateCollisionDistanceMax(iType,ivecPt2D[j],ivecLstBox[i]);

				if (distanceMax > collisionTemp)
				{
					collisionTemp = distanceMax;
				}
			}
		}
		//反过来再算一波，考虑了输入的box和已有的box的边界不平行
		if (bIntersect == TRUE)
		{
			for (int m=0; m<ivecLstBox[i].size();m++)
			{
				CATBoolean bInside = IsPointInsideBox(ivecLstBox[i][m],ivecPt2D);
				if (bInside == TRUE)
				{
					//vector<CATMathLine2D> vecline;
					//CreateLinesFromPoints(ivecPt2D,vecline);

					//CATMathPoint2D pt2D(ivecLstBox[i][m].Coord[0],ivecLstBox[i][m].Coord[1]);
					//CATMathVector2D dirY;
					//if (iType == 1) // 如果是A3，相交射线朝上
					//{
					//	dirY.SetCoord(0,1);
					//} 
					//else	//非A3，相交射线朝下
					//{
					//	dirY.SetCoord(0,-1);
					//}
					//CATMathLine2D intersectLine(pt2D,dirY);
					////
					//vector<CATMathPoint2D> vecPtIntersect;
					//CheckLineIntersect(intersectLine,vecline,vecPtIntersect);
					//double distanceMax = -DBL_MAX;
					//for (int k=0; k<vecPtIntersect.size(); k++)
					//{
					//	double distance = abs(pt2D.DistanceTo(vecPtIntersect[k]));
					//	if (distance > distanceMax)
					//	{
					//		distanceMax = distance;
					//	}
					//}
					double distanceMax = CalculateCollisionDistanceMax(-1*iType,ivecLstBox[i][m],ivecPt2D);

					if (distanceMax > collisionTemp)
					{
						collisionTemp = distanceMax;
					}
				}
			}
		}

		if (collisionTemp > oCollisionY)
		{
			oCollisionY = collisionTemp;
		}
	}

	return bIntersect;
}

//检查License是否勾选，如果没有则勾选上
HRESULT GeneralClass::CheckStaticLicense(CATUnicodeString istrLicName)
{
	CATISysLicenseSettingAtt* piSysLicenseSettingAtt = NULL;

	HRESULT rc = CATInstantiateComponent("CATSysLicenseSettingCtrl",
										IID_CATISysLicenseSettingAtt, (void **)&piSysLicenseSettingAtt);	//第一个输入的字符串不是随意输入

	if(piSysLicenseSettingAtt == NULL||FAILED(rc))
	{
		cout<<"Error in piSysLicenseSettingAtt"<<endl;
		return E_FAIL;
	}
	else
	{
		cout<<"Successful in piSysLicenseSettingAtt"<<endl;
	}

	//CATUnicodeString iLicenseName = "FMS.prd";

	CATUnicodeString oValue ;

	rc = piSysLicenseSettingAtt->GetLicense(&istrLicName, &oValue);

	if (FAILED(rc))
	{
		cout<<"Get License Failed! "<<endl;
		return E_FAIL;
	}

	if(oValue == "NotRequested")//如果license不存在，则跳出面板提示license不存在，让其选择License

	{
		cout<<"License not Selected"<<endl;
		cout<<"Starting to Select the License"<<endl;
		oValue = istrLicName;
		rc = piSysLicenseSettingAtt->SetLicense(&istrLicName,&oValue);
		if (FAILED(rc))
		{
			cout<<"Set License Failed!"<<endl;
			return E_FAIL;
		}
		else
		{
			cout<<"Set License Succeeded! "<<endl;
		}

	}

	else 
	{
		cout<<"License Already Selected"<<endl;
	}

	return S_OK;
}

//检查License是否勾选，如果没有则勾选上
HRESULT GeneralClass::CheckDynamicLicense(CATUnicodeString istrLicName)
{
	CATISysDynLicenseSettingAtt* piSysDynLicenseSettingAtt = NULL;

	HRESULT rc = CATInstantiateComponent("CATSysDynLicenseSettingCtrl",
										IID_CATISysDynLicenseSettingAtt, (void **)&piSysDynLicenseSettingAtt);	//第一个输入的字符串不是随意输入

	if(piSysDynLicenseSettingAtt == NULL||FAILED(rc))
	{
		cout<<"Error in piSysDynLicenseSettingAtt"<<endl;
		return E_FAIL;
	}
	else
	{
		cout<<"Successful in piSysDynLicenseSettingAtt"<<endl;
	}

	//CATUnicodeString iLicenseName = "FMS.prd";

	CATUnicodeString oValue ;

	//oValue = istrLicName;
	//rc = piSysDynLicenseSettingAtt->SetLicense(&istrLicName,&oValue);
	//if (FAILED(rc))
	//{
	//	cout<<"Set License Failed!"<<endl;
	//	return E_FAIL;
	//}
	//else
	//{
	//	cout<<"Set License Succeeded! "<<endl;
	//}

	///*
	rc = piSysDynLicenseSettingAtt->GetLicense(&istrLicName, &oValue);

	if (FAILED(rc))
	{
		cout<<"Get License Failed! "<<endl;
		return E_FAIL;
	}

	if(oValue == "NotRequested")//如果license不存在，则跳出面板提示license不存在，让其选择License

	{
		cout<<"License not Selected"<<endl;
		cout<<"Starting to Select the License"<<endl;
		oValue = istrLicName;
		rc = piSysDynLicenseSettingAtt->SetLicense(&istrLicName,&oValue);
		if (FAILED(rc))
		{
			cout<<"Set License Failed!"<<endl;
			return E_FAIL;
		}
		else
		{
			cout<<"Set License Succeeded! "<<endl;
		}

	}

	else 
	{
		cout<<"License Already Selected"<<endl;
	}
	//*/

	return S_OK;
}

//
void GeneralClass::RemoveLastZeroesFromString(CATUnicodeString &ioString)
{
	if (-1 != ioString.SearchSubString("."))	//先判断字符串中是否含有小数点
	{
		CATUnicodeChar zero('0');
		CATUnicodeChar dot('.');
		int iRemoveCharNum = 0;
		int iLength = ioString.GetLengthInChar();
		for (size_t i=iLength-1;i>=0;i--)
		{
			CATUnicodeChar chValue = ioString[i];
			if (chValue == zero)
			{
				iRemoveCharNum++;
			}
			else if (chValue == dot)
			{
				iRemoveCharNum++;
				break;
			}
			else
			{
				break;
			}
		}
		ioString = ioString.SubString(0,iLength-iRemoveCharNum);
	}
}

//描述：获取对象名称
//输入：CATBaseUnknown_var BaseUnknown对象
//输出：CATUnicodeString  对象名
//返回：CATUnicodeString
CATUnicodeString GeneralClass::GetNameFromBaseUnknownFunc(CATBaseUnknown_var ispiBaseUnknown)
{
	CATUnicodeString strPathName = "";
	if(NULL_var == ispiBaseUnknown)
	{
		return strPathName;
	}
	CATIAlias *piAlias = NULL;
	if(SUCCEEDED(ispiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
	{
		CATUnicodeString Name = piAlias->GetAlias();
		strPathName = Name;
		piAlias->Release();
		piAlias = NULL;
	}
	return strPathName;
}

//
HRESULT GeneralClass::GetCrvRadiusOnSurface(CATFace_var ispFace,double &odblCrvRadiusMin,double &odblCrvRadiusMax)
{
	HRESULT rc = S_OK;
	if (ispFace == NULL_var)
	{
		return E_FAIL;
	}
	//
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();
	//
	CATSurParam iCenterParam;
	ispFace->EstimateCenterParam(iCenterParam);
	CATSurface_var spSurface = ispFace->GetSurface();
	if (spSurface == NULL_var)
	{
		return E_FAIL;
	}
	CATMathPoint mathPt = spSurface->EvalPoint(iCenterParam);
	mathPt.Dump();
	//
	CATLocalAnalysis2D *pAnalysis2D = ::CATCreateLocalAnalysis(pConfig,spSurface,iCenterParam);
	if (pAnalysis2D == NULL)
	{
		return E_FAIL;
	}
	//
	double dblCurvatureMin,dblCurvatureMax;
	pAnalysis2D->GetMinMaxCurvature(dblCurvatureMin,dblCurvatureMax);
	//
	odblCrvRadiusMin = abs(1/dblCurvatureMin);
	odblCrvRadiusMax = abs(1/dblCurvatureMax);

	return rc;
}