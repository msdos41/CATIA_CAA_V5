// COPYRIGHT Dassault Systemes 2019
//===================================================================
//
// GeneralClass.cpp
// Header definition of MYGeneral
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Nov 2019  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "GeneralClass.h"



//从char转到unicodestring,主要用于解决中文字符的乱码显示
CATUnicodeString CAAUStringBuildFromChar(char * strchar)
{
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	wchar_t* strwcANSI = new wchar_t[len + 1]; 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
	CATUnicodeString strwcUnicode;
	strwcUnicode.BuildFromWChar(strwcANSI); 
	if(strwcANSI) delete [] strwcANSI;
	return strwcUnicode;
}
//从unicodestring转到char*,主要用于解决中文字符的乱码显示
void CAAUStringConvertToChar(CATUnicodeString strUnicode,char* strchar )
{
	int len = WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, NULL, 0, NULL, NULL); 
	memset(strchar, 0, len + 1); 
	WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, strchar, len, NULL, NULL); 
}
//从unicodestring转到wchar_t*,主要用于解决中文字符的乱码显示
void CAAUStringConvertToWChar(CATUnicodeString strUnicode, wchar_t* strwcANSI)
{
	const char *strchar =  strUnicode.ConvertToChar();
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
}

//描述：显示/隐藏对象
//输入：CATISpecObject对象，CATBoolean
//输出：void
//返回：void
void HideSpecObject( CATISpecObject_var spSpec,CATBoolean bShown )
{
	HRESULT rc=S_OK;

	if(spSpec!=NULL_var)
	{
		CATIVisProperties* piVisProp=NULL;
		CATVisPropertiesValues ioValues;
		CATShowAttribut oShow;
		if(bShown)
		{
			oShow=CATShowAttr;
		}
		else
		{
			oShow=CATNoShowAttr;
		}
		ioValues.SetShowAttr(oShow);
		if(SUCCEEDED(spSpec->QueryInterface(IID_CATIVisProperties,(void**)&piVisProp)))
		{
			rc=piVisProp->SetPropertiesAtt(ioValues,CATVPShow,CATVPGlobalType);
			piVisProp->Release();
			piVisProp=NULL;
		}
		CATIModelEvents_var spEvents = spSpec;
		if (NULL_var != spEvents)
		{
			CATModifyVisProperties ModifyNotification(spSpec, NULL, CATVPGlobalType, CATVPShow, ioValues); 
			spEvents->Dispatch(ModifyNotification);
		}
	}
}
//描述：查看特征的显示类型
//输入：CATISpecObject对象
//输出：CATBoolean true隐藏 false显示
//返回：CATBoolean
CATBoolean CheckShowState( CATISpecObject_var spSpec )
{
	HRESULT rc=S_OK;
	if(NULL_var == spSpec)
	{
		return FALSE;
	}
	CATBoolean bHide=TRUE;
	CATIVisProperties* piVisProp=NULL;
	if(SUCCEEDED(spSpec->QueryInterface(IID_CATIVisProperties,(void**)&piVisProp)))
	{
		CATVisPropertiesValues ioValues;
		rc=piVisProp->GetPropertiesAtt(ioValues,CATVPShow,CATVPGlobalType);
		CATShowAttribut oShow;
		ioValues.GetShowAttr(oShow);
		if(oShow==CATNoShowAttr)
		{
			bHide=FALSE;
		}
		piVisProp->Release();
		piVisProp=NULL;
	}
	return bHide;
}

//描述：更新
//输入：CATISpecObject对象
//输出：HRESULT
//返回：HRESULT
HRESULT ObjectUpdate( const CATISpecObject_var & ispSpec )
{
	HRESULT rc = S_OK; 
	if(NULL_var!= ispSpec )
	{
		CATTry
		{	
			ispSpec -> Update();
			CATISpecObject_var spFather = ispSpec->GetFather();
			if ( NULL_var  != spFather ) 
			{
				CATIGSMTool *piGSMToolFather = NULL;
				rc =spFather->QueryInterface ( IID_CATIGSMTool, (void**) &piGSMToolFather);
				if ( SUCCEEDED(rc) )
				{ 
					int IsAnOGS = -1 ;
					piGSMToolFather->GetType(IsAnOGS) ;
					if ( 1 == IsAnOGS )
					{
						CATBaseUnknown_var spUnkwnSpec = ispSpec;
						rc = CATMmrLinearBodyServices::Insert(spUnkwnSpec) ; 
					} 
					piGSMToolFather->Release() ; piGSMToolFather=NULL; 
				}   
				spFather -> Release() ; 
			}
		}

		// This block is specific for Update Errors
		CATCatch(CATMfErrUpdate,error)
		{
			cerr << " Update Error: " << (error-> GetDiagnostic()).ConvertToChar() << endl; 
			Flush(error) ; 
			return E_FAIL; 
		}
		// This block treats every other exception
		CATCatch(CATError,error)
		{
			cerr << " Error: " << error->GetMessageText() <<endl; 
			Flush(error);
			return E_FAIL; 
		}
		CATEndTry;

	}
	return rc ; 
}

//描述：获取历史记录
//输入：CATUnicodeString文件路径,CATUnicodeString设置的名称
//输出：CATUnicodeString 历史记录
//返回：HRESULT
CATBoolean RetrieveHistorySetting( CATUnicodeString istrRepository, CATUnicodeString istrSettingName, CATUnicodeString &ostrSettingValue )
{
	//cout<<"# Retrieve History Setting"<<endl;
	CATSettingRepository *pRepository=NULL;
	pRepository=CATSettingRepository::GetRepository(istrRepository);
	CATString oldValue;
	if(pRepository!=NULL)
	{
		pRepository->ReadSetting(istrSettingName,&ostrSettingValue);
		pRepository->Release();
		pRepository = NULL;
	}
	else
		return FALSE;
	return TRUE;
}
//描述：设置历史记录
//输入：CATUnicodeString 文件路径 CATUnicodeString  设置名称 CATUnicodeString 设置历史记录值
//输出：CATBoolean 
//返回：CATBoolean
CATBoolean SetHistorySetting( CATUnicodeString istrRepository, CATUnicodeString istrSettingName, CATUnicodeString istrSettingValue )
{
	//cout<<"# Set History Setting"<<endl;
	CATSettingRepository *pRepository=NULL;
	pRepository=CATSettingRepository::GetRepository(istrRepository);
	if(pRepository==NULL)
	{
		cout << "# Create CATSettingRepository error !" << endl;
		return FALSE;
	}

	pRepository->WriteSetting(istrSettingName,&istrSettingValue);

	//Save the repository
	pRepository->Commit();
	pRepository->SaveRepository();

	pRepository->Release();
	pRepository = NULL;
	return TRUE;
}
//描述：跳出提示框通用
//输入：CATUnicodeString提示内容，CATUnicodeString提示类型,CATDlgStyle提示框类型
//输出：int
//返回：int
int CAAMessageBox(CATUnicodeString message,CATUnicodeString title,CATDlgStyle iStyle)
{
	int intResult = -1;
	//1= The OK button has been pressed. 
	//2= The Cancel button has been pressed. 
	//3= The Yes button has been pressed. 
	//4= The No button has been pressed. 
	//5= The Retry button has been pressed. 
	//6= The Abort button has been pressed. 
	//7= The Ignore button has been pressed. 
	CATDlgNotify* pNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), title.ConvertToChar(),iStyle);
	if (NULL != pNotifyDlg)
	{
		intResult = pNotifyDlg->DisplayBlocked(message ,title);
		pNotifyDlg->RequestDelayedDestruction(); 
		pNotifyDlg = NULL;
	}
	return intResult;
}

//描述：跳出提示框Warning
//输入：CATUnicodeString提示内容，CATUnicodeString提示类型
//输出：void
//返回：void
void MessageOutputWarning( CATUnicodeString iString,CATUnicodeString iTopString )
{
	CATApplicationFrame *pApplication = CATApplicationFrame::GetFrame(); 
	if (NULL != pApplication) 
	{
		CATDlgWindow * pMainWindow = pApplication->GetMainWindow();
		CATDlgNotify *pNotifyDlg = new CATDlgNotify(pMainWindow, "............", CATDlgNfyWarning);
		if(NULL != pNotifyDlg) 
		{
			pNotifyDlg->DisplayBlocked(iString,iTopString);
			pNotifyDlg->RequestDelayedDestruction();
		}
	}
}
//描述：跳出提示框Error
//输入：CATUnicodeString提示内容，CATUnicodeString提示类型
//输出：void
//返回：void
void MessageOutputError( CATUnicodeString iString,CATUnicodeString iTopString )
{
	CATApplicationFrame *pApplication = CATApplicationFrame::GetFrame(); 
	if (NULL != pApplication) 
	{
		CATDlgWindow * pMainWindow = pApplication->GetMainWindow();
		CATDlgNotify *pNotifyDlg = new CATDlgNotify(pMainWindow, "............", CATDlgNfyError);
		if(NULL != pNotifyDlg) 
		{
			pNotifyDlg->DisplayBlocked(iString,iTopString);
			pNotifyDlg->RequestDelayedDestruction();
		}
	}
}
//描述：跳出提示框OK与cancel
//输入：CATUnicodeString提示内容
//输出：void
//返回：CATBoolean
CATBoolean CreateMsgBoxOptOKCancel( CATUnicodeString usMsg )
{
	//cout<<"** CreatMsgBoxOptNotice:"<<usMsg.ConvertToChar()<<endl;
	CATBoolean bl=TRUE;
	CATDlgNotify* warning = new CATDlgNotify(CATApplicationFrame::GetFrame()->GetMainWindow(), "CURRENT_NOTICE", CATDlgNfyOKCancel);
	CATUnicodeString title="Notice";
	if(warning->DisplayBlocked(usMsg, title)==1)
		bl=TRUE;
	else
		bl=FALSE;
	warning->RequestDelayedDestruction();
	return bl;
}




//描述：检查路径是否存在
//输入：string路径
//输出：bool
//返回：bool
bool DirExists( const std::string& dirName_in )
{
	DWORD ftyp = GetFileAttributesA(dirName_in.c_str());
	if (ftyp == INVALID_FILE_ATTRIBUTES)
	{
		return false; 
	}

	if (ftyp & FILE_ATTRIBUTE_DIRECTORY)
	{
		return true;  
	}
	return false;
}
//描述：写入错误信息
//输入：CATUnicodeString
//输出：void
//返回：void
CATBoolean WriteErrorLog( CATUnicodeString strErrorPath,CATUnicodeString strErrorMsg )
{
	ofstream errorfile(strErrorPath.ConvertToChar(),ios::app);
	char strchar[1000];
	StringConvertToChar(strErrorMsg,strchar);
	errorfile<<(CATTime::GetCurrentLocalTime()).ConvertToString("%Y/%m/%d,%H:%M:%S")<<":"<<strchar<<"\n";
	errorfile.close();
	return TRUE;
}
//描述：添加记录功能-获取初始记录 ----目前只适用于延锋
//输入：istrFuncString功能名称
//输出：ostrUserInfo用户使用记录,oStartTime程序启动时间
//返回：HRESULT
HRESULT AddStartUsedHistory( CATUnicodeString istrFuncString,CATUnicodeString &ostrUserInfo,CATTime &oStartTime,CATUnicodeString &ostrErrorPath )
{
	HRESULT oResult = S_OK;
	ostrUserInfo = "";
	oStartTime = CATTime::GetCurrentLocalTime();
	CATUnicodeString strStartTime = oStartTime.ConvertToString("%Y/%m/%d,%H:%M:%S,%p,%A");
	CATUnicodeString strLoginName = "UnKnownLoginName";

	char strLoginNameChar[1000];
	if(CATGetLoginName(strLoginNameChar,1000) == CATLibError)
	{
		oResult = E_FAIL;
	}
	else
	{
		strLoginName = StringBuildFromChar(strLoginNameChar);
	}

	ostrUserInfo.Append(istrFuncString);
	ostrUserInfo.Append(",");
	ostrUserInfo.Append(strLoginName);
	ostrUserInfo.Append(",");
	ostrUserInfo.Append(strStartTime);
	ostrUserInfo.Append(",");

	CATUnicodeString strErrorDir = "C:\\cattmp";
	if(!DirExists(strErrorDir.ConvertToChar()))
	{
		CreateDirectory(strErrorDir,NULL) ;
	}
	ostrErrorPath.Append("C:\\cattmp\\KBEErrorLog_"); 
	ostrErrorPath.Append(istrFuncString ); 
	ostrErrorPath.Append("_"); 
	ostrErrorPath.Append(oStartTime.ConvertToString("%Y%m%d")); 
	ostrErrorPath.Append(".txt"); 

	return oResult ;
}
//描述：添加记录功能-获取剩余记录
//输入：iStartTime程序启动时间，istrBaseInfo操作命令基本信息
//输出：
//返回：void
void AddEndUsedHistory( long iStartTime,CATUnicodeString istrBaseInfo )
{
	//获取程序变量
	char* docPath = "KBETracePath";															//保存模版的环境变量名
	char* docPathValue = NULL;																//保存莫班的环境变量对应的路
	CATLibStatus envState = ::CATGetEnvValue(docPath,&docPathValue);							//获得保存模版的环境变量的值
	CATUnicodeString strUserInfoDirect = docPathValue;
	strUserInfoDirect.Append("\\KBE_Traces\\CATIA");
	if(DirExists(strUserInfoDirect.ConvertToChar()))
	{
		strUserInfoDirect.Append("\\2DTools.txt");
	}
	else
	{
		strUserInfoDirect = "C:\\ToolTestData";
		CreateDirectory(strUserInfoDirect,NULL);
		strUserInfoDirect.Append("\\2DTools.txt");
	}

	CATUnicodeString ostrUserInfo = "";
	//结束时间
	long iEndTime = 0;
	GetSYSLocalTime(iEndTime);

	CATTime currentEndTime = CATTime::GetCurrentLocalTime();
	//CATTimeSpan runtime =  currentEndTime - iStartTime;
	long SpanTime = iEndTime-iStartTime;
	if(SpanTime>=60000)
	{
		SpanTime=SpanTime/1000;
		long Longmin = SpanTime/60;
		CATUnicodeString strmin = NULL;
		strmin.BuildFromNum(Longmin);
		ostrUserInfo = istrBaseInfo;
		ostrUserInfo.Append("DurationTime: ");
		ostrUserInfo.Append(strmin);
		ostrUserInfo.Append("min");
		if((SpanTime-Longmin*60)>0)
		{
			CATUnicodeString strSec = NULL;
			strSec.BuildFromNum((SpanTime-Longmin*60));
			ostrUserInfo.Append(strSec);
			ostrUserInfo.Append("s");
		}
	}else if(SpanTime<1000)
	{
		//SpanTime = SpanTime/100;
		double dblSpanTime = SpanTime/1000.0;
		CATUnicodeString strSec = NULL;
		strSec.BuildFromNum(dblSpanTime);
		ostrUserInfo = istrBaseInfo;
		ostrUserInfo.Append("DurationTime: ");
		ostrUserInfo.Append(strSec);
		ostrUserInfo.Append("s");
	}else
	{
		SpanTime = SpanTime/1000;
		CATUnicodeString strSec = NULL;
		strSec.BuildFromNum(SpanTime);
		ostrUserInfo = istrBaseInfo;
		ostrUserInfo.Append("DurationTime: ");
		ostrUserInfo.Append(strSec);
		ostrUserInfo.Append("s");
	}

	char strchar[1000];
	StringConvertToChar(strUserInfoDirect,strchar);
	ofstream file(strchar,ios::app);
	file<<ostrUserInfo<<"\n";
	file.close(); //使用完毕之后需要关闭
}

//描述：获取系统时间
//输入：void
//输出：long 系统时间
//返回：void
void GetSYSLocalTime( long& oStartTime )
{
	SYSTEMTIME tmSys;
	::GetLocalTime(&tmSys);
	CTime tm3(tmSys);
	oStartTime = _int64(tm3.GetTime())*1000+tmSys.wMilliseconds;
}

//根据输入时间和当前时间获取持续时间
CATUnicodeString GetDurationTime(long iStartTime)
{
	CATUnicodeString ostrDurationTime = "";
	//结束时间
	long iEndTime = 0;
	GetSYSLocalTime(iEndTime);

	CATTime currentEndTime = CATTime::GetCurrentLocalTime();
	//CATTimeSpan runtime =  currentEndTime - iStartTime;
	long SpanTime = iEndTime-iStartTime;
	if(SpanTime>=60000)
	{
		SpanTime=SpanTime/1000;
		long Longmin = SpanTime/60;
		CATUnicodeString strmin = NULL;
		strmin.BuildFromNum(Longmin);
		ostrDurationTime.Append(strmin);
		ostrDurationTime.Append("min");
		if((SpanTime-Longmin*60)>0)
		{
			CATUnicodeString strSec = NULL;
			strSec.BuildFromNum((SpanTime-Longmin*60));
			ostrDurationTime.Append(strSec);
			ostrDurationTime.Append("s");
		}
	}else if(SpanTime<1000)
	{
		//SpanTime = SpanTime/100;
		double dblSpanTime = SpanTime/1000.0;
		CATUnicodeString strSec = NULL;
		strSec.BuildFromNum(dblSpanTime);
		ostrDurationTime.Append(strSec);
		ostrDurationTime.Append("s");
	}else
	{
		SpanTime = SpanTime/1000;
		CATUnicodeString strSec = NULL;
		strSec.BuildFromNum(SpanTime);
		ostrDurationTime.Append(strSec);
		ostrDurationTime.Append("s");
	}

	return ostrDurationTime;
}

//描述：char*转Unicodestring
//输入：char *
//输出：CATUnicodeString
//返回：CATUnicodeString
CATUnicodeString StringBuildFromChar( char * strchar )
{
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	wchar_t* strwcANSI = new wchar_t[len + 1]; 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
	CATUnicodeString strwcUnicode;
	strwcUnicode.BuildFromWChar(strwcANSI); 
	if(strwcANSI) delete [] strwcANSI;
	return strwcUnicode;
}

//描述：Unicodestring转char*
//输入：CATUnicodeString
//输出：char*
//返回：void
void StringConvertToChar( CATUnicodeString strUnicode,char* strchar )
{
	int len = WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, NULL, 0, NULL, NULL); 
	memset(strchar, 0, len + 1); 
	WideCharToMultiByte(CP_ACP, 0, strUnicode, -1, strchar, len, NULL, NULL); 
}
//描述：Unicodestring转wchar_t*
//输入：CATUnicodeString
//输出：wchar_t*
//返回：void
void StringConvertToWChar( CATUnicodeString strUnicode, wchar_t* strwcANSI )
{
	const char *strchar =  strUnicode.ConvertToChar();
	int len = MultiByteToWideChar(CP_ACP, 0, strchar, -1, NULL, 0); 
	memset(strwcANSI, 0, len * 2 + 2); 
	MultiByteToWideChar(CP_ACP, 0, strchar, -1, strwcANSI, len); 
}
//描述：叉积运算 
//输入：CATMathVector 第一方向，CATMathVector 第二方向
//输出：CATMathVector 运算结果(垂直方向)
//返回：HRESULT
HRESULT MathCrossProductFunc( CATMathVector iVectorFirst,CATMathVector iVectorSecond,CATMathVector& oNewVecter )
{
	oNewVecter.SetX(iVectorFirst.GetY()*iVectorSecond.GetZ() - iVectorFirst.GetZ()*iVectorSecond.GetY());
	oNewVecter.SetY(iVectorFirst.GetZ()*iVectorSecond.GetX() - iVectorFirst.GetX()*iVectorSecond.GetZ());
	oNewVecter.SetZ(iVectorFirst.GetX()*iVectorSecond.GetY() - iVectorFirst.GetY()*iVectorSecond.GetX());
	return S_OK;
}

//描述：高亮某对象
//输入：CATISpecObject对象
//输出：CATBoolean
//返回：CATBoolean
CATBoolean AddHSO( CATBaseUnknown_var ispSpecSelect )
{
	HRESULT rc=S_OK;

	CATFrmEditor * pEditor=NULL;
	pEditor = CATFrmEditor::GetCurrentEditor();
	if(pEditor==NULL)
		return FALSE;

	CATHSO * pHSO = pEditor->GetHSO();
	if(pHSO==NULL)
		return FALSE;

	if (pHSO != NULL)
		pHSO->Empty();

	if ((ispSpecSelect != NULL_var) && (pEditor != NULL) && (pHSO != NULL))
	{
		CATIBuildPath *piBuildPath = NULL;
		HRESULT rc = ispSpecSelect->QueryInterface(IID_CATIBuildPath,(void**) &piBuildPath);
		if (SUCCEEDED(rc))
		{
			CATPathElement context = pEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc = piBuildPath->ExtractPathElement(&context,&pPathElement);
			if (pPathElement != NULL)
			{
				pHSO->AddElement(pPathElement);
				pPathElement->Release();
				pPathElement = NULL;
			}
			piBuildPath->Release();
			piBuildPath = NULL;
		}
	}

	return TRUE;
}
void UpdateHSO(CATLISTV(CATISpecObject_var) LstObject,CATFrmEditor*ipEditor,CATHSO * ipHSO)
{
	HRESULT rc=E_FAIL;

	if (ipHSO)
		ipHSO->Empty();

	for (int i=1;i<=LstObject.Size();i++)
	{
		CATBaseUnknown_var ispSpecObj=LstObject[i];
		if (ispSpecObj==NULL_var)
			continue;

		CATIBuildPath *pBuildPath =NULL;
		rc=ispSpecObj->QueryInterface(IID_CATIBuildPath,(void**)&pBuildPath);
		if ( SUCCEEDED(rc)&&pBuildPath!=NULL )
		{
			CATPathElement context = ipEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc=pBuildPath->ExtractPathElement(&context,&pPathElement);

			if (pPathElement != NULL)
			{   // the geometrical element corresponding to the active field is now highlighted
				ipHSO->AddElement(pPathElement);                
				pPathElement->Release();
				pPathElement = NULL ;
			}
			pBuildPath->Release(); 
			pBuildPath = NULL ;
		}
	}
}

//描述：高亮
//输入：CATBaseUnknown_var对象,CATFrmEditor*窗口,CATHSO* HSO指针
//输出：CATBoolean
//返回：CATBoolean
void UpdateHSO( CATBaseUnknown_var ispSpecObj,CATFrmEditor*ipEditor,CATHSO * ipHSO )
{
	HRESULT rc;

	if(ispSpecObj!=NULL_var)
	{
		ipHSO->Empty();

		CATIBuildPath *pBuildPath =NULL;
		rc=ispSpecObj->QueryInterface(IID_CATIBuildPath,(void**)&pBuildPath);
		if ( SUCCEEDED(rc)&&pBuildPath!=NULL )
		{
			CATPathElement context = ipEditor->GetUIActiveObject();
			CATPathElement *pPathElement = NULL;

			rc=pBuildPath->ExtractPathElement(&context,&pPathElement);

			if (pPathElement != NULL)
			{   // the geometrical element corresponding to the active field is now highlighted
				ipHSO->AddElement(pPathElement);                
				pPathElement->Release();
				pPathElement = NULL ;
			}
			pBuildPath->Release(); 
			pBuildPath = NULL ;
		}
	}
}
//描述：清空高亮
//输入：
//输出：CATBoolean
//返回：CATBoolean
CATBoolean EmptyHSO()
{
	CATFrmEditor * pEditor=NULL;
	pEditor = CATFrmEditor::GetCurrentEditor();
	if(pEditor==NULL)
		return FALSE;

	CATHSO * pHSO = pEditor->GetHSO();
	if(pHSO==NULL)
		return FALSE;

	if (pHSO != NULL)
		pHSO->Empty();

	return TRUE;
}

//描述：获取某路径的名称
//输入：CATPathElement对象
//输出：CATUnicodeString
//返回：void
void PathElementString( CATPathElement *ipPath,CATUnicodeString &strPathName )
{
	//cout<<"==> Output String of PathElement"<<endl;
	HRESULT rc =E_FAIL;
	strPathName = "";
	int NumOfPath = ipPath->GetSize();
	for(int i=0;i<NumOfPath;i++)  
	{
		CATBaseUnknown *pElt=(*ipPath)[i];
		if(pElt != NULL) 
		{
			CATIAlias *piAlias = NULL;
			rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
			if(SUCCEEDED(rc) && piAlias!=NULL)
			{
				CATUnicodeString Name = piAlias->GetAlias();
				strPathName.Append(Name) ;
				if(i<=(NumOfPath-2)) 
				{
					strPathName.Append("/");
				}
				piAlias->Release(); piAlias = NULL;
			}
		}
	}
}

//描述：获取某路径的名称
//输入：CATFeatureImportAgent对象
//输出：CATUnicodeString
//返回：void
void PathElementString( CATFeatureImportAgent *ipFeatImpAgt,CATUnicodeString &strPathName )
{
	//cout<<"==> Output String of PathElement"<<endl;
	HRESULT rc =E_FAIL;
	//
	CATPathElement* ipPath = NULL;
	ipPath = ipFeatImpAgt->GetValue();
	//
	strPathName = "";
	int NumOfPath = ipPath->GetSize();
	for(int i=0;i<NumOfPath;i++)  
	{
		CATBaseUnknown *pElt=(*ipPath)[i];
		if(pElt != NULL) 
		{
			CATIAlias *piAlias = NULL;
			rc = pElt->QueryInterface (IID_CATIAlias, (void**) &piAlias);
			if(SUCCEEDED(rc) && piAlias!=NULL)
			{
				CATUnicodeString Name = piAlias->GetAlias();
				strPathName.Append(Name) ;
				if(i<=(NumOfPath-2)) 
				{
					strPathName.Append("/");
				}
				piAlias->Release(); piAlias = NULL;
			}
		}
	}
}

//描述：打印属性值 ----目前只适用于延锋
//输入：CATISpecObject_var 对象
//输出：void
//返回：void
void PrintAttributes( CATISpecObject_var ispSpecObject )
{
	HRESULT rc = S_OK;

	CATLISTV(CATUnicodeString) ListOfViewName;
	CATListOfDouble oListOfScale;
	CATListOfDouble oListOfOrigin; 
	CATListOfDouble oListOfVector; 
	CATListOfDouble oListOfLength; 
	CATListOfInt oListOfNumSection;
	CATListOfInt oListOfModify;
	CATListOfInt oListOfHaveCross;

	CATUnicodeString attrInfos = NULL;
	CATUnicodeString strTemp = NULL;

	//ViewName
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWViewName",ListOfViewName);
	cout<<"ViewName:"<<endl;
	attrInfos.Append("View Name = ");
	for (int i=1;i<=ListOfViewName.Size();i++)
	{
		cout<<ListOfViewName[i]<<"，";
		attrInfos.Append(ListOfViewName[i]);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//ViewScale
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWViewScale",oListOfScale);
	cout<<"ViewScale:"<<endl;
	attrInfos.Append("View Scale = ");
	for (int i=1;i<=oListOfScale.Size();i++)
	{
		cout<<oListOfScale[i]<<"，";
		strTemp.BuildFromNum(oListOfScale[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//ViewOrigin
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWViewOrigin",oListOfOrigin);
	cout<<"ViewOrigin:"<<endl;
	attrInfos.Append("View Origin = ");
	for (int i=1;i<=oListOfOrigin.Size();i++)
	{
		cout<<oListOfOrigin[i]<<"，";
		strTemp.BuildFromNum(oListOfOrigin[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//ViewVector
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWViewVector",oListOfVector);
	cout<<"ViewVector:"<<endl;
	attrInfos.Append("Viwe Vector = ");
	for (int i=1;i<=oListOfVector.Size();i++)
	{
		cout<<oListOfVector[i]<<"，";
		strTemp.BuildFromNum(oListOfVector[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//YFWNumSection
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWNumSection",oListOfNumSection);
	cout<<"oListOfNumSection:"<<endl;
	attrInfos.Append("Num Section = ");
	for (int i=1;i<=oListOfNumSection.Size();i++)
	{
		cout<<oListOfNumSection[i]<<"，";
		strTemp.BuildFromNum(oListOfNumSection[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//YFWViewModify
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWViewModify",oListOfModify);
	cout<<"ViewModify:"<<endl;
	attrInfos.Append("View Modify = ");
	for (int i=1;i<=oListOfModify.Size();i++)
	{
		cout<<oListOfModify[i]<<"，";
		strTemp.BuildFromNum(oListOfModify[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//--------------------------------------------> Section
	ListOfViewName.RemoveAll();
	oListOfScale.RemoveAll();
	oListOfOrigin.RemoveAll(); 
	oListOfVector.RemoveAll(); 
	oListOfLength.RemoveAll(); 
	oListOfModify.RemoveAll();

	//SJDSectionName
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionName",ListOfViewName);
	cout<<"SectionName:"<<endl;
	attrInfos.Append("Section Name = ");
	for (int i=1;i<=ListOfViewName.Size();i++)
	{
		cout<<ListOfViewName[i]<<"，";
		attrInfos.Append(ListOfViewName[i]);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//SJDSectionScale
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionScale",oListOfScale);
	cout<<"SectionScale:"<<endl;
	attrInfos.Append("Section Scale = ");
	for (int i=1;i<=oListOfScale.Size();i++)
	{
		cout<<oListOfScale[i]<<"，";
		strTemp.BuildFromNum(oListOfScale[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//SJDSectionOrigin
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionOrigin",oListOfOrigin);
	cout<<"SectionOrigin:"<<endl;
	attrInfos.Append("Section Origin = ");
	for (int i=1;i<=oListOfOrigin.Size();i++)
	{
		cout<<oListOfOrigin[i]<<"，";
		strTemp.BuildFromNum(oListOfOrigin[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//SJDSectionVector
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionVector",oListOfVector);
	cout<<"SectionVector:"<<endl;
	attrInfos.Append("Section Vector = ");
	for (int i=1;i<=oListOfVector.Size();i++)
	{
		cout<<oListOfVector[i]<<"，";
		strTemp.BuildFromNum(oListOfVector[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//SJDSectionLength
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionLength",oListOfLength);
	cout<<"SectionLength:"<<endl;
	attrInfos.Append("Section Length = ");
	for (int i=1;i<=oListOfLength.Size();i++)
	{
		cout<<oListOfLength[i]<<"，";
		strTemp.BuildFromNum(oListOfLength[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//YFWHaveCrossSection
	YFGetSpecObjectAttrEx(ispSpecObject,"YFWHaveCrossSection",oListOfHaveCross);
	cout<<"YFWHaveCrossSection:"<<endl;
	attrInfos.Append("YF CrossSection = ");
	for (int i=1;i<=oListOfHaveCross.Size();i++)
	{
		cout<<oListOfHaveCross[i]<<"，";
		strTemp.BuildFromNum(oListOfHaveCross[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	//SJDSectionModify
	YFGetSpecObjectAttrEx(ispSpecObject,"SJDSectionModify",oListOfModify);
	cout<<"SectionModify:"<<endl;
	attrInfos.Append("Section Modify = ");
	for (int i=1;i<=oListOfModify.Size();i++)
	{
		cout<<oListOfModify[i]<<"，";
		strTemp.BuildFromNum(oListOfModify[i]);
		attrInfos.Append(strTemp);
		attrInfos.Append(",");
	}
	cout<<endl;
	attrInfos.Append("\n");

	MessageBox(NULL,attrInfos,_T("Attributes Info"),MB_OK);
	return ;
}

//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATISpecObject_var对象
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATISpecObject_var &ospiSpecGetObj )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATISpecObject *piSpecObj;
	piSpecObj=spiMPAc->GetSpecObject(pKey);

	ospiSpecGetObj = piSpecObj;

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATBoolean属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATBoolean obBool )
{
	obBool = FALSE;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATBoolean bBool =spiMPAc->GetBoolean (pKey);

	pKey->Release();
	pKey=NULL;

	//
	obBool=bBool;

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATLISTV(CATUnicodeString属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATLISTV(CATUnicodeString) &oLstStrings )
{
	if (oLstStrings.Size()>0) 
	{
		oLstStrings.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListValCATUnicodeString* pList=spiMPAc->GetListString (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL;
	//
	oLstStrings=*pList;
	delete pList;
	pList=NULL;

	//
	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATListOfDouble属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATListOfDouble &oLstDouble )
{
	if (oLstDouble.Size()>0) 
	{
		oLstDouble.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListOfDouble* pList=spiMPAc->GetListDouble (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL; 
	//
	oLstDouble=*pList;
	delete pList;
	pList=NULL;

	//

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATListOfInt属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATListOfInt &oLstInteger )
{
	if (oLstInteger.Size()>0) 
	{
		oLstInteger.RemoveAll();
	}

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	CATListOfInt* pList=spiMPAc->GetListInteger (pKey);

	pKey->Release();
	pKey=NULL;
	if(pList==NULL)
		return E_FAIL;
	//
	oLstInteger=*pList;
	delete pList;
	pList=NULL;

	//
	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：int属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, int &oValue )
{
	oValue = 0;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	oValue=spiMPAc->GetInteger (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：double属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, double &oValue )
{
	oValue = 0;

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	oValue=spiMPAc->GetDouble (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATUnicodeString属性值
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATUnicodeString &ostrValue )
{

	ostrValue = "";

	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	ostrValue=spiMPAc->GetString (pKey);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：获取属性
//输入：CATISpecObject对象，CATUnicodeString属性名称
//输出：CATLISTV(CATISpecObject_var)对象列表
//返回：HRESULT
HRESULT YFGetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATLISTV(CATISpecObject_var) &olstSpecObj )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;
	//
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL) return E_FAIL;

	int size=spiMPAc->GetListSize(pKey);

	for (int i=1; i <= size; i++)
	{
		CATISpecObject *piSpecObj;
		piSpecObj=spiMPAc->GetSpecObject(pKey,i);
		if (piSpecObj == NULL)
		{
			return E_FAIL;
		}
		olstSpecObj.Append(CATISpecObject_var(piSpecObj));
	}

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，int属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATISpecObject_var ispiSpecSetObj )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_specobject,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetSpecObject(pKey,ispiSpecSetObj);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATBoolean属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATBoolean ibBool )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_boolean,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetBoolean(pKey,ibBool);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATLISTV(CATUnicodeString)属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATLISTV(CATUnicodeString) iLstStrings )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_string),sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetListString(pKey,iLstStrings);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATListOfDouble属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject,CATUnicodeString istrKey,CATListOfDouble iValueList )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	//创建新的属性
	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_double),sp_NEUTRAL);//sp_NEUTRAL sp_IN sp_OUT
		if(pAttr==NULL) return E_FAIL;
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}

	spiMPAc->SetListDouble(pKey,iValueList);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATListOfInt属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject,CATUnicodeString istrKey,CATListOfInt iValueList )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	//创建新的属性
	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_integer),sp_NEUTRAL);//sp_NEUTRAL sp_IN sp_OUT
		if(pAttr==NULL) return E_FAIL;
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}

	spiMPAc->SetListInteger(pKey,iValueList);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}

//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，int属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, int iValue )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_integer,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetInteger(pKey,iValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，double属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, double iValue )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_double,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetDouble(pKey,iValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATUnicodeString属性值
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATUnicodeString istrValue )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_string,sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}
	spiMPAc->SetString(pKey,istrValue);

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：设置属性
//输入：CATISpecObject对象，CATUnicodeString属性名称，CATLISTV(CATISpecObject_var)对象列表
//输出：HRESULT
//返回：HRESULT
HRESULT YFSetSpecObjectAttrEx( CATISpecObject_var ispiSpecObject, CATUnicodeString istrKey, CATLISTV(CATISpecObject_var) ilstSpecObj )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(istrKey);
	if(pAttr!=NULL)
	{
		ispiSpecObject->RemoveAttribute (pAttr);
	}

	CATISpecAttrKey* pKey=spiMPAc->GetAttrKey(istrKey);
	if(pKey==NULL)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->AddAttribute(istrKey,tk_list(tk_specobject),sp_NEUTRAL);
		if(pAttr==NULL)
		{
			return E_FAIL;
		}
		pAttr->Release();
		pAttr=NULL;
		pKey=spiMPAc->GetAttrKey(istrKey);
	}

	for (int i=1; i <= ilstSpecObj.Size(); i++)
	{
		spiMPAc->SetSpecObject(pKey,ilstSpecObj[i]);
	}

	pKey->Release();
	pKey=NULL;

	return S_OK;
}
//描述：获取视图所有属性 
//输入：CATISpecObject_var 目标对象
//输出：void
//返回：HRESULT
HRESULT YFGetSpecAttrInfo( CATISpecObject_var ispiSpecOnObject )
{
	HRESULT rc=E_FAIL;

	//Check the input parameter
	if( !ispiSpecOnObject )  return rc;

	CATISpecAttrAccess_var spiSpecAttrAccess=ispiSpecOnObject;
	CATListValCATISpecAttrKey_var listAttrKey;
	//rc = spiSpecAttrAccess->ListAttrKeys(listAttrKey);
	spiSpecAttrAccess->ListAttrKeys(listAttrKey);
	//if( FAILED(rc) || listAttrKey.Size() < 1 ) return rc;
	if( listAttrKey.Size() < 1 ) return rc;

	CATISpecAttrKey_var spiSpecAttrKey=NULL_var;
	CATAttrKind attType,attListType;
	CATUnicodeString strAttName,strValue,strValueInList;
	CATUnicodeString strAttType,strAttListType,strAttQuality;
	int number;
	CATBoolean isBRepFeature;

	for(int i=1;i<=listAttrKey.Size();i++) 
	{
		spiSpecAttrKey = listAttrKey[i];
		if( !spiSpecAttrKey ) continue;

		strAttName = spiSpecAttrKey->GetName();

		if( sp_IN == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_IN";
		else if( sp_OUT == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_OUT";
		else if( sp_NEUTRAL == spiSpecAttrAccess->GetQuality((CATISpecAttrKey *)spiSpecAttrKey) )
			strAttQuality = "sp_NEUTRAL";
		else 
			strAttQuality = "Unknown";

		attType = spiSpecAttrKey->GetType();
		strAttType = YFGetSpecAttType(attType);
		if( tk_list == attType ) {
			attListType = spiSpecAttrKey->GetListType();
			strAttListType = YFGetSpecAttType(attListType);
			strAttType = strAttType+CATUnicodeString("(")+strAttListType+CATUnicodeString(")");
			number = spiSpecAttrAccess->GetListSize(strAttName.ConvertToChar());

			strValue = "";
			for(int j=1;j<=number;j++) 
			{
				strValueInList = YFGetSpecAttrValue(spiSpecAttrAccess,strAttName,j,attListType,isBRepFeature);
				if( j == 1 )
					strValue = strValueInList;
				else
					strValue = strValue + CATUnicodeString(";")+strValueInList;
			}

			//cout << "==> Attribute Name: " << strAttName.ConvertToChar() << endl;
			//cout << "              Type: " << strAttType.ConvertToChar() << endl;
			//cout << "           Quality: " << strAttQuality.ConvertToChar() << endl;
			//cout << "         List Size: " << number << endl;
			//cout << "             Value: " << strValue.ConvertToChar() << endl;
			if(tk_specobject == attListType || tk_component == attListType) 
			{
				//if( isBRepFeature )
				//	//cout << "      BRep Feature: TRUE " << endl;
				//else
				//	//cout << "      BRep Feature: FALSE " << endl;
			}
		}
		else 
		{
			strValue = YFGetSpecAttrValue(spiSpecAttrAccess,strAttName,0,attType,isBRepFeature);
			//cout << "==> Attribute name: " << strAttName.ConvertToChar() << endl;
			//cout << "              Type: " << strAttType.ConvertToChar() << endl;
			//cout << "           Quality: " << strAttQuality.ConvertToChar() << endl;
			//cout << "             Value: " << strValue.ConvertToChar() << endl;
			if(tk_specobject == attType || tk_component == attType)
			{
				//	if( isBRepFeature )
				//		//cout << "      BRep Feature: TRUE " << endl;
				//	else
				//		//cout << "      BRep Feature: FALSE " << endl;
			}
		}
	}
	listAttrKey.RemoveAll();

	return rc;
}
//描述：获取视图属性类型 
//输入：CATAttrKind 视图属性
//输出：CATUnicodeString 视图属性类型 
//返回：CATUnicodeString
CATUnicodeString YFGetSpecAttType( CATAttrKind iAttrType )
{
	CATUnicodeString oStrType;
	if( tk_specobject == iAttrType )
		oStrType = "tk_specobject";
	else if( tk_string == iAttrType )
		oStrType = "tk_string";
	else if( tk_double == iAttrType )
		oStrType = "tk_double";
	else if( tk_integer == iAttrType )
		oStrType = "tk_integer";
	else if( tk_list == iAttrType )
		oStrType = "tk_list";
	else if( tk_boolean == iAttrType )
		oStrType = "tk_boolean";
	else if( tk_component == iAttrType )
		oStrType = "tk_component";
	else if( tk_external == iAttrType )
		oStrType = "tk_external";
	else if( tk_octet == iAttrType )
		oStrType = "tk_octet";
	else if( tk_any == iAttrType )
		oStrType = "tk_any";
	else
		oStrType = "Unknown";

	return oStrType;
}
//描述：获取属性 
//输入：CATISpecAttrAccess_var 视图属性,CATUnicodeString属性名,int位置,CATAttrKind类型
//输出：CATBoolean是否是BRep特征,CATUnicodeString 属性内容 
//返回：CATUnicodeString
CATUnicodeString YFGetSpecAttrValue( CATISpecAttrAccess_var spiSpecAttrAccess,CATUnicodeString iStrAttrName,int iIndex,CATAttrKind iAttrType,CATBoolean &oIsBRepFeature )
{
	CATUnicodeString oStrValue;
	oIsBRepFeature=FALSE;

	//Check the  input parameter
	if( !spiSpecAttrAccess || iStrAttrName.GetLengthInChar() < 1 || iIndex < 0 )  return oStrValue;

	//Get the attribute key
	CATISpecAttrKey *piAttrKey=spiSpecAttrAccess->GetAttrKey(iStrAttrName.ConvertToChar());
	if( !piAttrKey ) return oStrValue;

	CATIAlias_var spiAlias=NULL_var;
	CATBoolean valueBoolean=FALSE;
	int iValue;
	double dValue;
	CATISpecObject *piSpecValue=NULL;
	CATIMfBRep_var spiBRepObject=NULL_var;

	if( tk_specobject == iAttrType || tk_component == iAttrType ) {
		if( !iIndex )
			piSpecValue = spiSpecAttrAccess->GetSpecObject(piAttrKey);
		else
			piSpecValue = spiSpecAttrAccess->GetSpecObject(piAttrKey,iIndex);
		spiAlias = piSpecValue;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		spiBRepObject = piSpecValue;
		if( !!spiBRepObject ) { oIsBRepFeature = TRUE; }
		if( !!piSpecValue ) { piSpecValue->Release(); piSpecValue = NULL; }
	}
	else if( tk_string == iAttrType ) {
		if( !iIndex )
			oStrValue = spiSpecAttrAccess->GetString(piAttrKey);
		else
			oStrValue = spiSpecAttrAccess->GetString(piAttrKey,iIndex);
	}
	else if( tk_double == iAttrType ) {
		if( !iIndex )
			dValue = spiSpecAttrAccess->GetDouble(piAttrKey);
		else
			dValue = spiSpecAttrAccess->GetDouble(piAttrKey,iIndex);
		oStrValue.BuildFromNum(dValue);
	}
	else if( tk_integer == iAttrType ) {
		if( !iIndex )
			iValue = spiSpecAttrAccess->GetInteger(piAttrKey);
		else
			iValue = spiSpecAttrAccess->GetInteger(piAttrKey,iIndex);
		oStrValue.BuildFromNum(iValue);
	}
	else if( tk_boolean == iAttrType ) {
		if( !iIndex )
			valueBoolean = spiSpecAttrAccess->GetBoolean(piAttrKey);
		else
			valueBoolean = spiSpecAttrAccess->GetBoolean(piAttrKey,iIndex);
		if( valueBoolean )
			oStrValue = "TRUE";
		else
			oStrValue = "FALSE";
	}
	else if( tk_external == iAttrType ) {
		HRESULT rc=E_FAIL;
		CATILinkableObject *piLinkableObject=NULL;
		if( !iIndex )
			rc = spiSpecAttrAccess->GetExternalObject(piAttrKey,ANYWHERE,&piLinkableObject);
		else
			rc = spiSpecAttrAccess->GetExternalObject(piAttrKey,ANYWHERE,&piLinkableObject,iIndex);
		spiAlias = piLinkableObject;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		if( !!piLinkableObject ) { piLinkableObject->Release(); piLinkableObject = NULL; }
	}
	else if( tk_octet == iAttrType )
		oStrValue = "Octet";
	else if( tk_any == iAttrType ) {
		CATISpecAttrKey *piRealAttrKey=NULL;
		CATISpecObject_var spiSpecOnRealValue=NULL_var;
		if( !iIndex )
			piRealAttrKey = spiSpecAttrAccess->GetSpecAttribute(piAttrKey,spiSpecOnRealValue);
		else
			piRealAttrKey = spiSpecAttrAccess->GetSpecAttribute(piAttrKey,spiSpecOnRealValue,iIndex);
		spiAlias = spiSpecOnRealValue;
		if( !!spiAlias ) {
			oStrValue = spiAlias->GetAlias();  
		}
		if( !!piRealAttrKey ) { piRealAttrKey->Release(); piRealAttrKey = NULL; }
	}
	else
		oStrValue = "Unknown";

	//Release
	if( !!piAttrKey ) { piAttrKey->Release(); piAttrKey = NULL; }

	return oStrValue;
}
//描述：删除属性
//输入：CATISpecObject_var对象,CATLISTV(CATUnicodeString)要删除的属性名
//输出：无
//返回：HRESULT
HRESULT YFRemoveSpecObjectAttrEx( CATISpecObject_var ispiSpecObject,CATLISTV(CATUnicodeString) iLstStrings )
{
	if(ispiSpecObject==NULL_var) return E_FAIL;

	//添加扩展属性
	CATISpecAttrAccess_var  spiMPAc=ispiSpecObject;
	if(spiMPAc==NULL_var) return E_FAIL;

	//为了重新设置，删除原来的属性
	for (int i=1;i<=iLstStrings.Size();i++)
	{
		CATISpecAttribute* pAttr=ispiSpecObject->GetAttribute(iLstStrings[i]);
		if(pAttr!=NULL)
		{
			ispiSpecObject->RemoveAttribute (pAttr);
			pAttr->Release();
			pAttr=NULL;
		}
	}

	return S_OK;
}
//描述：获取点的最小距离 
//输入：CATLISTV(CATMathPoint) 点集合,CATMathPoint目标点
//输出：CATMathPoint 点1,CATMathPoint 点2
//返回：void
void GetTwoMinDistancePt( CATLISTV(CATMathPoint) iMathPtList,CATMathPoint imathCenterPt,CATMathPoint &omathPt1,CATMathPoint &omathPt2 )
{
	//获取第一个最近距离的点
	double mindis=1000000;
	int locate=0;
	for (int i=1;i<=iMathPtList.Size();i++)
	{
		double dis=iMathPtList[i].DistanceTo(imathCenterPt);
		if (dis<mindis)
		{
			locate=i;
			omathPt1=iMathPtList[i];
			mindis=dis;
		}
	}


	//获取第二个最近距离的点
	mindis=1000000;
	for (int i=1;i<=iMathPtList.Size();i++)
	{
		if (i==locate)
			continue;

		double dis=iMathPtList[i].DistanceTo(imathCenterPt);
		if (dis<mindis)
		{
			omathPt2=iMathPtList[i];
			mindis=dis;
		}
	}
}	

//描述：分割字符 
//输入：CATUnicodeString 要分割的字符串,CATUnicodeString 关键字符
//输出：CATListOfCATUnicodeString 分割完的字符串
//返回：CATBoolean
CATBoolean SplitString( CATUnicodeString iStrString, CATUnicodeString iStrSplit, CATListOfCATUnicodeString &oStrList )
{
	CATUnicodeString strTemp, strTemp2;
	int iLocation = iStrString.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);
	int iSize;
	strTemp = iStrString;
	while(iLocation != -1)
	{
		strTemp2 = strTemp.SubString(0, iLocation);
		oStrList.Append(strTemp2);
		iSize = strTemp.GetLengthInChar();

		strTemp2 = strTemp.SubString(iLocation+iStrSplit.GetLengthInChar(), iSize-iLocation-iStrSplit.GetLengthInChar());
		strTemp = strTemp2;
		iLocation = strTemp.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);

		if(iLocation == -1 && strTemp2 != "")
			oStrList.Append(strTemp2);
	}	

	return TRUE;
}
//描述：分割字符 
//输入：CATUnicodeString 要分割的字符串,CATUnicodeString 关键字符
//输出：CATListOfCATUnicodeString 分割完的字符串
//返回：CATBoolean
CATBoolean SplitStringUpdate( CATUnicodeString iStrString, CATUnicodeString iStrSplit, CATListOfCATUnicodeString &oStrList )
{
	if (iStrString=="")
	{
		return FALSE;
	}
	CATUnicodeString strTemp, strTemp2;
	int iLocation = iStrString.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);
	int iSize;
	strTemp = iStrString;
	while(iLocation != -1)
	{
		strTemp2 = strTemp.SubString(0, iLocation);
		oStrList.Append(strTemp2);
		iSize = strTemp.GetLengthInChar();

		strTemp2 = strTemp.SubString(iLocation+iStrSplit.GetLengthInChar(), iSize-iLocation-iStrSplit.GetLengthInChar());
		strTemp = strTemp2;
		iLocation = strTemp.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);

		//if(iLocation == -1 && strTemp2 != "")
		//	oStrList.Append(strTemp2);
	}

	oStrList.Append(strTemp);

	return TRUE;
}
//描述：获取对象的名字
//输入：const CATBaseUnknown_var 目标对象
//输出：CATUnicodeString 名字
//返回：CATUnicodeString
CATUnicodeString GetSpecBasicName(const CATBaseUnknown_var &CurrentSpec)
{
	CATUnicodeString BasicName; 
	CATIAlias_var aliasftr  = CurrentSpec ;
	CATISpecObject_var Spec = CurrentSpec  ;
	if (aliasftr != NULL_var)
	{
		BasicName = aliasftr->GetAlias();
	}
	else if (Spec != NULL_var) 
	{
		BasicName = Spec->GetDisplayName();
	}
	if (BasicName == ""  &&  Spec != NULL_var)
	{
		BasicName = Spec->GetName();
	}
	return BasicName ;
}
//描述：刷新结构树 *****移动到3D
//输入：CATISpecObject_var 目标根节点
//输出：void
//返回：void
void UpdateTreeAndRedraw( CATISpecObject_var  ispSpec )
{
	if(ispSpec == NULL_var) return;
	ispSpec->Update();

	CATIModelEvents_var spModel = ispSpec;
	CATModify notif(ispSpec);
	if (spModel != NULL_var) 
	{
		spModel->Dispatch(notif);
	}

	CATIRedrawEvent_var spRedraw = ispSpec;
	if(spRedraw != NULL_var) 
	{
		spRedraw->Redraw();
	}
}
//描述：添加元素 *****移动到3D
//输入：CATISpecObject_var插入目标,CATISpecObject_var要插入的对象,CATUnicodeString对象名字,CATBoolean是否隐藏
//输出：void
//返回：HRESULT
HRESULT AppendObject(CATISpecObject_var spSpecFather,
					 CATISpecObject_var spSpecChild,
					 CATUnicodeString strNameForObject,
					 CATBoolean iShowOrHide)
{
	if (NULL_var == spSpecFather || NULL_var == spSpecChild)
	{
		return E_FAIL;
	}
	CATIDescendants_var spDescdt = spSpecFather;
	if (NULL_var == spDescdt)
	{
		return E_FAIL;
	}
	CATIAlias_var spAlias = NULL_var;
	spAlias = spSpecChild;
	if (NULL_var!=spAlias && strNameForObject != "")
	{
		spAlias->SetAlias(strNameForObject);
	}
	if (NULL_var!=spAlias && strNameForObject != "")
	{
		HideSpecObject(spSpecChild,  iShowOrHide);
	}
	spDescdt->Append(spSpecChild);
	UpdateTreeAndRedraw(spSpecChild);
	UpdateTreeAndRedraw(spSpecFather);
	return S_OK;
}
//描述：修改元素名称
//输入：CATISpecObject_var要修改的元素,CATUnicodeString修改后的名字
//输出：void
//返回：HRESULT
HRESULT SetObjectName( CATISpecObject_var spObj, CATUnicodeString objectName)
{
	if ( objectName != "" ) 
	{ 
		CATIAlias_var spAlias = spObj;
		if (NULL_var!=spAlias)
		{
			spAlias->SetAlias(objectName);
			return S_OK;
		}
	}
	return E_FAIL;
}
//描述：获取当前窗口文档名称
//输入：void
//输出：CATUnicodeString 文档完整名称
//返回：CATUnicodeString 文档名称
CATUnicodeString GetDocumentNameFunc(const CATUnicodeString &strDrawingFullName)
{
	CATUnicodeString strRst = "";
	int intLen = strDrawingFullName.GetLengthInChar();
	int intPos =  strDrawingFullName.SearchSubString("\\", 0, CATUnicodeString::CATSearchMode::CATSearchModeBackward);
	if(intPos == -1)
	{
		strRst = strDrawingFullName;
	}
	else
	{
		strRst = strDrawingFullName.SubString(intPos + 1,intLen - 1 - intPos);
	}

	int intPos2 =  strRst.SearchSubString(".", 0, CATUnicodeString::CATSearchMode::CATSearchModeBackward);
	if(intPos2 >= 0)
	{
		strRst = strRst.SubString(0,intPos2);
	}
	return strRst;
}

//描述:获取进程ID
//输入:void
//输出:void
//返回:vector<int>-进程号容器
vector<int> GetExcelProcessIdFunc()
{
	vector<int> pIDVec;
	setlocale(LC_ALL, "");
	HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    //建立进程快照

	if (INVALID_HANDLE_VALUE == hProcess)
	{
		CAAMessageBox("Failure to obtain excel process","Notice",CATDlgNfyOK);
		return pIDVec;
	}

	//成功获取进程信息
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	BOOL moreProc = Process32First(hProcess, &pe32);

	while (moreProc)   //枚举所有进程
	{
		WCHAR* pName = pe32.szExeFile;
		char pID[20] = "";

		_ultoa(pe32.th32ProcessID, pID, 10);  

		int nLen = WideCharToMultiByte( CP_ACP, 0,pName, -1, NULL, 0, NULL, NULL );   
		char* pResult = new char[nLen];  
		WideCharToMultiByte( CP_ACP, 0, pName, -1, pResult, nLen, NULL, NULL );  

		CATUnicodeString pIdNum(pID);
		CATUnicodeString pExeName(pResult);
		int IdNum = 0;
		pIdNum.ConvertToNum(&IdNum);
		if (pExeName == "EXCEL.EXE")
		{
			pIDVec.push_back(IdNum);
		}

		moreProc = Process32Next(hProcess, &pe32);
	}

	CloseHandle(hProcess);        //释放进程快照
	return pIDVec;
}

//描述：旋转2d点
//输入：double[2] 要旋转的点,double旋转角度
//输出：double[2] 旋转后的点
//返回：void
void Rotate2DPointFunc(double OrinPoint[2],double NewPoint[2],double Angle)
{
	//Angle是弧度：比如20度 angle = 20 / 180 * 3.14
	//视图的旋转是顺时针方向为负值
	NewPoint[0] = OrinPoint[0] * cos(-Angle) + OrinPoint[1] * sin(-Angle);
	NewPoint[1] = OrinPoint[1] * cos(-Angle) - OrinPoint[0] * sin(-Angle);
}

//描述：关闭后台excel进程
//输入：iOldPid-程序运行前进程号,iNewPid-程序运行后进程号
//输出：void
//返回：void
void RemoveExcelProcessFunc(vector<int> iOldPid,vector<int> iNewPid)
{
	//定义需要关闭的excel的新容器
	vector<int> excelNeedClose;

	//遍历不同pid，单独放入一个这个新容器
	//case 1:2个容器都不为空
	if (iOldPid.size() != 0 && iNewPid.size() != 0)
	{
		for (int i = 0;i<iNewPid.size();i++)
		{
			int flag = 0;
			for (int j = 0;j<iOldPid.size();j++)
			{
				if (iNewPid[i] == iOldPid[j])
				{
					flag = 1;
					break;
				}
			}

			if (flag == 0)
			{
				excelNeedClose.push_back(iNewPid[i]);
			}
		}
	}
	//case 2:程序运行excel前，并没有excel运行
	if (iOldPid.size() == 0 && iNewPid.size() != 0) excelNeedClose.assign(iNewPid.begin(),iNewPid.end());

	//case 3:并没有运行excel
	if (iOldPid.size() == 0 && iNewPid.size() == 0) return ;

	//关闭excel
	if (excelNeedClose.size()!=0)
	{
		for (int i = 0;i<excelNeedClose.size();i++)
		{
			//cout<<excelNeedClose[i]<<endl;
			HANDLE hprocess=::OpenProcess(PROCESS_ALL_ACCESS,FALSE,excelNeedClose[i]);
			if(hprocess!=NULL)
			{
				::TerminateProcess(hprocess,0);
				::CloseHandle(hprocess);
			}
		}
	}
	return ;
}

//描述：对象添加高亮 VB接口
//输入：CATBaseUnknown_var高亮对象,bool是否清空
//输出：void
//返回：HRESULT
HRESULT AddHightlightFor2DObject(CATBaseUnknown_var spSpecObj,bool empty)
{
	HRESULT returnRC = E_FAIL;

	CATISpecObject_var spSpecObject = spSpecObj;
	if(NULL_var == spSpecObject)
		return returnRC;

	CATFrmEditor* pEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pEditor)
		return returnRC;

	CATDocument * pDrwDoc = pEditor -> GetDocument();
	if (pDrwDoc!=NULL)
	{
		CATIADocument *pCATIADoc = NULL;
		HRESULT rc = pDrwDoc->QueryInterface(IID_CATIADocument,(void**)&pCATIADoc);
		if (pCATIADoc!=NULL)
		{
			CATIASelection *oSelection = NULL;
			pCATIADoc->get_Selection(oSelection);
			if (oSelection!=NULL)
			{
				if(empty == true)
				{
					oSelection->Clear();
				}
				CATIABase *iObject = NULL;
				rc = spSpecObject->QueryInterface(IID_CATIABase,(void**)&iObject);
				if (SUCCEEDED(rc) && iObject!=NULL)
				{
					oSelection->Add(iObject);
					returnRC = S_OK;
					iObject->Release();
					iObject=NULL;
				}
			}
			pCATIADoc->Release();
			pCATIADoc=NULL;
		}

	}
	return returnRC;
}

//描述：读取txt文本并进行排序
//输入：CATUnicodeString文件路径
//输出：CATListOfCATUnicodeString（字符排序List）
//返回：
void ReadTxtFileAndRankStringFunc( CATUnicodeString strFileName,
								  CATListOfCATUnicodeString& oAlphabeticalOrderLst)
{
	//step1：获取TXT文件路径
	//CATUnicodeString strResourcePath = GetTxtResourcePath(strOEM,strFileName);
	if (strFileName == NULL)
	{
		return;
	}
	CATUnicodeString strResourcePath = strFileName;
	CATUnicodeString strTxtFile = NULL;
	//step2：获取TXT文件内容
	string arryTxtFile[10000];
	int i=0;
	ifstream infile;
	infile.open(strResourcePath.ConvertToChar());
	if (!infile.is_open())
	{
		return;
	}
	while(!infile.eof())
	{
		getline(infile,arryTxtFile[i],'\n');
		i++;
	}
	for (int j=0;j<i;j++)
	{
		const char* charTxtFile = arryTxtFile[j].c_str();
		CATUnicodeString str = charTxtFile;
		strTxtFile+=str;
	}
	infile.close();
	//step3:分割字符
	SplitString(strTxtFile,";",oAlphabeticalOrderLst);
}
//描述：获取系统时间
//输入：void
//输出：CATUnicodeString 
//返回：CATUnicodeString 系统时间
CATUnicodeString GetStrCurrentLocalTime()
{
	CATTime date = CATTime::GetCurrentLocalTime();
	int Year =date.GetYear();
	int Month = date.GetMonth();
	int Day = date.GetDay();
	int Hour = date.GetHour();
	int Minute = date.GetMinute();
	int Second = date.GetSecond();
	CATUnicodeString StrTime ;
	CATUnicodeString Strdata;
	StrTime.BuildFromNum(Year);
	Strdata += StrTime;
	StrTime.BuildFromNum(Month);
	Strdata += StrTime;
	StrTime.BuildFromNum(Day);
	Strdata += StrTime;
	StrTime.BuildFromNum(Hour);
	Strdata += StrTime;
	StrTime.BuildFromNum(Minute);
	Strdata += StrTime;
	StrTime.BuildFromNum(Second);
	Strdata += StrTime;

	return Strdata;
}
//描述：根据输入的原点和三个方向，获取该局部坐标系下的iso view视角
//输入：double 原点，double X轴方向，double Y轴方向，double Z轴方向
//输出：double iso视角方向，double iso视角水平方向，double iso视角竖直方向
//返回：HRESULT
HRESULT GetIsoViewDirection(double iarrOrigin[3],
							double iarrDirX[3],
							double iarrDirY[3],
							double iarrDirZ[3],
							double oarrIsoDir[3],
							double oarrHDir[3],
							double oarrVDir[3])
{
	HRESULT rc = S_OK;
	double arrMove[3];
	D3PointMove(iarrOrigin,iarrDirX,arrMove);
	D3PointMove(arrMove,iarrDirY,arrMove);
	D3PointMove(arrMove,iarrDirZ,arrMove);
	D3VectorSetFromTwoPoint(iarrOrigin,arrMove,oarrIsoDir);
	//计算竖直方向
	double temp[3];
	D3CrossProduct(iarrDirZ,oarrIsoDir,temp);
	D3CrossProduct(oarrIsoDir,temp,oarrVDir);
	//计算水平方向
	D3CrossProduct(oarrVDir,oarrIsoDir,oarrHDir);
	//
	D3VectorUnit(oarrIsoDir,oarrIsoDir);
	D3VectorUnit(oarrHDir,oarrHDir);
	D3VectorUnit(oarrVDir,oarrVDir);
	return rc;
}
//描述：窗体跳转
//输入：CATDocument*目标文档
//输出：void
//返回：HRESULT
HRESULT JumpToAnotheerWIndowsFunc( CATDocument* opDoc )
{
	HRESULT rc = S_OK;

	CATFrmLayout *pLayout =CATFrmLayout::GetCurrentLayout();
	CATLISTP(CATFrmWindow) listOfCurWindows = pLayout->GetWindowList();
	for (int i=1; i<=listOfCurWindows.Size(); i++)
	{
		CATFrmEditor* pEditor= listOfCurWindows[i]->GetEditor();
		if (pEditor == NULL)
		{
			continue;
		}
		CATDocument *pDoc = pEditor->GetDocument();
		if (pDoc == NULL)
		{
			continue;
		}
		CATUnicodeString strThisDocPath;
		strThisDocPath = pDoc->StorageName();
		CATUnicodeString istrPath;
		istrPath = opDoc->StorageName();
		if(strThisDocPath == istrPath)
		{
			pLayout->SetCurrentWindow(listOfCurWindows[i]);
			return S_OK;
		}
	}
	return E_FAIL;
}
//描述：关闭文件
//输入：CATDocument*文档
//输出：无
//返回：HRESULT
HRESULT CloseDocEditFunc( CATDocument* opDoc )
{
	if(NULL == opDoc)
	{
		return E_FAIL;
	}
	HRESULT rc = S_OK;
	//设置服务
	CATSession * pSession = CATSession::GetPtrSession();
	if (pSession==NULL)
	{
		cout<<"General Table Can Not Found"<<endl;
		return E_FAIL;
	}
	CATIIniInteractiveSession* pInteractiveSession = NULL;
	rc=pSession->QueryInterface(IID_CATIIniInteractiveSession, (void **) &pInteractiveSession);
	if (FAILED(rc)||pInteractiveSession==NULL)
	{
		cout<<"Get CATIIniInteractiveSession Failed"<<endl;
		return E_FAIL;
	}
	//寻找文档
	CATFrmLayout *pLayout =CATFrmLayout::GetCurrentLayout();
	CATLISTP(CATFrmWindow) listOfCurWindows = pLayout->GetWindowList();
	for (int i=1; i<=listOfCurWindows.Size(); i++)
	{
		CATFrmEditor* pEditor= listOfCurWindows[i]->GetEditor();
		if (pEditor == NULL)
		{
			continue;
		}
		CATDocument *pDoc = pEditor->GetDocument();
		if (pDoc == NULL)
		{
			continue;
		}
		if(pDoc == opDoc)
		{
			CATIEditor * pEditor = NULL;
			opDoc->QueryInterface(IID_CATIEditor,(void**)&pEditor);
			if(NULL == pEditor)
			{
				return E_FAIL;
			}
			//pEditor->CloseWindowFromEditor();
			pInteractiveSession->Close(pEditor);
			return S_OK;
		}
	}
	return E_FAIL;
}

//描述：获取文本的内容
//输入：CATUnicodeString文件路径
//输出：CATListOfCATUnicodeString文本的内容
//返回：HRESULT
HRESULT GetTextInfor( CATUnicodeString strFileName,CATListOfCATUnicodeString& Lst )
{
	HRESULT rc = S_OK;

	//打开文件
	CATUnicodeString strFilePath = "";
	strFilePath = strFileName;

	ifstream input;
	const char* chPath = strFilePath.ConvertToChar();
	input.open(chPath);
	string strLine;
	CATUnicodeString strUniLine;
	while (getline(input,strLine))
	{
		const char *psz = strLine.c_str();
		char *buf = new char[strlen(psz)+1];
		strcpy(buf, psz);
		strUniLine=buf;
		Lst.Append(strUniLine);
	}
	input.close();
	return rc;
}

//描述：跳出提示框Info
//输入：CATUnicodeString提示内容，CATUnicodeString提示类型
//输出：void
//返回：void
void MessageOutputInfo( CATUnicodeString iString,CATUnicodeString iTopString )
{
	CATApplicationFrame *pApplication = CATApplicationFrame::GetFrame(); 
	if (NULL != pApplication) 
	{
		CATDlgWindow * pMainWindow = pApplication->GetMainWindow();
		CATDlgNotify *pNotifyDlg = new CATDlgNotify(pMainWindow, "............", CATDlgNfyInformation);
		if(NULL != pNotifyDlg) 
		{
			pNotifyDlg->DisplayBlocked(iString,iTopString);
			pNotifyDlg->RequestDelayedDestruction();
		}
	}
}

//描述：复制粘贴
//输入：CATISpecObject_var复制对象,CATISpecObject_var复制地点,CATBoolean是否保留连接
//输出：HRESULT
//返回：HRESULT
HRESULT CopyPasteSpecObject( CATISpecObject_var ispiSpecOnChild,CATISpecObject_var ispiSpecOnNewFather,CATBoolean iLink )
{
	HRESULT rc=E_FAIL;

	if( !ispiSpecOnChild || !ispiSpecOnNewFather ) return rc;

	CATMmrInterPartCopy *actionCP=new CATMmrInterPartCopy(ispiSpecOnChild,ispiSpecOnNewFather);
	if( !actionCP ) return rc;

	int iMode=3; // Copy attribute and color
	rc = actionCP->SetAttributeMode(iMode);
	rc = actionCP->SetLinkMode(iLink);

	CATUnicodeString erroMessage;
	rc = actionCP->Run(&erroMessage);
	if( FAILED(rc) )
	{
		cout << "==> Error in Run CopyPaste: " << erroMessage.ConvertToChar() << endl;
		return rc;
	}

	CATISpecObject_var spiSpecResult=NULL_var;
	rc = actionCP->GetResult(spiSpecResult);

	CATIAlias_var spiSourceAlias=ispiSpecOnChild;
	CATIAlias_var spiTargetAlias=spiSpecResult;

	CATUnicodeString specAlias;
	if( !!spiSourceAlias )
		specAlias = spiSourceAlias->GetAlias();
	if( !!spiTargetAlias )
		spiTargetAlias->SetAlias(specAlias);

	//spiSpecResult->Update();

	ispiSpecOnNewFather->Update();

	delete actionCP;  actionCP = NULL;

	return rc;
}
//描述：删除数字字符串末尾的0
//输入：CATUnicodeString 字符串
//输出：CATUnicodeString 字符串
//返回：
void RemoveLastZeroesFromString( CATUnicodeString &ioString )
{
	if (-1 != ioString.SearchSubString("."))	//先判断字符串中是否含有小数点
	{
		CATUnicodeChar zero('0');
		CATUnicodeChar dot('.');
		int iRemoveCharNum = 0;
		int iLength = ioString.GetLengthInChar();
		for (size_t i=iLength-1;i>=0;i--)
		{
			CATUnicodeChar chValue = ioString[i];
			if (chValue == zero)
			{
				iRemoveCharNum++;
			}
			else if (chValue == dot)
			{
				iRemoveCharNum++;
				break;
			}
			else
			{
				break;
			}
		}
		ioString = ioString.SubString(0,iLength-iRemoveCharNum);
	}
}

//描述：数组拷贝
//输入：double 数组
//输出：double 拷贝后的数组
//返回：void
void D2ArrayCopy(double inArray[2],double returnArray[2])
{
	for(int i=0;i<2;i++)
	{
		returnArray[i] = inArray[i];
	}
}
//描述：2D向量单位化
//输入：double 向量单位化的数组
//输出：double 向量单位化后新数组
//返回：void
void D2VectorUnit(double vec[2],double returnArray[2])
{
	double num = D2VectorLen(vec);
	if (num == 0)
	{
		returnArray[0] = 0;
		returnArray[1] = 0;
	}
	else
	{
		returnArray[0] = (vec[0] / num);
		returnArray[1] = (vec[1] / num);
	}
}
//描述：计算角度
//输入：double 数组 double比例
//输出：double 计算后的数组
//返回：void
void D2VectorScal(double vec[2],double scal,double returnArray[2])
{
	returnArray[0] = vec[0] * scal;
	returnArray[1] = vec[1] * scal;
}
//描述：计算长度
//输入：double 数组
//输出：double
//返回：double 数组
double D2VectorLen(double vec[2])
{
	return sqrt((pow(vec[0],2) + pow(vec[1],2)));
}
//描述：移动2D点
//输入：double 点坐标 double向量
//输出：double 结果数组
//返回：void
void D2PointMove(double point[2],double vec[2],double returnArray[2] )
{
	returnArray[0] = (point[0] + vec[0]);
	returnArray[1] = (point[1] + vec[1]);
}
//描述：通过两点计算向量
//输入：double 点1  double 点2
//输出：double 结果数组
//返回：void
void D2VectorSetFromTwoPoint(double P1[2],double P2[2],double returnArray[2])
{
	returnArray[0] = (P2[0] - P1[0]);
	returnArray[1] = (P2[1] - P1[1]);
}
//描述：2D向量减
//输入：double  点1  double 点2
//输出：double 结果数组
//返回：void
void D2VectorReduce(double v1Reduced[2],double v2[2],double returnArray[2])
{
	returnArray[0] = v1Reduced[0] - v2[0];
	returnArray[1] = v1Reduced[1] - v2[1];
}
//描述：计算向量之间距离
//输入：double 点1  double 点2
//输出：double
//返回：double 结果数组
double D2PointDistance(double point1[2],double point2[2])
{
	double vec[2] = {0.0,0.0};
	D2VectorSetFromTwoPoint(point1,point2,vec);
	return D2VectorLen(vec);
}
//描述：获取中点
//输入：double 点1  double 点2
//输出：double 结果数组
//返回：void
void D2GetMidPoint(double P1[2],double P2[2],double returnArray[2])
{
	double P3[2] = {0.0,0.0};
	D2VectorSetFromTwoPoint(P1,P2,P3);

	double P4[2] = {0.0,0.0};
	D2VectorScal( P3,0.5,P4);

	D2VectorSum(P1,P4,returnArray);
}
//描述：计算向量和
//输入：double 点1  double 点2
//输出：double 结果数组
//返回：void
void D2VectorSum(double v1[2],double v2[2],double returnArray[2])
{
	returnArray[0] = v1[0] + v2[0];
	returnArray[1] = v1[1] + v2[1];
}

//描述：计算出ISO视角
//输入：
//输出：
//返回：CATMathPlane
CATMathPlane GetAbsIsoViewDirection()
{ 
	CATMathPoint eyept(0.0,0.0,0.0);
	CATMathVector axisx(1.0,0.0,0.0);
	CATMathVector axisy(0.0,1.0,0.0);
	CATMathVector axisz(0.0,0.0,1.0);
	CATMathVector eyedir =  -axisx  -axisy - axisz;
	CATMathVector viewmatx = axisy - axisx;
	CATMathVector viewmaty = viewmatx ^ eyedir;
	viewmatx.Normalize();
	viewmaty.Normalize();
	return CATMathPlane(eyept,viewmatx,viewmaty);
}

//*******************************************************************************************************************************
//*******************************************************************************************************************************
//***********************************************二维和三维向量运算的数学方法****************************************************
//*******************************************************************************************************************************
//*******************************************************************************************************************************
//以下是纯数学运算
//描述：直线相交
//输入：double 第一条线的点1 double 第一条线的点2 double 第二条线的点1 double 第二条线的点2
//输出：
//返回：double 结果数组
bool D3LinesGetCrossPoint(double line1P1[3],double line1P2[3],double line2P1[3],double line2P2[3],double returnArray[3])
{
	double numArray[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line1P2,numArray);
	double numArray2[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line2P1,line2P2,numArray2);
	double numArray3[3] = {0.0,0.0,0.0};
	double numArray4[3] = {0.0,0.0,0.0};
	if (D3VectorsParallel(numArray,numArray2))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P1,numArray4);
		double num = D3PointDistance(numArray3,numArray4);
		if (D3PointDistance(line1P1,line2P2) <= num)
		{
			D3ArrayCopy(line1P1,numArray3);
			D3ArrayCopy(line2P2,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		if (D3PointDistance(line1P2,line2P1) <= num)
		{
			D3ArrayCopy(line1P2,numArray3);
			D3ArrayCopy(line2P1,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		if (D3PointDistance(line1P2,line2P2) <= num)
		{
			D3ArrayCopy(line1P2,numArray3);
			D3ArrayCopy(line2P2,numArray4);
			num = D3PointDistance(numArray3,numArray4);
		}
		D3GetMidPoint(numArray3,numArray4,returnArray);
		return false;
	}

	if ((D3PointDistance(line1P1,line2P1) <= offsettolerance) || (D3PointDistance(line1P1,line2P2) <= offsettolerance))
	{
		D3ArrayCopy(line1P1,returnArray);
		return true;
	}
	if ((D3PointDistance(line1P2,line2P1) <= offsettolerance) || (D3PointDistance(line1P2,line2P2) <= offsettolerance))
	{
		D3ArrayCopy(line1P2,returnArray);
		return true;
	}

	D3ArrayClear(numArray3);
	D3ArrayClear(numArray4);
	double numArray5[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P1,numArray5);
	double numArray6[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P2,numArray6);
	double numArray7[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P2,line2P1,numArray7);
	if (!(D3VectorsParallel(numArray,numArray5 ) || D3VectorsParallel(numArray2,numArray5)))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P1,numArray4);
	}
	else if (!(D3VectorsParallel(numArray,numArray6) || D3VectorsParallel(numArray2,numArray6)))
	{
		D3ArrayCopy(line1P1,numArray3);
		D3ArrayCopy(line2P2,numArray4);
	}
	else if (!(D3VectorsParallel(numArray,numArray7) || D3VectorsParallel(numArray2,numArray7)))
	{
		D3ArrayCopy(line1P2,numArray3);
		D3ArrayCopy(line2P1,numArray4);
	}
	else
	{
		D3ArrayCopy(line1P2,numArray3);
		D3ArrayCopy(line2P2,numArray4);
	}
	double vectoProjected[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(numArray3,numArray4,vectoProjected);
	double numArray0[3] = {0.0,0.0,0.0};
	D3VectorGetProjectY(vectoProjected,numArray,numArray0);
	double d = D3VectorAngle(numArray2,numArray0);
	double numArray8[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray2,numArray8);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorScal(numArray8,(D3VectorLen(numArray0) / cos(d)),vec);
	double numArray9[3] = {0.0,0.0,0.0};
	D3VectorScal(vec,-1,numArray9);
	D3PointMove(numArray4,numArray9,returnArray);
	if(abs(D3PointDistance(returnArray,line1P1) + D3PointDistance(returnArray,line1P2) - D3PointDistance(line1P1,line1P2))<=0.001)
	{
		return true;
	}
	else
	{
		return false;
	}

}
//描述：计算角度
//输入：double 计算数组
//输出：
//返回：double 结果数组
double D3AngleNew(double a1)
{
	a1 = a1 - int(a1 / (mathPi * 2)) * (mathPi * 2);
	if (a1 < 0)
	{
		a1 = ((mathPi * 2) + a1);
	}
	return a1;
}
//描述：计算两点距离
//输入：double 点1 double点2
//输出：
//返回：double 结果数组
double D3PointDistance(double point1[3],double point2[3])
{
	double vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(point1,point2,vec);
	return D3VectorLen(vec);
}
//描述：通过两点计算向量
//输入：double 点1 double点2
//输出：double 结果数组
//返回：void
void D3VectorSetFromTwoPoint(double P1[3],double P2[3],double returnArray[3])
{
	returnArray[0] = (P2[0] - P1[0]);
	returnArray[1] = (P2[1] - P1[1]);
	returnArray[2] = (P2[2] - P1[2]);
}
//描述：计算向量的长度
//输入：double 点坐标数组
//输出：
//返回：double
double D3VectorLen(double vec[3])
{
	return sqrt(((pow(vec[0],2) + pow(vec[1],2)) + pow(vec[2],2)));
}
//描述：数组拷贝
//输入：double 要拷贝的数组
//输出：double 拷贝后的数组
//返回：void
void D3ArrayCopy(double inArray[3],double returnArray[3])
{
	for(int i=0;i<3;i++)
	{
		returnArray[i] = inArray[i];
	}
}
//描述：清空一个数组
//输入：double 要清空的数组
//输出：
//返回：void
void D3ArrayClear(double inArray[3])
{
	for(int i=0;i<3;i++)
	{
		inArray[i] = 0.0 ;
	}
}
//描述：平行向量
//输入：double 向量1 double向量2
//输出：
//返回：bool
bool D3VectorsParallel(double vec1[3],double vec2[3] )
{
	double num = D3VectorAngle(vec1,vec2);
	return ((abs(num - 0.0) <= offsettolerance) || (abs(num - mathPi) <= offsettolerance));
}
//描述：计算3D向量角度
//输入：double
//输出：
//返回：double
double D3VectorAngle(double v1[3],double v2[3])
{
	double d = (D3DotProduct(v1,v2) / (D3VectorLen(v1) * D3VectorLen(v2)));
	if (abs(d + 1) < offsettolerance)
	{
		return mathPi;
	}
	if (abs(d - 1) < offsettolerance)
	{
		return 0.0;
	}
	return acos(d);
}
//描述：点积
//输入：double 点1 double 点2
//输出：
//返回：double
double D3DotProduct(double v1[3],double v2[3])
{
	return (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
}
//描述：取两个3D点的中点
//输入：double 点1 double 点2
//输出：double 结果数组
//返回：void
void D3GetMidPoint(double P1[3],double P2[3],double returnArray[3])
{
	double numArray1[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(P1,P2,numArray1);

	double numArray2[3] = {0.0,0.0,0.0};
	D3VectorScal( numArray1,0.5,numArray2);

	D3PointMove(P1,numArray2,returnArray);
}
//描述：通过比例控制向量大小
//输入：double 向量 double 比例
//输出：double 结果数组
//返回：void
void D3VectorScal(double vec[3],double scal,double returnArray[3])
{
	returnArray[0] = (vec[0] * scal);
	returnArray[1] = (vec[1] * scal); 
	returnArray[2] = (vec[2] * scal);
}
//描述：移动3D点
//输入：double 点  double 向量  
//输出：double 结果数组
//返回：void
void D3PointMove(double point[3],double vec[3],double returnArray[3])
{
	returnArray[0] = (point[0] + vec[0]);
	returnArray[1] = (point[1] + vec[1]);
	returnArray[2] = (point[2] + vec[2]);
}
//描述：3D点通过Y向获得一条向量
//输入：double 点  double 方向
//输出：double 结果数组
//返回：void
void D3VectorGetProjectY(double vectoProjected[3],double vecAxis[3],double returnArray[3])
{
	double numArray[3] = {0.0,0.0,0.0};
	D3VectorGetProjectX(vectoProjected,vecAxis,numArray);
	D3VectorReduce(vectoProjected,numArray,returnArray);
}
//描述：3D点通过X向获得一条向量
//输入：double 点  double 方向
//输出：double 结果数组
//返回：void
void D3VectorGetProjectX(double vectoProjected[3],double vecAxis[3],double returnArray[3])
{
	double scal = (D3DotProduct(vecAxis,vectoProjected) / D3VectorLen(vecAxis));
	double numArray1[3] = {0.0,0.0,0.0};
	D3VectorUnit(vecAxis,numArray1);
	D3VectorScal(numArray1,scal,returnArray);
}
//描述：3D向量减
//输入：double 点1 double 点2
//输出：double 结果数组
//返回：void
void D3VectorReduce(double v1Reduced[3],double v2[3],double returnArray[3])
{
	returnArray[0] = v1Reduced[0] - v2[0];
	returnArray[1] = v1Reduced[1] - v2[1];
	returnArray[2] = v1Reduced[2] - v2[2];
}
//描述：3D向量单位化
//输入：double 向量
//输出：double 结果数组
//返回：void
void D3VectorUnit(double vec[3],double returnArray[3])
{
	double num = D3VectorLen(vec);
	if (num == 0.0)
	{
		returnArray[0] = 0.0;
		returnArray[1] = 0.0;
		returnArray[2] = 0.0;
	}
	else
	{
		returnArray[0] = vec[0] / num;
		returnArray[1] = vec[1] / num;
		returnArray[2] = vec[2] / num;
	}
}
//描述：3D向量旋转
//输入：double 向量  double 向量 double角度
//输出：double 结果数组
//返回：void
void D3VectorRotate(double vs[3],double vnormal[3],double ang,double returnArray[3])
{
	ang = D3AngleNew(ang);
	double numArray[3] = {0.0,0.0,0.0};
	double numArray4[3] = {0.0,0.0,0.0};
	D3CrossProduct(vs,vnormal,numArray4);
	double numArray5[3] = {0.0,0.0,0.0};
	D3VectorSymmetric(numArray4,numArray5);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray5,vec);
	double numArray3[3] = {0.0,0.0,0.0};
	if (ang == 0.0)
	{
		D3ArrayCopy(vs,returnArray);
		return ;
	}
	if (ang == (mathPi / 2))
	{
		D3VectorScal(vec,D3VectorLen(vs),returnArray);
		return ;
	}
	if (ang == mathPi)
	{
		D3VectorSymmetric(vs,returnArray);
		return;
	}
	if (ang == (mathPi * 1.5))
	{
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorScal(vec,D3VectorLen(vs),numArray6);
		D3VectorSymmetric(numArray6,returnArray);
		return;
	}
	if (ang == (mathPi * 2))
	{
		D3ArrayCopy(vs,returnArray);
		return ;
	}
	if ((ang > 0) && (ang < (mathPi / 2)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorUnit(numArray6,numArray7 );
		D3VectorScal( numArray7,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > (mathPi / 2)) && (ang < mathPi))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorSymmetric(numArray6,numArray7 );
		double numArray8[3] = {0.0,0.0,0.0};
		D3VectorUnit( numArray7,numArray8 );
		D3VectorScal(numArray8,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > mathPi) && (ang < (mathPi * 1.5)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorSymmetric(numArray6,numArray7 );
		double numArray8[3] = {0.0,0.0,0.0};
		D3VectorUnit( numArray7,numArray8 );
		D3VectorScal(numArray8,D3VectorLen(vs),returnArray);
		return;
	}
	if ((ang > (mathPi * 1.5)) && (ang < (mathPi * 2)))
	{
		D3VectorScal(vec,(D3VectorLen(vs) * tan(ang)),numArray3);
		double numArray6[3] = {0.0,0.0,0.0};
		D3VectorSum(vs,numArray3,numArray6);
		double numArray7[3] = {0.0,0.0,0.0};
		D3VectorUnit(numArray6,numArray7 );
		D3VectorScal( numArray7,D3VectorLen(vs),returnArray);
		return;
	}
	D3ArrayCopy(numArray,returnArray);
}
//描述：vec1和vec2的叉积
//输入：double 向量1 double 向量2 
//输出：double 结果数组
//返回：void
void D3CrossProduct(double vec1[3],double vec2[3],double returnArray[3] )
{
	returnArray[0] = (vec1[1] * vec2[2]) - (vec1[2] * vec2[1]),
		returnArray[1] = (vec1[2] * vec2[0]) - (vec1[0] * vec2[2]),
		returnArray[2] = (vec1[0] * vec2[1]) - (vec1[1] * vec2[0]);
}
//描述：计算3D反向向量
//输入：double 向量1
//输出：double 结果数组
//返回：void
void D3VectorSymmetric(double vec[3],double returnArray[3])
{
	returnArray[0] = -vec[0];
	returnArray[1] = -vec[1];
	returnArray[2] = -vec[2];

}
//描述：向量和
//输入：double 向量1 double 向量2
//输出：double 结果数组
//返回：void
void D3VectorSum(double v1[3],double v2[3],double returnArray[3])
{
	returnArray[0] = (v1[0] + v2[0]);
	returnArray[1] = (v1[1] + v2[1]);
	returnArray[2] = (v1[2] + v2[2]);

}
//描述：判断3D向量是否相等
//输入：double 向量1 double 向量2
//输出：
//返回：bool
bool D3VectorEqual(double v1[3],double v2[3])
{
	return (((abs(v1[0] - v2[0]) <= offsettolerance) && (abs(v1[1] - v2[1]) <= offsettolerance)) && (abs(v1[2] - v2[2]) <= offsettolerance));
}
//描述：3D点投影到面上
//输入：double 投影点 double 原点 double 方向 
//输出：double 结果数组
//返回：void
void D3PointProjectOnPlane(double pointToProjected[3], double originPoint[3], double Direction[3],double returnArray[3])
{
	if (D3VectorEqual(pointToProjected, originPoint))
	{
		D3ArrayCopy(pointToProjected,returnArray) ;
		return ;
	}
	double LineEndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint, Direction,LineEndPoint);
	double numArray2[3] = {0.0 , 0.0 , 0.0};
	D3PointProjectOnLine(originPoint, LineEndPoint, pointToProjected, false,numArray2);
	double vec[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(numArray2, pointToProjected,vec);
	D3PointMove(originPoint, vec, returnArray);
}
//描述：3D点投影到面上
//输入：double 投影点 double 原点 double 方向 double 方向  bool 布尔判断
//输出：double 结果数组
//返回：void
void D3PointProjectOnPlane(double pointToProjected[3], double originPoint[3], double vecX[3], double vecY[3], bool transformto2D,double returnArray[])
{
	if (D3VectorEqual(pointToProjected, originPoint))
	{
		if (!transformto2D)
		{
			D3ArrayCopy(pointToProjected,returnArray) ;
			return;
		}
		double numArray0[2] = {0.0,0.0};
		D2ArrayCopy(numArray0,returnArray) ;
		return ;
	}

	double vecZ[3] = {0.0 , 0.0 , 0.0};
	double resultPoint3D[3] = {0.0 , 0.0 , 0.0};
	D3CrossProduct(vecX,vecY,vecZ);
	D3PointProjectOnPlane( pointToProjected, originPoint,  vecZ, resultPoint3D);
	if (!transformto2D)
	{
		D3ArrayCopy (resultPoint3D,returnArray);
		return;
	}

	double vecY2[3] = {0.0 , 0.0 , 0.0};
	D3CrossProduct(vecZ,vecX,vecY2);
	double vecY2EndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint,vecY2,vecY2EndPoint);
	double vecXEndPoint[3] = {0.0 , 0.0 , 0.0};
	D3PointMove(originPoint,vecX,vecXEndPoint);	

	double X2D[2] = {0.0, 0.0};
	D3PointProjectOnLine(originPoint, vecXEndPoint, resultPoint3D,true,X2D);
	double Y2D[2] = {0.0, 0.0};
	D3PointProjectOnLine(originPoint, vecY2EndPoint, resultPoint3D,true,Y2D);

	double numArray13[2] = {X2D[0], Y2D[0]};
	D2ArrayCopy(numArray13,returnArray);
}
//描述：通过两个面相交出一条线
//输入：double 第一个面原点  double 第一个面方向 ouble 第二个面原点  double 第二个面方向
//输出：double 线的原点 double 线的方向
//返回：bool
bool D3PlanesGetCrossLine(double plane1Origin[3], double plane1Direction[3], double plane2Origin[3], double plane2Direction[3],double outCrossLineOrigin[3], double outCrossLineDir[3])
{
	if (D3VectorsParallel(plane1Direction, plane2Direction))
	{
		return false;
	}
	else
	{
		double numArray12[3] = {0.0 , 0.0 , 0.0};
		D3CrossProduct(plane1Direction, plane2Direction,numArray12);
		D3VectorUnit(numArray12,outCrossLineDir);

		if (D3VectorEqual(plane1Origin, plane2Origin))
		{
			D3ArrayCopy(plane1Origin,outCrossLineOrigin);
		}
		else
		{
			double plane1line[3] = {0.0 , 0.0 , 0.0};
			D3CrossProduct(plane1Direction, outCrossLineDir,plane1line);
			double plane2line[3] = {0.0 , 0.0 , 0.0};
			D3CrossProduct(outCrossLineDir , plane2Direction,plane2line);

			double vec[3] = {0.0 , 0.0 , 0.0};
			D3VectorSetFromTwoPoint(plane2Origin, plane1Origin,vec);
			double numArray6[3] = {0.0 , 0.0 , 0.0};
			D3VectorGetProjectX(vec, outCrossLineDir,numArray6);
			double plane2Origin2[3] = {0.0 , 0.0 , 0.0};
			D3PointMove(plane2Origin,numArray6,plane2Origin2);

			double plane1End[3] = {0.0 , 0.0 , 0.0};
			double plane2End[3] = {0.0 , 0.0 , 0.0};
			D3PointMove(plane1Origin,plane1line,plane1End);
			D3PointMove(plane2Origin2,plane2line,plane2End);
			D3LinesGetCrossPoint(plane1Origin,plane1End, plane2Origin2,plane2End ,outCrossLineOrigin);
		}
		return true;
	}
}
//描述：3D点投影在线上
//输入：double 线的起点  double线的终点  double 投影点 bool 布尔判断
//输出：double 结果数组
//返回：void
void D3PointProjectOnLine(double LineStartPoint[3],double LineEndPoint[3],double AnyPoint[3],bool transformto2D,double returnArray[])
{
	double vecAxis[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineStartPoint,LineEndPoint,vecAxis);
	double vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineStartPoint,AnyPoint,vec);
	double numArray3[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(LineEndPoint,AnyPoint,numArray3);
	double numArray4[3] = {0.0,0.0,0.0};
	double numArray5[3] = {0.0,0.0,0.0};
	if (D3VectorLen(vec) <= offsettolerance)
	{
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else if (D3VectorLen(numArray3) <= offsettolerance)
	{
		D3ArrayCopy(vecAxis,numArray4);
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else
	{
		D3VectorGetProjectX(vec,vecAxis,numArray4);
		D3PointMove(LineStartPoint,numArray4,numArray5);
	}
	if (!transformto2D)
	{
		D3ArrayCopy(numArray5,returnArray);
		return ;
	}
	double numArray6[3] = {0.0,0.0,0.0};
	D3VectorUnit(vecAxis,numArray6);
	double numArray7[3] = {0.0,0.0,0.0};
	D3VectorUnit(numArray4,numArray7);
	double num = 0.0;
	if(D3VectorEqual(numArray6,numArray7) )
	{
		num = D3VectorLen(numArray4);
	}
	else
	{
		num = 0 - D3VectorLen(numArray4);
	}
	double numArray2[2] = {num,0.0};
	D2ArrayCopy(numArray2,returnArray);
}

//描述：3D点沿指定方向投影在线上
//输入：double 线的起点  double线的终点  double 投影点 double指定投影方向  bool 布尔判断
//输出：double
//返回：void
void D3PointProjectOnLineAlongDir(double LineStartPoint[3], double LineEndPoint[3], double AnyPoint[3], double projectDirection[3], bool transformto2D,double returnArray[])
{
	double vec[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineStartPoint, LineEndPoint,vec);
	double numArray2[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineStartPoint, AnyPoint,numArray2);
	double numArray3[3] = {0.0 , 0.0 , 0.0};
	D3VectorSetFromTwoPoint(LineEndPoint, AnyPoint,numArray3);
	double numArray4[3] = {0.0 , 0.0 , 0.0};
	double numArray5[3] = {0.0 , 0.0 , 0.0};
	if (D3VectorLen(numArray2) <= offsettolerance)
	{
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else if (D3VectorLen(numArray3) <= offsettolerance)
	{
		D3ArrayCopy(vec,numArray4);
		D3ArrayCopy(AnyPoint,numArray5);
	}
	else
	{
		double numArray6[3] = {0.0 , 0.0 , 0.0};
		D3PointMove(AnyPoint, projectDirection,numArray6);
		D3LinesGetCrossPoint(LineStartPoint, LineEndPoint, AnyPoint, numArray6,numArray5);
		D3VectorSetFromTwoPoint(LineStartPoint, numArray5,numArray4);
	}
	if (!transformto2D)
	{
		D3ArrayCopy( numArray5,returnArray);
		return;
	}
	double numArray7[3] = {0.0 , 0.0 , 0.0};
	D3VectorUnit(vec,numArray7);
	double numArray8[3] = {0.0 , 0.0 , 0.0};
	D3VectorUnit(numArray4,numArray8);
	double num = 0.0;
	if(D3VectorEqual(numArray7, numArray8) )
	{
		num = D3VectorLen(numArray4) ;
	}
	else
	{
		num = 0 - D3VectorLen(numArray4);
	}
	double numArray9[2] = {num, 0.0};
	D2ArrayCopy(numArray9,returnArray);
}


//描述：获取文档类型
//输入：CATDocument文档对象
//输出：CATUnicodeString
//返回：HRESULT
HRESULT GetDocumentType( CATDocument *ipDocument,CATUnicodeString &ostrType )
{
	HRESULT rc=S_OK;

	ostrType = "";
	if( !ipDocument ) return E_FAIL;

	CATUnicodeString storageName;
	storageName = ipDocument->StorageName();

	int len;
	len = storageName.GetLengthInChar();

	CATUnicodeString suffix;
	if( !!len ) 
	{
		//Get suffix of the document
		int startPos;
		startPos = storageName.SearchSubString(CATUnicodeString("."),0,CATUnicodeString::CATSearchModeBackward);
		startPos++;
		suffix = storageName.SubString(startPos,(len-startPos));
	}
	else 
	{
		CATIDocId *piDocID=NULL;
		rc = ipDocument->GetDocId(&piDocID);
		if( SUCCEEDED(rc) && !!piDocID ) 
		{
			rc = piDocID->GetType(suffix);
			piDocID->Release(); piDocID = NULL;
		}
		else
			suffix = ipDocument->GetType();
	}
	ostrType = suffix;

	return S_OK;
}

//描述：打开文件
//输入：CATUnicodeString路径
//输出：CATISpecObject对象，CATUnicodeString名称，CATUnicodeString类型
//返回：HRESULT
HRESULT OpenCATPrdFromPath( CATUnicodeString istrPath, CATISpecObject_var &ospSpecObject, CATUnicodeString &ostrPartNumber, CATUnicodeString &ostrType )
{
	HRESULT rc = S_OK;

	//查看文件是否存在
	if ((_access(istrPath,0)) == -1)
	{
		cout<<"The File "<<istrPath<<" doesn't exist"<<endl;
		return E_FAIL;
	}

	CATDocument * pDocument = NULL;
	rc=CATDocumentServices::OpenDocument(istrPath,pDocument);
	if (NULL == pDocument) return E_FAIL;

	CATIDocId *oDocId=NULL;
	rc=pDocument->GetDocId(&oDocId);
	if(SUCCEEDED(rc)&&oDocId!=NULL)
	{
		CATUnicodeString oType;
		rc=oDocId->GetType(oType);
		if(oType=="CATProduct" || oType=="CATPart")
		{
			CATIProduct_var spiOtherProduct=NULL_var;
			CATIDocRoots *piDocRootsOnDoc = NULL;
			rc = pDocument -> QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
			if ( FAILED(rc) )
			{
				cout<<"-- 获取DocRoots接口失败！"<<endl;
				return E_FAIL;
			}

			CATListValCATBaseUnknown_var* pRootProducts = piDocRootsOnDoc -> GiveDocRoots();
			if (pRootProducts->Size())
			{	
				spiOtherProduct = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			piDocRootsOnDoc->Release(); piDocRootsOnDoc = NULL;
			if(spiOtherProduct!=NULL_var)
			{
				ospSpecObject=spiOtherProduct;
				ostrPartNumber = spiOtherProduct->GetPartNumber();
				ostrType = oType;
			}
		}
	}

	return rc;
}
//描述：获取所有的打开文档
//输入：
//输出：CATLISTV(CATISpecObject_var)对象，CATListOfCATUnicodeString名称
//返回：HRESULT
HRESULT GetAllRootDocument( CATLISTV(CATISpecObject_var) &oListOfRootObjects,CATListOfCATUnicodeString &oListOfRootObjectNames )
{
	HRESULT rc=S_OK;

	// ********************
	// 获得所有窗口的根节点文档
	// ********************
	CATFrmLayout *pLayout = CATFrmLayout::GetCurrentLayout();
	if(pLayout!=NULL)
	{
		CATLISTP(CATFrmWindow) WindowList ;
		WindowList = pLayout ->GetWindowList();
		for(int i=1; i<=WindowList.Size(); i++)
		{
			CATFrmWindow *pCurrentWind = WindowList[i] ;
			if(pCurrentWind!=NULL)
			{
				CATFrmEditor *pEditor = pCurrentWind->GetEditor(); 
				if(pEditor!=NULL)
				{
					CATDocument *pDocument = pEditor ->GetDocument(); 
					CATUnicodeString strDisplayName = pDocument->DisplayName();
					cout<<"Document "<<i<<" "<<strDisplayName<<endl;
					CATIDocId *oDocId=NULL;
					rc=pDocument->GetDocId(&oDocId);
					if(SUCCEEDED(rc)&&oDocId!=NULL)
					{
						CATUnicodeString oType;
						rc=oDocId->GetType(oType);
						if(oType=="CATProduct" || oType=="CATPart")
						{
							CATIProduct_var spiOtherProduct=NULL_var;
							CATIDocRoots *piDocRootsOnDoc = NULL;
							rc = pDocument -> QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
							if ( FAILED(rc) )
							{
								cout<<"-- 获取DocRoots接口失败！"<<endl;
								return FALSE;
							}

							CATListValCATBaseUnknown_var* pRootProducts = piDocRootsOnDoc -> GiveDocRoots();
							if (pRootProducts->Size())
							{	
								spiOtherProduct = (*pRootProducts)[1];
								delete pRootProducts;
								pRootProducts = NULL;
							}
							piDocRootsOnDoc->Release(); piDocRootsOnDoc = NULL;
							if(spiOtherProduct!=NULL_var)
							{
								CATISpecObject_var spCurrObj=spiOtherProduct;
								oListOfRootObjects.Append(spCurrObj);
								oListOfRootObjectNames.Append(spiOtherProduct->GetPartNumber());
								if (oType=="CATProduct")
								{
									oListOfRootObjectNames.Append("CATProduct");
								}
								else
									oListOfRootObjectNames.Append("CATPart");
							}
						}
					}	
				}
			}
		}
	}

	return rc;
}

//描述：获取当前打开的根节点，包括Part和Product
//输入：
//输出：CATIProduct
//返回：HRESULT
HRESULT GetRootProduct( CATIProduct_var &ospiRootProduct )
{
	//获取Document
	CATFrmEditor *pEditor = CATFrmEditor::GetCurrentEditor();
	if (pEditor == NULL)
	{
		return E_FAIL;
	}
	CATDocument *pDoc = pEditor->GetDocument();
	if (pDoc == NULL)
	{
		return E_FAIL;
	}

	//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDoc->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
	CATIProduct_var spRootProduct = NULL_var;
	if (pRootProducts->Size())
	{
		spRootProduct = (*pRootProducts)[1];
		delete pRootProducts;
		pRootProducts = NULL;
	}

	piDocRootsOnDoc->Release();

	ospiRootProduct = spRootProduct;

	////CATIProduct *piProductOnRoot = NULL;
	//rc = spRootProduct->QueryInterface(IID_CATIProduct, (void**)&opiRootProduct);
	//if (FAILED(rc) || piDocRootsOnDoc == NULL)
	//{
	//	return E_FAIL;
	//}

	return S_OK;
}


//描述：获取PartContainer
//输入：CATIProduct产品对象
//输出：CATIPrtContainer
//返回：CATIPrtContainer
CATIPrtContainer_var GetPrtContainer( CATIProduct_var ispiObject )
{
	HRESULT rc;

	CATIPrtContainer_var spRootCont=NULL_var;
	if (ispiObject ==NULL_var)
	{
		cout<<"GetPrtContainer Failed"<<endl;
		return spRootCont;
	}
	CATIProduct_var spRefProduct =ispiObject->GetReferenceProduct();
	if( NULL_var == spRefProduct ) return spRootCont;

	CATILinkableObject *piLinkableObject = NULL;
	rc = spRefProduct ->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObject);
	if( FAILED(rc) || piLinkableObject == NULL ) return  spRootCont;

	// Do not release this pointer
	// Get the document.
	CATDocument * pDoc = NULL ;
	pDoc = piLinkableObject->GetDocument();
	piLinkableObject->Release();       
	piLinkableObject = NULL ;
	if( pDoc == NULL )
	{
		return spRootCont;
	}
	//Get Init
	CATInit_var spInitOnDoc(pDoc);
	if(NULL_var == spInitOnDoc)
	{
		return spRootCont;
	}
	CATIPrtContainer *piPrtContainerOnRoot  = (CATIPrtContainer*)spInitOnDoc->GetRootContainer("CATIPrtContainer");	
	if(piPrtContainerOnRoot!=NULL)
	{
		spRootCont=piPrtContainerOnRoot;
		piPrtContainerOnRoot->Release();
		piPrtContainerOnRoot=NULL;
	}
	return spRootCont;
}

//描述：获取某产品的所有子级
//输入：产品对象CATIProduct
//输出：子级件List
//返回：HRESULT
HRESULT GetAllChildrenOfRootPrd( CATIProduct_var ispProjPrd,CATLISTV(CATISpecObject_var) &oListOfObject )
{
	HRESULT rc=S_OK;

	if(ispProjPrd == NULL_var) return E_FAIL;

	CATListValCATBaseUnknown_var *listChildPrd=NULL;
	listChildPrd = ispProjPrd->GetAllChildren();
	if(listChildPrd==NULL) return E_FAIL;

	if (listChildPrd->Size()<=0) return E_FAIL;

	for(int i=1;i<=listChildPrd->Size();i++)
	{
		CATIProduct_var spChildProduct=((*listChildPrd)[i]);
		if (spChildProduct == NULL_var) continue;

		CATIProduct_var spiRefProduct=spChildProduct->GetReferenceProduct();
		CATILinkableObject_var spiRefLink=spiRefProduct;

		if(NULL_var == spiRefLink ) continue;
		CATDocument *piDocOnChildPrd=NULL;
		piDocOnChildPrd = spiRefLink->GetDocument();

		if(NULL == piDocOnChildPrd ) continue;
		CATUnicodeString strPrdType = "";
		CATIDocId *piDocID=NULL;
		rc = piDocOnChildPrd->GetDocId(&piDocID);
		if( SUCCEEDED(rc) && !!piDocID ) 
		{
			rc = piDocID->GetType(strPrdType);
			piDocID->Release(); piDocID = NULL;
		}

		CATISpecObject_var spCurrObj=spChildProduct;
		oListOfObject.Append(spCurrObj);
	}
	return rc;
}
//描述：获取某产品的所有part子级
//输入：产品对象CATIProduct
//输出：子级件List
//返回：HRESULT
HRESULT GetAllPartsOfPrd( CATIProduct_var ispProjPrd,CATLISTV(CATISpecObject_var) &oListOfObject )
{
	HRESULT rc=S_OK;

	if(ispProjPrd == NULL_var) return E_FAIL;

	CATListValCATBaseUnknown_var *listChildPrd=NULL;
	listChildPrd = ispProjPrd->GetAllChildren();
	if(listChildPrd==NULL) return E_FAIL;

	if (listChildPrd->Size()<=0) return E_FAIL;

	for(int i=1;i<=listChildPrd->Size();i++)
	{
		CATIProduct_var spChildProduct=((*listChildPrd)[i]);
		if (spChildProduct == NULL_var) continue;

		CATIProduct_var spiRefProduct=spChildProduct->GetReferenceProduct();
		CATILinkableObject_var spiRefLink=spiRefProduct;

		if(NULL_var == spiRefLink ) continue;
		CATDocument *piDocOnChildPrd=NULL;
		piDocOnChildPrd = spiRefLink->GetDocument();

		if(NULL == piDocOnChildPrd ) continue;
		CATUnicodeString strPrdType = "";
		CATIDocId *piDocID=NULL;
		rc = piDocOnChildPrd->GetDocId(&piDocID);
		if( SUCCEEDED(rc) && !!piDocID ) 
		{
			rc = piDocID->GetType(strPrdType);
			piDocID->Release(); piDocID = NULL;

			if(strPrdType=="CATPart")
			{
				CATISpecObject_var spCurrObj=spChildProduct;
				oListOfObject.Append(spCurrObj);
			}
		}
	}
	return rc;
}
//描述：获取某名称的几何集
//输入：CATISpecObject对象，CATUnicodeString几何集名称
//输出：CATISpecObject
//返回：HRESULT
HRESULT GetGeometricalSet( CATISpecObject_var ispSpecObject, CATUnicodeString istrGeometrySet, CATISpecObject_var &ospGeometrySet )
{
	HRESULT rc=S_OK;
	ospGeometrySet = NULL_var;
	if (NULL_var == ispSpecObject) return E_FAIL;

	//转换成CATIDescendants类型,用来得到Feature中所有的孩子
	CATIDescendants *piDescPart=NULL;
	rc = ispSpecObject->QueryInterface(IID_CATIDescendants, (void**)&piDescPart);
	if (FAILED(rc)||(!piDescPart)) return E_FAIL;

	//获得所有的几何图形集
	CATListValCATISpecObject_var splistGeoFeatures;
	piDescPart->GetAllChildren("CATIMmiGeometricalSet", splistGeoFeatures);

	for (int i = 1; i<=splistGeoFeatures.Size(); i++)
	{
		CATISpecObject_var spCurrGeo = splistGeoFeatures[i];
		if (NULL_var == spCurrGeo) continue;

		CATUnicodeString strAliasOnGeo = CATIAlias_var(spCurrGeo)->GetAlias();

		if (strAliasOnGeo == istrGeometrySet)
		{
			ospGeometrySet = spCurrGeo;
			break;
		}
	}
	return rc;
}
//描述：获取几何集下的指定特征
//输入：CATISpecObject对象，CATUnicodeString特征名称
//输出：CATISpecObject
//返回：HRESULT
HRESULT GetFeatureOfGeometricalSet( CATISpecObject_var ispGeometricalSet, CATUnicodeString strFeatureName, CATISpecObject_var &ospFeature )
{
	HRESULT rc = S_OK;
	ospFeature = NULL_var;
	if (NULL_var == ispGeometricalSet) return E_FAIL;

	//转换成CATIDescendants类型,用来得到Feature中所有的孩子
	CATIDescendants *piDescPart=NULL;
	rc = ispGeometricalSet->QueryInterface(IID_CATIDescendants, (void**)&piDescPart);
	if (FAILED(rc)||(!piDescPart)) return E_FAIL;

	CATListValCATISpecObject_var splistFeatures;
	piDescPart->GetDirectChildren("CATISpecObject", splistFeatures);

	if (splistFeatures.Size()>0)
	{
		for (int i=1;i<=splistFeatures.Size();i++)
		{
			CATISpecObject_var spCurrFeat = splistFeatures[i];
			if (NULL_var == spCurrFeat) continue;

			CATUnicodeString strAliasOnFeat = CATIAlias_var(spCurrFeat)->GetAlias();

			if (strAliasOnFeat == strFeatureName)
			{
				ospFeature = spCurrFeat;
				break;
			}
		}
	}
	return rc;
}
//描述：获取特征的Body
//输入：CATISpecObject对象
//输出：CATBody
//返回：CATBody
CATBody_var GetBodyFromFeature( const CATBaseUnknown_var& ispFeature )
{
	//cout<<"GetBodyFromFeature...."<<endl;
	CATBody_var spBody = NULL_var; 
	do { 
		if( ispFeature==NULL_var )  break; 

		CATIMfBRep_var spBRepOnFeature = ispFeature; 
		if(spBRepOnFeature!=NULL_var )
		{ 
			spBody = spBRepOnFeature->GetBody(); 
			if (spBody==NULL_var)
			{
				spBody=spBRepOnFeature->CreateBody(MfWithPermanentBody);
				if (spBody==NULL_var)
				{
					spBody=spBRepOnFeature->CreateSickBody();
					if (spBody==NULL_var)
					{
						cout<<"CATIMfBRep GetBody Failed"<<endl;

					}
					else
					{
						cout<<"CreateSickBody sucess"<<endl;

					}

				}
				else
				{
					cout<<"CreateBody sucess"<<endl;
				}
			}
		} 
		else
		{ 
			CATIBRepAccess_var spBRepAccess=ispFeature;
			if (spBRepAccess!=NULL_var)
			{
				spBody=spBRepAccess->CreateBody();
			}
			else
			{
				CATIGeometricalElement_var spGeometricalElementOnFeature = ispFeature; 
				if( !!spGeometricalElementOnFeature ) 
				{ 
					spBody = spGeometricalElementOnFeature->GetBodyResult(); 
				} 
				else
				{ 
					CATIBodyRequest_var spBodyRequestOnModel = ispFeature; 
					if( spBodyRequestOnModel == NULL_var) break; 

					CATListValCATBaseUnknown_var listResult; 
					HRESULT rc = spBodyRequestOnModel->GetResults("MfDefault3DView",listResult);
					if(FAILED(rc) ||  listResult.Size() <= 0)   break; 

					CATIGeometricalElement_var spGeometricalElementOnBody = listResult[1]; 
					if(spGeometricalElementOnBody==NULL_var)  break;    
					spBody = spGeometricalElementOnBody->GetBodyResult();
				} 
			}
		}
		if( spBody==NULL_var) break;
	} while(FALSE); 
	//cout<<"GetBodyFromFeature...."<<endl;
	return spBody; 
}


//描述：获取对象的包围盒
//输入：CATISpecObject对象
//输出：CATMathBox
//返回：CATMathBox
CATMathBox Get3DBoundingBox( CATISpecObject_var ispiSpecProd )
{
	HRESULT rc=E_FAIL;
	CATMathBox oMathBox;

	if (ispiSpecProd == NULL_var)
	{
		cout<<"Get3DBoundingBox Failed"<<endl;
		return oMathBox;
	}
	CATIPrtContainer_var  spRootContainer = GetPrtContainer((CATIProduct_var)ispiSpecProd);
	if( spRootContainer == NULL_var )
	{
		cout <<"# Get Container error !" << endl;
		return oMathBox;
	}

	CATISpecObject_var spiSpecOnPart = spRootContainer -> GetPart();
	if (spiSpecOnPart == NULL_var)
	{
		cout<<"Get Part Failed!"<<endl;
		return oMathBox;
	}
	//cout<<"Part Name: "<<CATIAlias_var(spiSpecOnPart)->GetAlias()<<endl;
	CATIDescendants *spDescendants = NULL;
	CATListValCATISpecObject_var  ListOfTriDimObjects;
	rc = spiSpecOnPart->QueryInterface(IID_CATIDescendants,(void**) &spDescendants);
	if( FAILED(rc) || spDescendants == NULL )
	{
		cout << "# Get CATIDescendants error !" << endl;
		return oMathBox;
	}

	spDescendants -> GetAllChildren("CATIMfTriDimResult",ListOfTriDimObjects);
	spDescendants->Release();
	spDescendants = NULL;
	if(ListOfTriDimObjects.Size()>0)
	{
		for (int i=1;i<=ListOfTriDimObjects.Size();i++)
		{
			CATISpecObject_var spCurrObj = ListOfTriDimObjects[i];
			if (NULL_var == spCurrObj) continue;

			CATBoolean bShow = CheckShowState(spCurrObj);
			if (!bShow) continue;

			//cout<<i<<" element "<<CATIAlias_var(spCurrObj)->GetAlias()<<endl;

			CATBody_var spBody = GetBodyFromFeature(spCurrObj);
			if(spBody != NULL_var)
			{
				CATMathBox tempBox = spBody->GetBoundingBox();
				oMathBox.AddInside(tempBox);
				//tempBox.Dump();
			}
		}
	}
	return oMathBox;
}
//描述：获取矩阵
//输入：CATISpecObject对象1，CATISpecObject对象2
//输出：CATMathTransformation
//返回：CATMathTransformation
CATMathTransformation GetMatrixTransformation( CATISpecObject_var spSpecOne, CATISpecObject_var spSpecTwo )
{
	CATIMovable_var spiMovableOne(spSpecOne);
	if(spiMovableOne == NULL_var) 
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATIMovable_var spiMovableTwo(spSpecTwo);
	if(spiMovableTwo == NULL_var) {
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	CATMathTransformation pMathTrans = spiMovableOne->GetPosition(spiMovableTwo, CATPrd3D, TRUE);

	return pMathTrans;
}
//描述：获取特征点的坐标
//输入：CATIBody_var对象,CATIProduct_var body所在part,CATIProduct_var 目标part(空时默认转化到绝对坐标系)
//输出：CATIBody_var
//返回：HRESULT
HRESULT GetTransformationBody(CATBody_var ispBody,CATIProduct_var ispOrginProduct,CATIProduct_var ispTargetProduct,CATBody_var& ospResultBody)
{
	HRESULT rc = S_OK;
	ospResultBody = NULL_var;
	if(NULL_var == ispBody||NULL_var == ispOrginProduct||NULL_var == ispTargetProduct)
	{
		return E_FAIL;
	}
	CATGeoFactory_var spGeoFac=ispBody->GetContainer();
	if (spGeoFac==NULL_var)
	{
		return E_FAIL;
	}

	CATMathTransformation transFather;
	if(NULL_var == ispTargetProduct)
	{
		transFather = GetAbsTransformation(ispOrginProduct);
	}else
	{
		transFather = GetMatrixTransformation(ispOrginProduct,ispTargetProduct);
	}
	//先把Body也坐标变换到father一级
	CATTransfoManager * pTransfoManager = new CATTransfoManager(transFather,spGeoFac,CATTransfoManager::FullDuplicate  , NULL); 		
	if (NULL==pTransfoManager)
	{
		return E_FAIL;
	}

	pTransfoManager->Add(ispBody);
	pTransfoManager->Run();

	CATBody * piTransBody = (CATBody *)(pTransfoManager->ReadImage(ispBody));
	if (piTransBody==NULL)
	{
		return E_FAIL;
	}

	ospResultBody = piTransBody;
	delete pTransfoManager;
	pTransfoManager = NULL;

	return S_OK;
}

//描述：获取全局的矩阵
//输入：CATISpecObject对象(原始轴系对应product)
//输出：CATMathTransformation
//返回：CATMathTransformation
CATMathTransformation GetAbsTransformation( CATISpecObject_var ispSpecOne )
{
	CATMathTransformation pMathTrans;

	if(ispSpecOne==NULL_var)
		return pMathTrans;

	CATIMovable_var spiMovableOne(ispSpecOne);
	if(spiMovableOne == NULL_var) 
	{
		cout<<"Failed to Get Movable."<<endl;
		return NULL;
	}

	spiMovableOne->GetAbsPosition(pMathTrans);

	return pMathTrans;
}
#ifdef fkjslfrglr
//描述：获取某一对象的包围盒中点
//输入：CATIProduct产品对象1，CATISpecObject对象
//输出：CATMathPoint
//返回：HRESULT
HRESULT GetCenterOfObject( CATIProduct_var ispPrd,CATISpecObject_var ispRefPrd,CATMathPoint &oCenterPt,double &odistance )
{
	HRESULT rc = S_OK;

	if (NULL_var == ispPrd) return E_FAIL;

	if (NULL_var == ispRefPrd)
	{
		ispRefPrd = ispPrd;
	}

	CATIProduct_var spiRefProduct=ispPrd->GetReferenceProduct();

	CATILinkableObject_var spiRefLink=spiRefProduct;

	if(NULL_var == spiRefLink ) return E_FAIL;
	CATDocument *piDoc=NULL;
	piDoc = spiRefLink->GetDocument();

	CATUnicodeString strPrdType = "";
	GetDocumentType(piDoc,strPrdType);

	CATLISTV(CATISpecObject_var) ListOfParts;
	if (strPrdType == "CATProduct")
	{
		CATLISTV(CATISpecObject_var) ListOfPartChildren;
		GetAllPartsOfPrd(ispPrd,ListOfPartChildren);
		ListOfParts.Append(ListOfPartChildren);
	}
	else if (strPrdType == "CATPart")
	{
		ListOfParts.Append(ispPrd);
	}

	if (ListOfParts.Size()<1) return E_FAIL;

	CATMathBox mathPrdBox;
	for (int i=1;i<=ListOfParts.Size();i++)
	{
		CATIProduct_var spCurrPrd = ListOfParts[i];
		if (NULL_var == spCurrPrd) continue;

		CATISpecObject_var spCurrObj = spCurrPrd;
		if (NULL_var == spCurrPrd) continue;

		CATMathBox iBox = Get3DBoundingBox(spCurrObj);
		if (!iBox.IsEmpty())
		{
			CATMathBox iAbsBox;
			GetAbsMathBox(spCurrObj,CATISpecObject_var(ispRefPrd),iBox,iAbsBox);
			mathPrdBox.AddInside(iAbsBox);
		}		
	}

	if (!mathPrdBox.IsEmpty())
	{
		CATMathPoint iHighPt;
		CATMathPoint iLowPt;
		mathPrdBox.GetHigh(iHighPt);
		mathPrdBox.GetLow(iLowPt);
		oCenterPt = 0.5*(iHighPt+iLowPt);
		odistance=abs(iHighPt.GetY()-iLowPt.GetY());
		return S_OK;
	}

	return rc;
}

HRESULT GetCenterOfObject( CATIProduct_var ispPrd,CATISpecObject_var ispRefPrd,CATMathPoint &oCenterPt )
{
	HRESULT rc = S_OK;

	if (NULL_var == ispPrd) return E_FAIL;

	if (NULL_var == ispRefPrd)
	{
		ispRefPrd = ispPrd;
	}

	CATIProduct_var spiRefProduct=ispPrd->GetReferenceProduct();

	CATILinkableObject_var spiRefLink=spiRefProduct;

	if(NULL_var == spiRefLink ) return E_FAIL;
	CATDocument *piDoc=NULL;
	piDoc = spiRefLink->GetDocument();

	CATUnicodeString strPrdType = "";
	GetDocumentType(piDoc,strPrdType);

	CATLISTV(CATISpecObject_var) ListOfParts;
	if (strPrdType == "CATProduct")
	{
		CATLISTV(CATISpecObject_var) ListOfPartChildren;
		GetAllPartsOfPrd(ispPrd,ListOfPartChildren);
		ListOfParts.Append(ListOfPartChildren);
	}
	else if (strPrdType == "CATPart")
	{
		ListOfParts.Append(ispPrd);
	}

	if (ListOfParts.Size()<1) return E_FAIL;

	CATMathBox mathPrdBox;
	for (int i=1;i<=ListOfParts.Size();i++)
	{
		CATIProduct_var spCurrPrd = ListOfParts[i];
		if (NULL_var == spCurrPrd) continue;

		CATISpecObject_var spCurrObj = spCurrPrd;
		if (NULL_var == spCurrPrd) continue;

		CATMathBox iBox = Get3DBoundingBox(spCurrObj);
		if (!iBox.IsEmpty())
		{
			CATMathBox iAbsBox;
			GetAbsMathBox(spCurrObj,CATISpecObject_var(ispRefPrd),iBox,iAbsBox);
			mathPrdBox.AddInside(iAbsBox);
		}		
	}

	if (!mathPrdBox.IsEmpty())
	{
		CATMathPoint iHighPt;
		CATMathPoint iLowPt;
		mathPrdBox.GetHigh(iHighPt);
		mathPrdBox.GetLow(iLowPt);
		oCenterPt = 0.5*(iHighPt+iLowPt);
		return S_OK;
	}
	return rc;
}
//描述：获取某一对象的包围盒中点
//输入：CATIProduct产品对象1，CATISpecObject对象
//输出：CATMathBox
//返回：HRESULT
HRESULT GetCenterOfObject( CATIProduct_var ispPrd,CATISpecObject_var ispRefPrd,CATMathBox &oMathBox,CATMathPoint &oCenterPt )
{
	HRESULT rc = S_OK;

	if (NULL_var == ispPrd) return E_FAIL;

	if (NULL_var == ispRefPrd)
	{
		ispRefPrd = ispPrd;
	}

	CATIProduct_var spiRefProduct=ispPrd->GetReferenceProduct();
	CATILinkableObject_var spiRefLink=spiRefProduct;

	if(NULL_var == spiRefLink ) return E_FAIL;
	CATDocument *piDoc=NULL;
	piDoc = spiRefLink->GetDocument();

	CATUnicodeString strPrdType = "";
	GetDocumentType(piDoc,strPrdType);

	CATLISTV(CATISpecObject_var) ListOfParts;
	if (strPrdType == "CATProduct")
	{
		CATLISTV(CATISpecObject_var) ListOfPartChildren;
		GetAllPartsOfPrd(ispPrd,ListOfPartChildren);
		ListOfParts.Append(ListOfPartChildren);
	}
	else if (strPrdType == "CATPart")
	{
		ListOfParts.Append(ispPrd);
	}

	if (ListOfParts.Size()<1) return E_FAIL;

	CATMathBox mathPrdBox;
	for (int i=1;i<=ListOfParts.Size();i++)
	{
		CATIProduct_var spCurrPrd = ListOfParts[i];
		if (NULL_var == spCurrPrd) continue;

		CATUnicodeString strPartNumber = spCurrPrd->GetPartNumber();
		//cout<<i<<" "<<strPartNumber<<endl;

		CATISpecObject_var spCurrObj = spCurrPrd;
		if (NULL_var == spCurrPrd) continue;

		CATMathBox iBox = Get3DBoundingBox(spCurrObj);
		if (!iBox.IsEmpty())
		{
			//iBox.Dump();
			CATMathBox iAbsBox;
			GetAbsMathBox(spCurrObj,CATISpecObject_var(ispRefPrd),iBox,iAbsBox);

			mathPrdBox.AddInside(iAbsBox);
		}
	}

	if (!mathPrdBox.IsEmpty())
	{
		oMathBox = mathPrdBox;
		CATMathPoint iHighPt;
		CATMathPoint iLowPt;
		mathPrdBox.GetHigh(iHighPt);
		mathPrdBox.GetLow(iLowPt);
		oCenterPt = 0.5*(iHighPt+iLowPt);
		return S_OK;
	}

	return rc;
}
#endif
//描述：获取特征点的坐标
//输入：CATISpecObject对象
//输出：CATMathPoint
//返回：HRESULT
HRESULT GetMathPointFromPointSpec( CATISpecObject_var ispSpecOnPt,CATMathPoint &oMathPt )
{
	HRESULT rc = S_OK;

	if (NULL_var == ispSpecOnPt) return E_FAIL;

	CATPoint_var spPoint = ispSpecOnPt;
	if (spPoint != NULL)
	{
		spPoint->GetMathPoint(oMathPt);
		return S_OK;
	}
	else
		return E_FAIL;

	return rc;
}
//描述：获取点坐标的String表达式
//输入：CATMathPoint点
//输出：CATUnicodeString
//返回：CATUnicodeString
CATUnicodeString GetStringOfPointCoord( CATMathPoint imathPoint )
{
	CATUnicodeString strCoord = "";

	CATUnicodeString strXCoord = "";
	CATUnicodeString strYCoord = "";
	CATUnicodeString strZCoord = "";
	strXCoord.BuildFromNum(imathPoint.GetX(),"%g");
	strYCoord.BuildFromNum(imathPoint.GetY(),"%g");
	strZCoord.BuildFromNum(imathPoint.GetZ(),"%g");
	strCoord = "X="+strXCoord+", Y="+strYCoord+", Z="+strZCoord+";";

	return strCoord;
}

#ifdef fklnsg
//描述：获取线集合的中点
//输入：CATLISTV(CATISpecObject_var)对象
//输出：CATMathPoint
//返回：HRESULT
HRESULT GetCenterPtOfCurves( CATLISTV(CATISpecObject_var) iListOfCurves,CATLISTV(CATISpecObject_var) iListOfCurvesPart,CATMathPoint &oMathPt )
{
	HRESULT rc = S_OK;

	if (iListOfCurves.Size()<1) return E_FAIL;

	CATMathBox oMathBox;
	for (int i=1;i<=iListOfCurves.Size();i++)
	{
		CATISpecObject_var spCurrCurve = iListOfCurves[i];
		if (NULL_var == spCurrCurve) continue;

		CATBody_var spBody = GetBodyFromFeature(spCurrCurve);
		if(spBody == NULL_var) continue;

		CATMathBox tempBox = spBody->GetBoundingBox();

		CATMathBox oAbsBox;
		GetAbsMathBox(iListOfCurvesPart[i],tempBox,oAbsBox);

		oMathBox.AddInside(oAbsBox);
	}

	if (!oMathBox.IsEmpty())
	{
		CATMathPoint iHighPt;
		CATMathPoint iLowPt;
		oMathBox.GetHigh(iHighPt);
		oMathBox.GetLow(iLowPt);
		oMathPt = 0.5*(iHighPt+iLowPt);
		return S_OK;
	}
	else
		return E_FAIL;

	return rc;
}
#endif
//描述：获取Curve类型的线
//输入：CATISpecObject对象
//输出：CATMathVector
//返回：HRESULT
HRESULT GetCurveOfSpecObject( CATISpecObject_var ispSpecOnCurve,CATCurve_var &ospCurve )
{
	HRESULT rc = S_OK;

	if (NULL_var == ispSpecOnCurve) return E_FAIL;

	ospCurve = ispSpecOnCurve;
	if (NULL_var == ospCurve)
	{
		CATBody_var spCurveBody = GetBodyFromFeature(ispSpecOnCurve);
		if (spCurveBody != NULL_var)
		{
			CATEdgeCurve_var spCircleCurve = NULL_var;
			CATLISTP(CATCell) LISTCell;
			spCurveBody->GetAllCells(LISTCell,1);
			if (LISTCell.Size()>0)
			{
				for( int index = 1; index <= LISTCell.Size(); index++)
				{ 
					CATCell *pSplineCell = LISTCell[index]; 
					if(!pSplineCell)
					{ 
						continue; 
					} 
					CATCell_var spSplineCell = pSplineCell; 
					if(!spSplineCell)
					{ 
						continue; 
					};
					CATEdge_var spEdge=spSplineCell;
					if(!spEdge)
					{
						continue;
					}
					CATEdgeCurve_var spEdgeCurve = spEdge ->GetCurve(NULL);
					if(!spEdgeCurve)
					{ 
						continue; 
					}

					ospCurve=spEdgeCurve->GetRefCurve();
					if (NULL_var != ospCurve)
					{
						break;
					}					
				}
			}
		}
	}

	if (NULL_var != ospCurve)
	{
		return S_OK;
	}
	else
		return E_FAIL;

	return rc;
}
//描述：从body获取曲线
//输入：CATBody_var 要提取的body
//输出：CATCurve_var 获得的曲线
//返回：HRESULT
HRESULT GetCurveOfBody( CATBody_var spCurveBody,CATCurve_var &ospCurve )
{
	HRESULT rc = S_OK;

	if (NULL_var == spCurveBody) return E_FAIL;

	CATEdgeCurve_var spCircleCurve = NULL_var;
	CATLISTP(CATCell) LISTCell;
	spCurveBody->GetAllCells(LISTCell,1);

	for( int index = 1; index <= LISTCell.Size(); index++)
	{ 
		CATCell *pSplineCell = LISTCell[index]; 
		if(!pSplineCell)
		{ 
			continue; 
		} 
		CATCell_var spSplineCell = pSplineCell; 
		if(!spSplineCell)
		{ 
			continue; 
		};
		CATEdge_var spEdge=spSplineCell;
		if(!spEdge)
		{
			continue;
		}
		CATEdgeCurve_var spEdgeCurve = spEdge ->GetCurve(NULL);
		if(!spEdgeCurve)
		{ 
			continue; 
		}

		ospCurve=spEdgeCurve->GetRefCurve();
		if (NULL_var != ospCurve)
		{
			break;
		}					
	}

	if (NULL_var != ospCurve)
	{
		return S_OK;
	}
	else
		return E_FAIL;

	return rc;
}
//描述：获取直线方向
//输入：CATBaseUnknown_var 线特征
//输出：CATMathVector 获得的方向
//返回：HRESULT
HRESULT GetLineDirection( CATBaseUnknown_var ispiSpecObject,CATMathVector &oMathVec )
{
	//CATMathLine resultMathLine;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody != NULL ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0); 
		if(LISTCell.Size()<2)
		{
			cout<<"LISTCell size != 2"<<endl;
			return E_FAIL; 
		}
		else
		{
			CATVertex_var spV1 = LISTCell[1];
			CATVertex_var spV2 = LISTCell[LISTCell.Size()];

			CATPoint * pt1 = spV1->GetPoint();
			CATPoint * pt2 = spV2->GetPoint();

			CATMathPoint mathPt1;
			CATMathPoint mathPt2;
			pt1->GetMathPoint(mathPt1);
			pt2->GetMathPoint(mathPt2);
			CATMathVector vec = mathPt2 - mathPt1;

			oMathVec = vec;
		}		
	}
	else  //当选择图形内虚拟轴线时，BaseUnknown无法直接转成body，此时就直接把轴线的BaseUnknown转成CATLine，直接获得方向即可
	{
		CATLine_var spLine = ispiSpecObject;
		if (spLine == NULL_var)
		{
			return E_FAIL;
		}
		oMathVec = spLine->GetDirection();
	}

	return S_OK;
}
//描述：通过3点求得圆的圆心和半径
//输入：CATMathPoint 
//输出：CATMathPoint 计算圆心，double半径
//返回：
void GetCenterAndRadius( CATMathPoint iPTA,CATMathPoint iPTB,CATMathPoint iPTC,CATMathPoint &oPT,double &oRadius )
{
	double dPx,dQx,dRx;
	double dPy,dQy,dRy;
	double dPz,dQz,dRz;
	//	double dX0,dY0,dZ0;

	dPx=iPTA.GetX();
	dQx=iPTB.GetX();
	dRx=iPTC.GetX();

	dPy=iPTA.GetY();
	dQy=iPTB.GetY();
	dRy=iPTC.GetY();

	dPz=iPTA.GetZ();
	dQz=iPTB.GetZ();
	dRz=iPTC.GetZ();

	// 	//算平面法量
	// 	double pi,pj,pk;
	// 	double x1=dQx-dPx;
	// 	double x2=dRx-dPx;
	// 
	// 	double y1=dQy-dPy;
	// 	double y2=dRy-dPy;
	// 
	// 	double z1=dQz-dPz;
	// 	double z2=dRz-dPz;
	// 
	// 	pi=y1*z2-z1*y2;
	// 	pj=z1*x2-x1*z2;
	// 	pk=x1*y2-y1*x2;
	// 
	// 	//求PQ和PR的中垂线
	// 	//1，过PQ的中点(Mx,My,Mz),
	// 
	// 	double dMx,dMy,dMz;
	// 
	// 	dMx=(dPx+dQx)/2;
	// 	dMy=(dPy+dQy)/2;
	// 	dMz=(dPz+dQz)/2;
	// 
	// 	//（Mi,Mj,Mk）＝（pi，pj，pk）×（x1,y1,z1）垂直
	// 	double dMi,dMj,dMk;
	// 	dMi=pj*z1-pk*y1;
	// 	dMj=pk*x1-pi*z1;
	// 	dMk=pi*y1-pj*x1;
	// 
	// 	//2，过PR的中点(Nx,Ny,Nz),
	// 	double dNx,dNy,dNz;
	// 
	// 	dNx=(dPx+dRx)/2;
	// 	dNy=(dPy+dRy)/2;
	// 	dNz=(dPz+dRz)/2;
	// 
	// 	//（Ni,Nj,Nk）＝（pi，pj，pk）×（x2,y2,z2）垂直
	// 	double dNi,dNj,dNk;
	// 
	// 	dNi=pj*z2-pk*y2;
	// 	dNj=pk*x2-pi*z2;
	// 	dNk=pi*y2-pj*x2;
	// 
	// 	//解两直线交点
	// 	double tn;
	// 	if((dNj*dMi-dMj*dNi)!=0)
	// 	{	
	// 		tn=((dMy-dNy)*dMi+dMj*(dNx-dMx))/(dNj*dMi-dMj*dNi);
	// 	}
	// 	else if((dMi*dNk-dMk*dNi)!=0)
	// 	{	
	// 		tn=((dMz-dNz)*dMi+dMk*(dNx-dMx))/(dNk*dMi-dMk*dNi);
	// 	}
	// 	else if((dMj*dNk-dMk*dNj)!=0)
	// 	{	
	// 		tn=((dMz-dNz)*dMj+dMk*(dNy-dMy))/(dMj*dNk-dMk*dNj);
	// 	}
	// 	dX0=dNx+dNi*tn;
	// 	dY0=dNy+dNj*tn;
	// 	dZ0=dNz+dNk*tn;
	// 
	// 	//得半径
	// 	oRadius=(dX0-dPx)*(dX0-dPx)+(dY0-dPy)*(dY0-dPy)+(dZ0-dPz)*(dZ0-dPz);
	// 	oPT.SetCoord(dX0,dY0,dZ0);
	// 	oRadius=sqrt(oRadius);
	double x1=iPTA.GetX();
	double x2=iPTB.GetX();
	double x3=iPTC.GetX();

	double y1=iPTA.GetY();
	double y2=iPTB.GetY();
	double y3=iPTC.GetY();

	double z1=iPTA.GetZ();
	double z2=iPTB.GetZ();
	double z3=iPTC.GetZ();

	double a1, b1, c1, d1;
	double a2, b2, c2, d2;
	double a3, b3, c3, d3;

	a1 = (y1*z2 - y2*z1 - y1*z3 + y3*z1 + y2*z3 - y3*z2);
	b1 = -(x1*z2 - x2*z1 - x1*z3 + x3*z1 + x2*z3 - x3*z2);
	c1 = (x1*y2 - x2*y1 - x1*y3 + x3*y1 + x2*y3 - x3*y2);
	d1 = -(x1*y2*z3 - x1*y3*z2 - x2*y1*z3 + x2*y3*z1 + x3*y1*z2 - x3*y2*z1);

	a2 = 2 * (x2 - x1);
	b2 = 2 * (y2 - y1);
	c2 = 2 * (z2 - z1);
	d2 = x1 * x1 + y1 * y1 + z1 * z1 - x2 * x2 - y2 * y2 - z2 * z2;

	a3 = 2 * (x3 - x1);
	b3 = 2 * (y3 - y1);
	c3 = 2 * (z3 - z1);
	d3 = x1 * x1 + y1 * y1 + z1 * z1 - x3 * x3 - y3 * y3 - z3 * z3;

	double x, y, z;
	x = -(b1*c2*d3 - b1*c3*d2 - b2*c1*d3 + b2*c3*d1 + b3*c1*d2 - b3*c2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);
	y = (a1*c2*d3 - a1*c3*d2 - a2*c1*d3 + a2*c3*d1 + a3*c1*d2 - a3*c2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);
	z = -(a1*b2*d3 - a1*b3*d2 - a2*b1*d3 + a2*b3*d1 + a3*b1*d2 - a3*b2*d1)
		/ (a1*b2*c3 - a1*b3*c2 - a2*b1*c3 + a2*b3*c1 + a3*b1*c2 - a3*b2*c1);

	oPT.SetCoord(x,y,z);
	double r = 0.0;
	r = sqrt((x1 - x)*(x1 - x) + (y1 - y)*(y1 - y) + (z1 - z)*(z1 - z));
	r = sqrt((x2 - x)*(x2 - x) + (y2 - y)*(y2 - y) + (z2 - z)*(z2 - z));
	r = sqrt((x3 - x)*(x3 - x) + (y3 - y)*(y3 - y) + (z3 - z)*(z3 - z));
	oRadius=r;
}
//描述：创建圆Body
//输入：CATGeoFactory，CATTopData，CATMathPlane，double
//输出：CATBody
//返回：CATBoolean
HRESULT CreateCircle( CATGeoFactory_var spGeoFactory,CATTopData * topdata,CATMathPlane iMathPlane,double Radius,CATBody_var &ospBody )
{
	HRESULT hr=E_FAIL;

	CATCircle * pCircle=spGeoFactory->CreateCircle(Radius,iMathPlane);
	if (pCircle==NULL)
	{
		cout<<"CreateCircle Failed"<<endl;
		return E_FAIL;
	}

	CATCurve *piCurve = NULL;
	hr = pCircle->QueryInterface(IID_CATCurve,(void**)&piCurve);
	if(FAILED(hr) || piCurve == NULL)
	{
		cout<<"QI to IID_CATCurve is failed!"<<endl;
		return E_FAIL;
	}

	int iNum = 1;
	CATCurve ** ListOfCurves = new CATCurve * [iNum];
	CATCrvLimits * curLimits = new CATCrvLimits[iNum];
	short * wireOrientations = new short[iNum];
	ListOfCurves[0] = piCurve;

	for (int i = 0; i <iNum ; i++)
	{
		CATCurve * pLocalCurve = ListOfCurves[i];
		if (pLocalCurve != NULL)
			pLocalCurve->GetLimits(curLimits[i]);
		wireOrientations[i]=short(1);
	}

	CATTopWire * pWire = ::CATCreateTopWire(spGeoFactory, 
		topdata,
		iNum,
		ListOfCurves,
		curLimits,
		wireOrientations);

	pWire->ForceWireClosure();
	pWire->Run();

	ospBody = pWire->GetResult();

	if (pCircle!=NULL)
	{
		spGeoFactory->Remove(pCircle);
		pCircle=NULL;
	}

	if (pWire!=NULL)
	{
		delete pWire;
		pWire = NULL;
	}

	if (ListOfCurves!=NULL)
	{
		delete ListOfCurves; 
		ListOfCurves = NULL;
	}

	if (curLimits!=NULL)
	{
		delete curLimits;
		curLimits = NULL;
	}

	if (wireOrientations!=NULL)
	{
		delete wireOrientations; 
		wireOrientations = NULL;
	}


	return S_OK;
}
//描述：创建曲线的body
//输入：CATGeoFactory_var Geo工厂,CATTopData,CATCurve_var 目标曲线
//输出：CATBody_var 曲线的body
//返回：HRESULT
HRESULT CreateBodyFromCurveFunc( CATGeoFactory_var ispiGeoFactory,CATTopData * itopdata,CATCurve_var ispiCurve,CATBody_var &ospiBody )
{
	if(NULL_var == ispiGeoFactory || NULL_var == ispiCurve || NULL == itopdata)
	{
		return E_FAIL;
	}
	int iNum = 1;
	CATCurve ** arrypCurves = new CATCurve * [iNum];
	CATCrvLimits * pCurLimits = new CATCrvLimits[iNum];
	short * pWireOrientations = new short[iNum];
	arrypCurves[0] = ispiCurve;

	for (int i = 0; i <iNum ; i++)
	{
		CATCurve * pLocalCurve = arrypCurves[i];
		if (pLocalCurve != NULL)
			pLocalCurve->GetLimits(pCurLimits[i]);
		pWireOrientations[i]=short(1);
	}

	CATTopWire * pWire = ::CATCreateTopWire(ispiGeoFactory, 
		itopdata,
		iNum,
		arrypCurves,
		pCurLimits,
		pWireOrientations);

	pWire->ForceWireClosure();
	pWire->Run();

	ospiBody = pWire->GetResult();

	if (pWire!=NULL)
	{
		delete pWire;
		pWire = NULL;
	}

	if (arrypCurves!=NULL)
	{
		delete arrypCurves; 
		arrypCurves = NULL;
	}

	if (pCurLimits!=NULL)
	{
		delete pCurLimits;
		pCurLimits = NULL;
	}

	if (pWireOrientations!=NULL)
	{
		delete pWireOrientations; 
		pWireOrientations = NULL;
	}

	return TRUE;
}
//描述：修改线的颜色，线型，宽度 
//输入：CATISpecObject_var文件名称,unsigned short线型,unsigned short线宽,unsigned short红,unsigned short绿,unsigned short蓝
//输出：无
//返回：HRESULT
HRESULT SetCurveFormat( CATISpecObject_var ispSpeObj,unsigned short iMask,unsigned short iWeight,unsigned char iRed,unsigned char iGgren,unsigned char iBlue )
{
	CATIVisProperties *piGraphProp=NULL;
	HRESULT rc = ispSpeObj->QueryInterface(IID_CATIVisProperties,(void**)&piGraphProp);
	if( FAILED(rc) || piGraphProp == NULL ) return rc;

	CATVisPropertiesValues Attribut;
	//设置线宽
	Attribut.SetWidth(iWeight);
	piGraphProp->SetPropertiesAtt(Attribut,CATVPWidth,CATVPLine,0,0);
	//设置线型
	Attribut.SetLineType(iMask);
	piGraphProp->SetPropertiesAtt(Attribut,CATVPLineType,CATVPLine,0,0);
	//设置颜色
	Attribut.SetColor(iRed,iGgren,iBlue);
	piGraphProp->SetPropertiesAtt(Attribut,CATVPColor,CATVPLine,0,0);
	piGraphProp->Release();
	piGraphProp=NULL;

	CATIModelEvents *piME = NULL;
	rc = ispSpeObj->QueryInterface( IID_CATIModelEvents,(void **) &piME);
	if( FAILED(rc) || piME == NULL ) return rc;
	CATModifyVisProperties notif1(ispSpeObj, CATPathElement(ispSpeObj), CATVPLine ,CATVPWidth,Attribut);
	CATModifyVisProperties notif2(ispSpeObj, CATPathElement(ispSpeObj), CATVPLine ,CATVPLineType,Attribut);
	CATModifyVisProperties notif3(ispSpeObj, CATPathElement(ispSpeObj), CATVPLine ,CATVPColor,Attribut);
	piME->Dispatch(notif1);
	piME->Dispatch(notif2);
	piME->Dispatch(notif3);
	piME->Release();
	piME= NULL ;

	return rc;
}
//描述：修改面的颜色
//输入：CATISpecObject_var文件名称,unsigned short红,unsigned short绿,unsigned short蓝
//输出：无
//返回：HRESULT
HRESULT SetCurveFormat( CATISpecObject_var ispSpeObj,unsigned char iRed,unsigned char iGgren,unsigned char iBlue )
{
	CATIVisProperties *piGraphProp=NULL;
	HRESULT rc = ispSpeObj->QueryInterface(IID_CATIVisProperties,(void**)&piGraphProp);
	if( FAILED(rc) || piGraphProp == NULL ) return rc;

	CATVisPropertiesValues Attribut;
	//设置颜色
	Attribut.SetColor(iRed,iGgren,iBlue);
	piGraphProp->SetPropertiesAtt(Attribut,CATVPColor,CATVPLine,0,0);
	piGraphProp->Release();
	piGraphProp=NULL;

	CATIModelEvents *piME = NULL;
	rc = ispSpeObj->QueryInterface( IID_CATIModelEvents,(void **) &piME);
	if( FAILED(rc) || piME == NULL ) return rc;
	CATModifyVisProperties notif3(ispSpeObj, CATPathElement(ispSpeObj), CATVPMesh ,CATVPColor,Attribut);
	piME->Dispatch(notif3);
	piME->Release();
	piME= NULL ;

	return rc;
}
//描述：根据维数，从Cell转到body
//输入：CATGeoFactory 几何工厂, CATCell cell对象，int 维数
//输出：
//返回：CATBody body对象
CATBody* CreateBodyFromCell(CATGeoFactory *ipGeoFactory, CATCell_var ispCell, int iDimension)
{
	CATBody *pBody = ipGeoFactory->CreateBody();
	CATDomain *pDomain = pBody->CreateDomain(iDimension);
	pDomain->AddCell(ispCell);
	pBody->AddDomain(pDomain);
	return pBody;
}
//描述：根据维数，从CATDomain转到body
//输入：CATGeoFactory 几何工厂, CATDomain domain对象，int 维数
//输出：
//返回：CATBody body对象
CATBody* CreateBodyFromDomain(CATGeoFactory *ipGeoFactory, CATDomain *ipDomain, int iDimension)
{
	CATBody *pBody = NULL;
	if (ipDomain==NULL||ipGeoFactory==NULL)
	{
		return NULL;
	}
	CATLISTP(CATCell) lstCell;
	ipDomain->GetAllCells(lstCell,iDimension);
	pBody = ipGeoFactory->CreateBody();
	CATDomain *pDomainCurr = pBody->CreateDomain(iDimension);
	for (int j=1;j<=lstCell.Size();j++)
	{
		pDomainCurr->AddCell(lstCell[j]);
	}
	pBody->AddDomain(pDomainCurr);

	return pBody;
}

//在模型树上的指定GeoSet中插入新建的对象
//输入：CATIProduct_var Product对象 CATISpecObject_var CATISpecObject 对象  CATUnicodeString 名称 CATBody 对象Body
//输出：CATISpecObject_var 插入完成后的新对象
//返回：HRESULT
HRESULT InsertObjOnTree(CATIProduct_var ispProd,CATISpecObject_var ispiSpecGeoSet,CATUnicodeString istrObjName,CATBody *ipBody, CATISpecObject_var &ospiSpecObj)
{
	HRESULT rc = S_OK;
	//
	if (ispProd == NULL_var || ipBody == NULL_var)
	{
		return E_FAIL;
	}
	//
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * topdata =new CATTopData(pConfig, NULL);//topdata

	CATIPrtContainer_var ospiCont=NULL_var;
	CATGeoFactory*  pGeoFactory=GetProductGeoFactoryAndPrtCont(ispProd,ospiCont);
	if (ospiCont==NULL_var||pGeoFactory==NULL)
	{
		cout<<"GetProductGeoFactoryAndPrtCont Failed"<<endl;
		return E_FAIL;
	}
	//
	CATIDatumFactory *piDatumFactory =NULL;
	ospiCont->QueryInterface(IID_CATIDatumFactory,(void**) &piDatumFactory);
	if (piDatumFactory==NULL)
	{
		cout<<"QI CATIDatumFactory Failed"<<endl;
		return E_FAIL;
	}
	//特征化
	CATISpecObject * pTempSpec = NULL;
	rc=piDatumFactory->InstanciateDatum(ipBody,pTempSpec);
	if (pTempSpec==NULL_var)
	{
		return E_FAIL;
	}

	CATISpecObject_var spiTempSpec = pTempSpec;
	CATTry
	{
		spiTempSpec ->Update();
	}
	CATCatch(CATMfErrUpdate , pUpdateError)
	{
		return E_FAIL;
	}
	CATCatch(CATError , pError)
	{
		return E_FAIL;
	}
	CATEndTry
		//重命名
		if (istrObjName != "")
		{
			CATIAlias_var spiAlias = spiTempSpec;
			if (spiAlias != NULL_var)
			{
				spiAlias->SetAlias(istrObjName);
			}
		}
		//插入模型树中，放在该GeoSet下
		CATIGSMProceduralView_var spiProceduralView = spiTempSpec;
		if (NULL_var != spiProceduralView )
		{
			rc = spiProceduralView->InsertInProceduralView(ispiSpecGeoSet);
		}
		//
		if (ispiSpecGeoSet != NULL_var)
		{
			ispiSpecGeoSet->Update();
		}
		ospiSpecObj = spiTempSpec;
		return rc;
}

//描述：选择元素，转换成BaseUnknown，并同时返回所属Product(Instance)
//输入：CATFeatureImportAgent*对象
//输出：CATBaseUnknown*转换的元素,CATIProduct_var对应part
//返回：void
void TransferSelectToBU( CATFeatureImportAgent *pFeatAgent,CATBaseUnknown *&opBUSelection, CATIProduct_var &ospProductSeletion )
{
	HRESULT rc = E_FAIL;

	if (pFeatAgent == NULL)
	{
		return;
	}
	CATISpecObject *piSpecOnSelection = NULL;
	CATPathElement *pPath = pFeatAgent->GetValue();
	CATBaseUnknown *pSelection = pFeatAgent->GetElementValue(pPath);

	opBUSelection = pSelection;

	//返回所属Product
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospProductSeletion = spPartObject;
		return;
	}
	ospProductSeletion = pProduct;
}

//描述：选择元素，转换成BaseUnknown，并同时返回所属Product(Instance)
//输入：CATPathElementAgent* PathElementAgent对象
//输出：CATBaseUnknown_var转换后的元素,CATIProduct_var对应part
//返回：void
void TransferSelect( CATPathElementAgent *pPathElementAgent,CATBaseUnknown_var &ospBUSelection, CATIProduct_var &ospProductSeletion )
{
	HRESULT rc = E_FAIL;

	if (pPathElementAgent == NULL)
	{
		return;
	}
	CATISpecObject *piSpecOnSelection = NULL;
	CATPathElement *pPath = pPathElementAgent->GetValue();

	CATBaseUnknown *pSelection = pPathElementAgent->GetElementValue();

	ospBUSelection = pSelection;

	//返回所属Product
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospProductSeletion = spPartObject;
		return;
	}
	ospProductSeletion = pProduct;
}
//描述：判断是否为父级节点
//输入：CATIProduct_var 子节点,CATIProduct_var 父节点
//输出：CATBoolean
//返回：CATBoolean
CATBoolean CheckFather( CATIProduct_var ispChild,CATIProduct_var ispFather )
{
	if (ispChild==NULL_var||ispFather==NULL_var)
		return FALSE;

	CATIProduct_var spFather=ispChild->GetFatherProduct();
	while (spFather!=NULL_var)
	{
		if (spFather->IsEqual(ispFather))
		{
			return TRUE;
		}

		spFather=spFather->GetFatherProduct();
	}

	return FALSE;
}
//描述：判断是否为子级节点
//输入：CATIProduct_var 子节点,CATIProduct_var 父节点
//输出：CATBoolean
//返回：CATBoolean
CATBoolean CheckChild( CATIProduct_var ispChild,CATIProduct_var ispFather )
{
	if (ispChild==NULL_var||ispFather==NULL_var)
		return FALSE;

	CATLISTV(CATISpecObject_var) ListOfChildObject;
	GetAllPartsOfPrd(ispFather,ListOfChildObject);
	if (ListOfChildObject.Size()==0)
		return FALSE;

	for (int i=1;i<=ListOfChildObject.Size();i++)
	{
		if (ispChild->IsEqual(ListOfChildObject[i]))
		{
			return TRUE;
		}
	}

	return FALSE;	
}
//描述：获取轴系的原点
//输入：CATIProduct_var所在part,CATISpecObject_var轴系对象
//输出：CATMathPoint原点,CATMathVector方向1,CATMathVector方向2,CATMathVector方向3
//返回：HRESULT
HRESULT GetAxisOriginPoint(CATISpecObject_var ispAxiasObject, CATMathPoint &oMathPoint, CATMathVector &oFirstDirection, CATMathVector &oSecondDirection, CATMathVector &oThirdDirection )
{
	if (ispAxiasObject==NULL_var)
		return E_FAIL;

	CATIMf3DAxisSystem_var sp3DAxisSystem = ispAxiasObject;
	if (NULL_var == sp3DAxisSystem)
		return E_FAIL;

	CATMathAxis oMathAxis;
	sp3DAxisSystem->GetMathAxis(oMathAxis);

	oMathAxis=oMathAxis;

	CATMathPoint ioOrigin;
	CATMathVector ioFirstDirection;
	CATMathVector ioSecondDirection;
	CATMathVector ioThirdDirection;
	oMathAxis.GetOrigin(ioOrigin);
	oMathAxis.GetDirections(ioFirstDirection,ioSecondDirection,ioThirdDirection);

	oMathAxis.Dump();

	oMathPoint=ioOrigin;
	oFirstDirection=ioFirstDirection;
	oSecondDirection=ioSecondDirection;
	oThirdDirection=ioThirdDirection;

	return S_OK;
}

//描述：检查是否同一个参考对象
//输入：CATIProduct_var对象1,CATIProduct_var对象2
//输出：HRESULT
//返回：HRESULT
HRESULT CheckSameReferencePart( CATIProduct_var spiPro1,CATIProduct_var spiPro2 )
{
	if (spiPro1==NULL_var||spiPro2==NULL_var)
		return E_FAIL;

	CATIProduct_var spiRefPro1 = spiPro1->GetReferenceProduct();
	CATIProduct_var spiRefPro2 = spiPro2->GetReferenceProduct();
	if (spiRefPro1==NULL_var||spiRefPro2==NULL_var)
		return E_FAIL;

	if (spiRefPro1->IsEqual(spiRefPro2))
	{
		return S_OK;
	}

	return E_FAIL;
}
//描述：获取最小距离
//输入：CATBaseUnknown_var对象1,CATBaseUnknown_var对象2
//输出：CATMathPoint点1,CATMathPoint点2,double距离,CATBoolean是否成功
//返回：void
void GetMinDistance( CATBaseUnknown_var spiSpec1, CATBaseUnknown_var spiSpec2, CATMathPoint &ioMathPoint1, CATMathPoint &ioMathPoint2, double &minDistance, CATBoolean &oissucess )
{
	CATTry 
	{
		CATIMeasurableInContext_var spMeasurableInContext1 = spiSpec1;
		CATIMeasurableInContext_var spMeasurableInContext2 = spiSpec2;
		CATIMeasurable_var spMeasurable2 = spiSpec2;
		if (spMeasurableInContext1 == NULL_var) return ;
		if (spMeasurableInContext2 == NULL_var) return ;
		if (spMeasurable2 == NULL_var) return ;

		CATMathAxis ioAxis;
		double oMinDis = 9999.0;
		spMeasurableInContext2->GetAxisSystemFromMeasurable(ioAxis);
		spMeasurableInContext1->MinimumDistance(spMeasurable2,ioAxis,oMinDis,ioMathPoint1,ioMathPoint2);
		minDistance = oMinDis;
		oissucess=TRUE;
	}
	CATCatch(CATError , pError)
	{
		return ;
	}
	CATEndTry
}

//描述：创建平面的body
//输入：CATGeoFactory_var geo工厂,CATTopData*对象,CATMathPlane数学面
//输出：CATBody_var平面的body
//返回：CATBoolean
CATBoolean CreatePlaneBody( CATGeoFactory_var spGeoFactory,CATTopData * topdata, CATMathPlane iMathPlane,CATBody_var &ospPlaneBody )
{
	HRESULT hr=E_FAIL;

	if (spGeoFactory==NULL_var)
		return FALSE;

	CATPlane *piNewPlane=NULL;
	piNewPlane=spGeoFactory->CreatePlane(iMathPlane);
	if (piNewPlane==NULL)
	{
		cout<<"CreatePlane Failed"<<endl;
		return FALSE;
	}

	CATSurface *iNewSurface = NULL;
	hr = piNewPlane->QueryInterface(IID_CATSurface,(void**)&iNewSurface);
	if(FAILED(hr) || iNewSurface == NULL)
	{
		cout<<"QI to IID_CATSurface is failed!"<<endl;
		return FALSE;
	}

	CATSurLimits surMaxLimits;
	iNewSurface->GetLimits(surMaxLimits) ;

	CATTopSkin * TopSkin =CATCreateTopSkin(spGeoFactory,topdata,iNewSurface,&surMaxLimits);
	//CATICGMTopSkin * TopSkin =CATCGMCreateTopSkin(pGeoFactory,topdata,iNewSurface,&surMaxLimits);
	if (TopSkin==NULL)
	{
		cout<<"CATCGMCreateTopSkin Failed"<<endl;
		return FALSE;
	}

	TopSkin->Run();

	CATBody*pTopPlaneBody=NULL;
	pTopPlaneBody = TopSkin->GetResult();
	if (pTopPlaneBody==NULL)
	{
		cout<<"pTopPlaneBody==NULL"<<endl;
		return FALSE;
	}

	if (TopSkin!=NULL)
	{
		delete TopSkin;
		TopSkin = NULL;
	}

	ospPlaneBody=pTopPlaneBody;

	return TRUE;
}

//描述：创建平面的body
//输入：CATGeoFactory_var geo工厂,CATTopData*对象,CATMathPlane数学面
//输出：CATBody_var平面的body
//返回：CATBoolean
CATBoolean CreateFaceBody( CATGeoFactory_var spGeoFactory,CATTopData * topdata, CATFace_var ispFace,CATBody_var &ospSurfaceBody )
{
	HRESULT hr=E_FAIL;

	if (spGeoFactory==NULL_var || ispFace==NULL_var)
		return FALSE;

	CATSurface *iNewSurface = NULL;
	iNewSurface = ispFace->GetSurface();
	if(iNewSurface == NULL)
	{
		return FALSE;
	}

	CATSurLimits surMaxLimits;
	iNewSurface->GetLimits(surMaxLimits) ;

	CATTopSkin * TopSkin =CATCreateTopSkin(spGeoFactory,topdata,iNewSurface,&surMaxLimits);
	//CATICGMTopSkin * TopSkin =CATCGMCreateTopSkin(pGeoFactory,topdata,iNewSurface,&surMaxLimits);
	if (TopSkin==NULL)
	{
		cout<<"CATCGMCreateTopSkin Failed"<<endl;
		return FALSE;
	}

	TopSkin->Run();

	CATBody*pTopSurfaceBody=NULL;
	pTopSurfaceBody = TopSkin->GetResult();
	if (pTopSurfaceBody==NULL)
	{
		cout<<"pTopPlaneBody==NULL"<<endl;
		return FALSE;
	}

	if (TopSkin!=NULL)
	{
		delete TopSkin;
		TopSkin = NULL;
	}

	ospSurfaceBody=pTopSurfaceBody;

	return TRUE;
}

//描述：投影
//输入：CATGeoFactory* ,CATTopData*,CATBody* 投影元素,CATBody* 投影目标(surface的body)
//输出：CATBody 投影结果
//返回：HRESULT
CATBody* CreateTopProject(CATGeoFactory* ipGeoFactory, CATTopData* itopdata,CATBody* iBody1,CATBody* iBody2)
{
	if (ipGeoFactory==NULL||itopdata==NULL||iBody1 == NULL||iBody1 == NULL)
	{
		return NULL;
	}

	//做投影
	CATHybProject * HybProject=CATCreateTopProject(ipGeoFactory,itopdata,iBody1,iBody2,0) ;
	if (HybProject==NULL)
	{
		return NULL;
	}
	HybProject->Run();

	CATBody* pResultBody= HybProject->GetResult();
	if (pResultBody==NULL)
	{
		return NULL;
	}

	return pResultBody;
}
//描述：获取曲面中点
//输入：CATBaseUnknown_var 曲面
//输出：CATMathPoint 数学点
//返回：HRESULT
HRESULT GetCenterOfSurface( CATBaseUnknown_var ispiSpecObject,CATMathPoint &omathOriginalPoint )
{
	CATBoolean isMathPlane = FALSE;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	double maxAreaValue=0.0;
	if(spBody != NULL_var ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 2 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;
			CATFace_var spFace = spCell;
			if(spFace == NULL_var) 
			{
				cout<<"CATFace_var is NULL_var."<<endl;
				continue;
			}

			CATSurParam oCenterParam;
			spFace->EstimateCenterParam(oCenterParam);

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) 
			{
				cout<<"CATSurface_var is NULL_var."<<endl;
				continue;
			}

			omathOriginalPoint = spSurface->EvalPoint(oCenterParam);

			return S_OK;
		}
	}
	else  
	{
		cout<<"Get Body From Feature is failed."<<endl;
		return E_FAIL;
	}

	return S_OK;
}
//描述：求出Body的6个方向的极值，以此推导出包络体----------该方式求出的包络体较精确
//输入：CATBody_var Body对象 CATIProduct_var  Product对象 CATMathVector 方向1 CATMathVector 方向2 CATMathVector方向3
//输出：CATMathBox 3D包围盒
//返回：HRESULT
HRESULT GetBodyBoxFromExtremePt( CATBody_var spBody, CATIProduct_var ispiProduct, CATMathVector VAxeX, CATMathVector VAxeY, CATMathVector VAxeZ, vector<CATMathPoint> &olstEtremePts )
{
	HRESULT rc = S_OK;

	CATGeoFactory_var spGeoFac=spBody->GetContainer();

	if (spGeoFac==NULL_var)

	{

		return E_FAIL;

	}

	CATBody * piTransBody = spBody;
	if (piTransBody==NULL)
	{
		return E_FAIL;
	}

	//获得特征的6个方向极值点

	CATBody_var spxyzmaxBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,1,spxyzmaxBody);



	CATBody_var spxyzminBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeX,VAxeY

		,VAxeZ,2,spxyzminBody);



	CATBody_var spyzxmaxBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,1,spyzxmaxBody);



	CATBody_var spyzxminBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeY,VAxeZ,VAxeX

		,2,spyzxminBody);



	CATBody_var spzxymaxBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,1,spzxymaxBody);



	CATBody_var spzxyminBody=NULL_var;

	CreateExtremePoint(piTransBody,spGeoFac

		,VAxeZ,VAxeX,VAxeY

		,2,spzxyminBody);



	//过6个极值点做6个平面

	CATMathPoint zxymaxMathPoint;

	CATMathPoint zxyminMathPoint;

	GetMathPtFromBody(spzxymaxBody,zxymaxMathPoint);

	GetMathPtFromBody(spzxyminBody,zxyminMathPoint);

	CATMathPlane zxymaxXYPlane(zxymaxMathPoint,VAxeZ);

	CATMathPlane zxyminXYPlane(zxyminMathPoint,VAxeZ);




	CATMathPoint xyzmaxMathPoint;

	CATMathPoint xyzminMathPoint;

	GetMathPtFromBody(spxyzmaxBody,xyzmaxMathPoint);

	GetMathPtFromBody(spxyzminBody,xyzminMathPoint);

	CATMathPlane xyzmaxYZPlane(xyzmaxMathPoint,VAxeX);

	CATMathPlane xyzminYZPlane(xyzminMathPoint,VAxeX);




	CATMathPoint yzxmaxMathPoint;

	CATMathPoint yzxminMathPoint;

	GetMathPtFromBody(spyzxmaxBody,yzxmaxMathPoint);

	GetMathPtFromBody(spyzxminBody,yzxminMathPoint);

	CATMathPlane yzxmaxZXPlane(yzxmaxMathPoint,VAxeY);

	CATMathPlane yzxminZXPlane(yzxminMathPoint,VAxeY);

	zxymaxMathPoint.Dump();
	zxyminMathPoint.Dump();
	xyzmaxMathPoint.Dump();
	xyzminMathPoint.Dump();
	yzxmaxMathPoint.Dump();
	yzxminMathPoint.Dump();

	//平面求相交线

	CATMathLine zxymaxXYAndxyzmaxYZ;

	zxymaxXYPlane.Intersect(xyzmaxYZPlane,zxymaxXYAndxyzmaxYZ);

	CATMathPoint zxymaxXYAndxyzmaxYZPt;

	zxymaxXYAndxyzmaxYZ.GetOrigin(zxymaxXYAndxyzmaxYZPt);



	CATMathLine zxymaxXYAndxyzminYZ;

	zxymaxXYPlane.Intersect(xyzminYZPlane,zxymaxXYAndxyzminYZ);

	CATMathPoint zxymaxXYAndxyzminYZPt;

	zxymaxXYAndxyzminYZ.GetOrigin(zxymaxXYAndxyzminYZPt);



	CATMathLine zxymaxXYAndyzxmaxZX;

	zxymaxXYPlane.Intersect(yzxmaxZXPlane,zxymaxXYAndyzxmaxZX);

	CATMathPoint zxymaxXYAndyzxmaxZXPt;

	zxymaxXYAndyzxmaxZX.GetOrigin(zxymaxXYAndyzxmaxZXPt);



	CATMathLine zxymaxXYAndyzxminZX;

	zxymaxXYPlane.Intersect(yzxminZXPlane,zxymaxXYAndyzxminZX);

	CATMathPoint zxymaxXYAndyzxminZXPt;

	zxymaxXYAndyzxminZX.GetOrigin(zxymaxXYAndyzxminZXPt);



	//求出相交点，即为包围盒上表面的四个端点

	CATMathPoint projectMathPt1;

	zxymaxXYAndyzxmaxZX.Project(zxymaxXYAndxyzmaxYZPt,

		projectMathPt1);





	CATMathPoint projectMathPt2;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxmaxZXPt,

		projectMathPt2);





	CATMathPoint projectMathPt3;

	zxymaxXYAndxyzminYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt3);





	CATMathPoint projectMathPt4;

	zxymaxXYAndxyzmaxYZ.Project(zxymaxXYAndyzxminZXPt,

		projectMathPt4);





	//将四个投影点投影到zxyminXYPlane

	CATMathPoint projectMathPt5,projectMathPt6,projectMathPt7,projectMathPt8;

	zxyminXYPlane.Project(projectMathPt1,projectMathPt5);

	zxyminXYPlane.Project(projectMathPt2,projectMathPt6);

	zxyminXYPlane.Project(projectMathPt3,projectMathPt7);

	zxyminXYPlane.Project(projectMathPt4,projectMathPt8);


	/*
	projectMathPt1=transFather*projectMathPt1;

	projectMathPt2=transFather*projectMathPt2;

	projectMathPt3=transFather*projectMathPt3;

	projectMathPt4=transFather*projectMathPt4;

	projectMathPt5=transFather*projectMathPt5;

	projectMathPt6=transFather*projectMathPt6;

	projectMathPt7=transFather*projectMathPt7;

	projectMathPt8=transFather*projectMathPt8;

	*/

	//
	olstEtremePts.push_back(projectMathPt1);
	olstEtremePts.push_back(projectMathPt2);
	olstEtremePts.push_back(projectMathPt3);
	olstEtremePts.push_back(projectMathPt4);
	olstEtremePts.push_back(projectMathPt5);
	olstEtremePts.push_back(projectMathPt6);
	olstEtremePts.push_back(projectMathPt7);
	olstEtremePts.push_back(projectMathPt8);

	return rc;
}
void GetMathPointFromBody(CATBody*ipBody,CATLISTV(CATMathPoint) &LstMathPoint)
{
	if (ipBody==NULL)
		return;

	CATLISTP(CATCell) LISTCell; 
	ipBody->GetAllCells( LISTCell, 0 ); 
	if (LISTCell.Size()==0)
		return ;

	for( int index = 1; index <= LISTCell.Size(); index++ )
	{ 
		CATCell_var spCell = LISTCell[index]; 
		if(spCell == NULL_var) 
		{
			cout<<"CATCell_var is NULL_var."<<endl;
			continue;
		}

		CATVertex_var spVertex = spCell;
		if(spVertex == NULL_var) 
		{
			cout<<"CATVertex is NULL_var."<<endl;
			continue;
		}

		CATPoint *pPoint = spVertex->GetPoint();
		if(pPoint == NULL)
		{
			cout<<"GetPoint failed."<<endl;
			continue;
		}

		CATMathPoint  oMathPoint;
		pPoint->GetMathPoint(oMathPoint);

		LstMathPoint.Append(oMathPoint);

		//if (pPoint!=NULL)
		//{
		//	pPoint->Release();
		//	pPoint=NULL;
		//}

	}

}
//描述：从Body获取数学点
//输入：CATBody_var目标body
//输出：CATMathPoint数学点
//返回：void
HRESULT GetMathPtFromBody( CATBody_var ispPointBody,CATMathPoint& oMathPoint )
{
	if(ispPointBody != NULL_var)

	{

		//计算所有点的角度

		CATLISTP(CATCell) LISTCell;

		ispPointBody->GetAllCells( LISTCell, 0 );

		for( int index = 1; index <= LISTCell.Size(); index++ )

		{

			CATCell * pCell = LISTCell[index];

			if(pCell == NULL)

			{

				cout<<"CATCell is NULL."<<endl;

				continue;

			}



			CATCell_var spCell = pCell;



			CATVertex_var spVertex = spCell;

			if(spVertex == NULL_var)

			{

				cout<<"CATVertex is NULL_var."<<endl;

				continue;

			}



			CATPoint *pPoint = spVertex->GetPoint();

			if(pPoint == NULL)

			{

				cout<<"GetPoint failed."<<endl;

				continue;

			}



			pPoint->GetMathPoint(oMathPoint);

			return S_OK;

		}

	}

	return E_FAIL;
}
//描述：Body根据3个方向获得6个极值点的Body
//输入：CATBody_var Body对象 CATGeoFactory_var  GeoFactory对象 CATMathVector 方向1 CATMathVector 方向2 CATMathVector方向3  int Max or Min
//输出：CATBody_var 6个极值点的Body
//返回：void
void CreateExtremePoint( CATBody_var ispBody,CATGeoFactory_var ispGeoFac , CATMathVector iFirstVT,CATMathVector iSecondVT, CATMathVector iThirdVT,int iMaxOrMin,CATBody_var &ospPointBody )
{
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();

	CATTopData topdata(pConfig);

	CATMinMax minormax;

	if (iMaxOrMin==1)//最大

	{

		minormax=CATMaximum;

	}

	else//最小

	{

		minormax=CATMinimum;

	}



	CATMathPoint Origin(0,0,0);

	CATTopBodyExtremum  *pOption1  =  CATCreateDirBodyExtremum(ispGeoFac,  

		&topdata,ispBody,minormax,iFirstVT,Origin)  ; 

	CATBody_var spOptionBody1=NULL_var;

	if  (pOption1)

	{

		pOption1->Run();

		cout << "Min along X " << pOption1->GetExtremum() << endl;

		spOptionBody1 =  pOption1->GetResult();

		//pOption1->Release();

		//pOption1  =  NULL;





		CATTopBodyExtremum  *pOption2  =  CATCreateDirBodyExtremum(ispGeoFac,  

			&topdata,spOptionBody1,minormax,iSecondVT,Origin)  ; 

		CATBody_var spOptionBody2=NULL_var;

		if  (pOption2)

		{

			pOption2->Run();

			cout << "Min along X " << pOption2->GetExtremum() << endl;

			spOptionBody2 =  pOption2->GetResult();

			//pOption2->Release();

			//pOption2  =  NULL;



			//最后得到点

			CATTopBodyExtremum  *pOption3  =  CATCreateDirBodyExtremum(ispGeoFac,  

				&topdata,spOptionBody2,minormax,iThirdVT,Origin)  ; 

			CATBody_var spOptionBody3=NULL_var;

			if  (pOption3)

			{

				pOption3->Run();

				cout << "Min along X " << pOption3->GetExtremum() << endl;

				spOptionBody3 =  pOption3->GetResult();

				//pOption3->Release();

				//pOption3  =  NULL;

				ospPointBody=spOptionBody3;

			}

		}

	}
}
//描述：计算出一组点的3D包围盒，根据定义的轴系
//输入：vector <CATMathPoint>   空间点 CATMathPoint 空间点 CATMathVector 方向1 CATMathVector 方向2 CATMathVector方向3 
//输出：CATMathPoint DBox包围盒
//返回：void
void Create3DBoxWithAxis( vector <CATMathPoint> points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector viewZAxis,CATMathPoint onew3DBox[8] )
{
	CATMathPoint org = viewOrg;
	CATMathVector xVec = viewXAxis;
	CATMathVector yVec = viewYAxis;
	CATMathVector zVec = viewZAxis;
	CATMathVector nzVec = zVec * -1;
	xVec.Normalize();
	yVec.Normalize();
	zVec.Normalize();
	//CATMathPlane xyPlane(org,xVec,yVec);
	//CATMathPlane xzPlane(org,xVec,zVec);
	CATMathPoint* xyPlaneBox = new CATMathPoint[4];
	PointsProjectingInTo2DBoxOnViewAlongDirection(points,org,xVec,yVec,zVec,xyPlaneBox);
	CATMathPoint* xzPlaneBox = new CATMathPoint[4];
	PointsProjectingInTo2DBoxOnViewAlongDirection(points,org,xVec,zVec,yVec,xzPlaneBox);
	CATMathLine xLine(org,xVec);
	double tempx;
	CATMathPoint basepoint = PointProjectingOnLineAlongDirection(xyPlaneBox[0], xLine,yVec ,tempx);

	double basepoint_arr[3] = {0.0,0.0,0.0};
	double xyPlaneBox0_arr[3] = {0.0,0.0,0.0};
	double xyPlaneBox1_arr[3] = {0.0,0.0,0.0};
	double moveVec0_arr[3] = {0.0,0.0,0.0};
	double moveVec1_arr[3] = {0.0,0.0,0.0};
	basepoint.GetCoord(basepoint_arr);
	xyPlaneBox[0].GetCoord(xyPlaneBox0_arr);
	xyPlaneBox[1].GetCoord(xyPlaneBox1_arr);
	D3VectorSetFromTwoPoint(basepoint_arr,xyPlaneBox0_arr,moveVec0_arr);
	D3VectorSetFromTwoPoint(basepoint_arr,xyPlaneBox1_arr,moveVec1_arr);
	CATMathVector moveVec0(moveVec0_arr);
	CATMathVector moveVec1(moveVec1_arr);
	delete []xyPlaneBox;

	onew3DBox[0] = ( xzPlaneBox[1] + moveVec0);
	onew3DBox[1] = ( xzPlaneBox[0] + moveVec0);	//最大
	onew3DBox[2] = ( xzPlaneBox[3] + moveVec0);
	onew3DBox[3] = ( xzPlaneBox[2] + moveVec0);
	onew3DBox[4] = ( xzPlaneBox[1] + moveVec1);
	onew3DBox[5] = ( xzPlaneBox[0] + moveVec1);
	onew3DBox[6] = ( xzPlaneBox[3] + moveVec1);
	onew3DBox[7] = ( xzPlaneBox[2] + moveVec1);	//最小
	delete []xzPlaneBox;
}
//描述：求出一个点投影到某个直线上的位置
//输入：CATMathPoint 数学点 CATMathLine 直线 CATMathVector 方向
//输出：double Length
//返回：CATMathPoint
CATMathPoint PointProjectingOnLineAlongDirection( CATMathPoint iProjectingPoint, CATMathLine iLine, CATMathVector iDirection, double & oLength )
{
	double line1P1[3] = {0.0,0.0,0.0};
	iLine.GetOrigin().GetCoord(line1P1);
	double line1P2[3] = {0.0,0.0,0.0};
	CATMathVector line1Vec = (CATMathVector)iLine.GetDirection();
	line1Vec.Normalize();
	(iLine.GetOrigin() + line1Vec).GetCoord(line1P2);

	double line2P1[3] = {0.0,0.0,0.0};
	iProjectingPoint.GetCoord(line2P1);
	CATMathVector line2Vec = iDirection;
	line2Vec.Normalize();
	double line2P2[3] = {0.0,0.0,0.0};
	(iProjectingPoint + line2Vec).GetCoord(line2P2);

	double crossPointArray[3] = {0.0,0.0,0.0};
	D3LinesGetCrossPoint( line1P1,line1P2,line2P1,line2P2,crossPointArray);
	CATMathPoint crossPoint(crossPointArray);

	double line1VecUnit[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint( line1P1,line1P2   ,line1VecUnit );
	double projVec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint( line1P1,crossPointArray   ,projVec );
	double projVecUnit[3] = {0.0,0.0,0.0};
	D3VectorUnit(  projVec , projVecUnit);
	oLength = D3VectorLen(projVec);
	if (! D3VectorEqual( line1VecUnit,projVecUnit  ))
	{
		oLength = 0 - oLength;
	}
	return crossPoint;
}
//求出一个空间点投影到某个平面上的位置
//输入：CATMathPoint 数学点 CATMathPoint 数学点 CATMathVector 方向1 CATMathVector 方向2 CATMathVector 方向3
//输出：
//返回：CATMathPoint
CATMathPoint PointProjectingOnViewAlongDirection( CATMathPoint ipoint, CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector iDirection )
{
	double line1P1[3] = {0.0,0.0,0.0};
	ipoint.GetCoord(line1P1);

	double line1P2[3] = {0.0,0.0,0.0};
	CATMathVector line1CATVec = (CATMathVector)iDirection;
	line1CATVec.Normalize();
	(ipoint + line1CATVec).GetCoord(line1P2);
	double line1Vec[3] = {0.0,0.0,0.0};
	line1CATVec.GetCoord(line1Vec);

	double line2P1[3] = {0.0,0.0,0.0};
	CATMathPoint org = viewOrg;

	double Direction[3] = {0.0,0.0,0.0};
	double viewXAxisArray[3] = {0.0,0.0,0.0};
	double viewYAxisArray[3] = {0.0,0.0,0.0};
	viewXAxis.GetCoord(viewXAxisArray);
	viewYAxis.GetCoord(viewYAxisArray);
	D3CrossProduct(viewXAxisArray,viewYAxisArray,Direction);

	double originPoint[3] = {0.0,0.0,0.0};
	org.GetCoord(originPoint);
	D3PointProjectOnPlane(line1P1, originPoint, Direction,line2P1);

	double line2P2[3] = {0.0,0.0,0.0};
	double line3Vec[3] = {0.0,0.0,0.0};
	D3VectorSetFromTwoPoint(line1P1,line2P1,line3Vec);
	double line1line2Angle =mathPi * 0.5 - D3VectorAngle(line3Vec,line1Vec);

	double vnormal[3] = {0.0,0.0,0.0};
	D3CrossProduct(line3Vec,line1Vec,vnormal);

	if (D3VectorLen(vnormal) == 0)
	{
		return CATMathPoint(line2P1);
	}

	double line2Vec[3] = {0.0,0.0,0.0};
	D3VectorRotate(line1Vec, vnormal,line1line2Angle,line2Vec);
	D3PointMove(line2P1,line2Vec,line2P2);

	double crossPointArray[3] = {0.0,0.0,0.0};
	D3LinesGetCrossPoint( line1P1,line1P2,line2P1,line2P2,crossPointArray);
	return CATMathPoint(crossPointArray);
}
//描述：求出一组空间点投影到某个平面上的2DBox包围盒
//输入：vector <CATMathPoint>   空间点 CATMathPoint 空间点 CATMathVector 方向1 CATMathVector 方向2 CATMathVector方向3 
//输出：CATMathPoint 2DBox包围盒
//返回：void
void PointsProjectingInTo2DBoxOnViewAlongDirection( vector <CATMathPoint> points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathVector iDirection ,CATMathPoint pro2dBox[4] )
{
	vector <CATMathPoint> boxProjection;
	for(int i = 0 ; i < points.size() ; i++)
	{
		CATMathPoint temp = PointProjectingOnViewAlongDirection( points[i], viewOrg,viewXAxis,viewYAxis, iDirection);
		boxProjection.push_back (temp);
	}
	//CAAMessageBox(TransformVector3DBoxInToString(boxProjection),CATUnicodeString("Vector2DBOX"));
	Get2DBoxOfPointsOnView(boxProjection,  viewOrg,viewXAxis,viewYAxis, pro2dBox ) ;
	//delete boxProjection;
}
//描述：在某个平面上，求出一组点的2D包围盒
//输入：vector <CATMathPoint> 一组点 CATMathPoint MathPoint CATMathVector 方向1 CATMathVector 方向2 
//输出：CATMathPoint 2DBox包围盒
//返回：void
void Get2DBoxOfPointsOnView( vector <CATMathPoint> points,CATMathPoint viewOrg,CATMathVector viewXAxis,CATMathVector viewYAxis,CATMathPoint points2dBox[4] )
{
	CATMathPoint org = viewOrg;
	CATMathVector xVec = viewXAxis;
	CATMathVector yVec = viewYAxis;
	xVec.Normalize();
	yVec.Normalize();
	CATMathLine xline(org,xVec);
	CATMathLine yline(org,yVec);
	double x1,x2,y1,y2;
	for(int i = 0 ; i < points.size() ; i++)
	{
		double tempx;
		PointProjectingOnLineAlongDirection(points[i],xline,yVec ,tempx);
		double tempy;
		PointProjectingOnLineAlongDirection(points[i],yline,xVec ,tempy);
		if (i==1)
		{
			x1 = tempx;
			x2 = tempx;
			y1 = tempy;
			y2 = tempy;
		}
		else
		{
			if(x1 > tempx)
			{
				x1 = tempx;
			}
			else if(x2 < tempx)
			{
				x2 = tempx;
			}
			if(y1 > tempy)
			{
				y1 = tempy;
			}
			else if(y2 < tempy) 
			{
				y2 = tempy;
			}
		}

	}
	points2dBox[0] = (org + (xVec * x1) + (yVec * y1));	//最大 
	points2dBox[1] = (org + (xVec * x1) + (yVec * y2));
	points2dBox[2] = (org + (xVec * x2) + (yVec * y2));	//最小
	points2dBox[3] = (org + (xVec * x2) + (yVec * y1));	
}

//描述：获取数学面
//输入：CATISpecObject对象
//输出：CATMathPlane
//返回：HRESULT
HRESULT GetMathPlaneFromBody(CATBody_var ispBody,CATMathPlane& oMathPlane )
{
	if(NULL_var == ispBody)
	{
		return E_FAIL;
	}
	CATBoolean isMathPlane = FALSE;
	CATBody_var spBody = ispBody;
	double maxAreaValue=0.0;
	if(spBody != NULL ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 2 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) {
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;
			CATFace_var spFace = spCell;
			if(spFace == NULL_var) {
				cout<<"CATFace_var is NULL_var."<<endl;
				continue;
			}

			CATSurParam oCenterParam;
			spFace->EstimateCenterParam(oCenterParam);

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) {
				cout<<"CATSurface_var is NULL_var."<<endl;
				continue;
			}
			CATMathPoint mathPlaneOriginalPoint = spSurface->EvalPoint(oCenterParam);

			double areaValue;
			areaValue = spFace->CalcArea();
			if (areaValue>maxAreaValue)
			{
				maxAreaValue = areaValue;
				CATIMeasurableInContext_var spiMeasurableInContext = NULL_var;
				spiMeasurableInContext = spFace;
				if (spiMeasurableInContext == NULL_var)
				{
					cout<<"Get CATIMeasurableInContext failed."<<endl;
					continue;
				}

				CATMeasurableName shapeName;
				spiMeasurableInContext->GetShapeName(shapeName);
				if (shapeName == CATMeasurablePlane)
				{
					spiMeasurableInContext->GetPlane(oMathPlane);
					oMathPlane.SetOrigin(mathPlaneOriginalPoint);
					isMathPlane = TRUE;
				}
			}
		}
	}
	else  cout<<"Get Body From Feature is failed."<<endl;

	if (isMathPlane)
	{
		return S_OK;
	}
	return E_FAIL;
}
//描述：获取所选择的面的数学平面
//输入：CATBaseUnknown_var 对象
//输出：
//返回：CATMathPlane
CATMathPlane GetMathPlane(CATBaseUnknown_var ispiSpecObject)
{
	CATMathPlane MathPlane;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody != NULL ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 2 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;

			CATFace_var spFace = spCell;
			if(spFace == NULL_var)
			{
				cout<<"CATFace_var is NULL_var."<<endl;
				continue;
			}

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) 
			{
				cout<<"CATSurface_var is NULL_var."<<endl;
				continue;
			}

			CATPlane *pPlane = NULL;
			HRESULT rc = spSurface->QueryInterface(IID_CATPlane,(void**)&pPlane);
			if(FAILED(rc) || pPlane == NULL) 
			{
				cout<<"QI to CATPlane is failed!"<<endl;
				continue;
			}			

			MathPlane = pPlane->GetAxis();
		}
	}
	else  cout<<"Get Body From Feature is failed."<<endl;

	return MathPlane;
}

//描述：获取所选择线的数学线
//输入：CATBaseUnknown_var 对象
//输出：
//返回：CATMathLine
CATMathLine GetMathLine(CATBaseUnknown_var ispiSpecObject)
{
	CATMathLine resultMathLine;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody != NULL ) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0); 
		if(LISTCell.Size()<2)
		{
			cout<<"LISTCell size != 2"<<endl;
		}
		else
		{
			CATVertex_var spV1 = LISTCell[1];
			CATVertex_var spV2 = LISTCell[LISTCell.Size()];

			CATPoint * pt1 = spV1->GetPoint();
			CATPoint * pt2 = spV2->GetPoint();

			CATMathPoint mathPt1;
			CATMathPoint mathPt2;
			pt1->GetMathPoint(mathPt1);
			pt2->GetMathPoint(mathPt2);
			CATMathVector vec = mathPt2 - mathPt1;

			resultMathLine.Set(mathPt1, vec);
		}		
	}
	else  
		cout<<"Get Body From Feature is failed."<<endl;

	return resultMathLine;
}
//描述：获得所选择点的数学点
//输入：CATBaseUnknown_var 对象
//输出：
//返回：CATMathPoint
CATMathPoint GetMathPoint(CATBaseUnknown_var ispiSpecPoint)
{
	CATMathPoint oMathPoint;
	CATPoint_var spPoint = GetPoint(ispiSpecPoint);
	if (spPoint==NULL_var)
	{
		cout<<"GetPoint Failed"<<endl;
		return oMathPoint;
	}

	double x,y,z;
	spPoint->GetCoord(x,y,z);
	spPoint->GetMathPoint(oMathPoint);

	return oMathPoint;
}

//描述：获得所选点
//输入：CATBaseUnknown_var 对象
//输出：
//返回：CATPoint_var
CATPoint_var GetPoint(CATBaseUnknown_var ispiSpecObject)
{
	CATPoint_var spPoint=NULL_var;
	CATBody_var spBody = GetBodyFromFeature(ispiSpecObject);
	if(spBody != NULL_var) 
	{
		CATLISTP(CATCell) LISTCell; 
		spBody->GetAllCells( LISTCell, 0 ); 
		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell * pCell = LISTCell[index]; 
			if(pCell == NULL) 
			{
				cout<<"CATCell is NULL."<<endl;
				continue;
			}

			CATCell_var spCell = pCell;

			CATVertex_var spVertex = spCell;
			if(spVertex == NULL_var) 
			{
				cout<<"CATVertex is NULL_var."<<endl;
				continue;
			}

			CATPoint *pPoint = spVertex->GetPoint();
			if(pPoint == NULL)
			{
				cout<<"GetPoint failed."<<endl;
				continue;
			}

			spPoint = pPoint;
		}
	}
	return spPoint;
}
//描述：获取GeoFactory和container
//输入：CATIProduct_var目标part对应product
//输出：CATIPrtContainer_var prt容器对象
//返回：CATGeoFactory* geo工厂
CATGeoFactory* GetProductGeoFactoryAndPrtCont( CATIProduct_var ispProduct,CATIPrtContainer_var &ospiCont )
{
	CATIProduct_var spiRefProduct=ispProduct->GetReferenceProduct();
	CATILinkableObject_var spiRefLink=spiRefProduct;
	CATDocument *opDocument=NULL;
	if( !!spiRefLink ) 
	{
		opDocument = spiRefLink->GetDocument();
	}
	CATGeoFactory*pGeoFactory=GetCATGeoFactory(opDocument);
	//GetPrtContFromPrd(ispProduct,ospiCont);
	ospiCont = GetPrtContainer(ispProduct);
	return pGeoFactory;
}
//描述：获取Doc
//输入：CATIProduct_var product对象
//输出：CATDocument* 对象的文档
//返回：HRESULT
HRESULT GetReferencePrdDocument( CATIProduct_var ispiInstanceProduct,CATDocument *&opDocument )
{
	HRESULT rc=E_FAIL;
	opDocument = NULL;

	if(ispiInstanceProduct==NULL_var) return rc;

	CATIProduct_var spiRefProduct=ispiInstanceProduct->GetReferenceProduct();

	CATILinkableObject_var spiRefLink=spiRefProduct;

	if( !!spiRefLink ) 
	{
		opDocument = spiRefLink->GetDocument();
		rc = S_OK;
	}

	return rc;
}
void  GetPrtContFromPrd(CATIProduct_var ispiPrd, CATIPrtContainer_var & ospiCont,CATISpecObject_var &ospPrtPart)
{
	//获取Container
	CATDocument * pPrdDocument = NULL;
	GetReferencePrdDocument(ispiPrd, pPrdDocument);
	if (pPrdDocument==NULL)
		return;

	CATIPrtContainer_var  spiPrtCont = NULL_var;
	GetContOfPartDocument(pPrdDocument, spiPrtCont);
	if (spiPrtCont==NULL_var)
		return;

	CATISpecObject_var spPrtPart=spiPrtCont->GetPart();
	if (spPrtPart==NULL_var)
		return;

	ospiCont = spiPrtCont;
	ospPrtPart=spPrtPart;

}

//描述：获取container
//输入：CATDocument* 文档对象
//输出：CATIPrtContainer_var prt容器
//返回：HRESULT
HRESULT GetContOfPartDocument( CATDocument *ipDocument,CATIPrtContainer_var &opiCont )
{
	HRESULT rc=E_FAIL;

	if( !ipDocument ) return rc;

	CATInit_var spInit = ipDocument;
	CATIPrtContainer *piPrtContainer=NULL;
	if( !!spInit )
		piPrtContainer = (CATIPrtContainer *)spInit->GetRootContainer("CATIPrtContainer");
	opiCont = piPrtContainer;
	return rc;
}
//描述：获取GeoFactory
//输入：CATDocument* 文档对象
//输出：CATGeoFactory* geo工厂
//返回：CATGeoFactory*
CATGeoFactory* GetCATGeoFactory( CATDocument * ipDoc )
{
	HRESULT rc;
	CATGeoFactory * pGeoFactory = NULL;	
	if ( NULL != ipDoc )
	{
		CATIContainerOfDocument * pIContainerOfDocument = NULL ;
		rc = ipDoc->QueryInterface(IID_CATIContainerOfDocument, (void**)& pIContainerOfDocument );
		if ( SUCCEEDED(rc) )
		{
			CATIContainer * pIContainerOnGeomContainer = NULL ;
			rc = pIContainerOfDocument->GetResultContainer(pIContainerOnGeomContainer);
			if ( SUCCEEDED(rc) )
			{
				rc = pIContainerOnGeomContainer->QueryInterface( IID_CATGeoFactory, (void**)&pGeoFactory );
				if(pGeoFactory==NULL || FAILED(rc))
				{
					cout<<"QueryInterface pGeoFactory FAILED"<<endl;
					return NULL;
				}
			}
		}
	}
	else
	{
		cout<<"pDoc is NULL"<<endl;
		return NULL;
	}

	return pGeoFactory;
}
//描述：判断是Product还是Part
//输入：CATIProduct_var product对象
//输出：无
//返回：CATBoolean
CATBoolean IsProduct( CATIProduct_var ispiPrd )
{
	HRESULT rc = S_OK;

	CATBoolean isProduct=FALSE;

	CATIProduct *piPrd=NULL;
	rc = ispiPrd->QueryInterface(IID_CATIProduct,(void **)&piPrd);

	CATIProduct_var spRefPrd=ispiPrd->GetReferenceProduct();
	piPrd->Release();  piPrd = NULL;

	if (spRefPrd==NULL_var)
	{
		isProduct = TRUE;
		cout<<"==>Get ReferenceProduct failed"<<endl;
		return isProduct;
	}

	CATILinkableObject *piLinkObj=NULL;
	rc=spRefPrd->QueryInterface(IID_CATILinkableObject,(void **)&piLinkObj);
	if( FAILED(rc) || !piLinkObj ) 
	{
		cout << "==> Get CATILinkableObject error !" << endl;
		return isProduct;
	}

	CATDocument *pDoc=piLinkObj->GetDocument();
	piLinkObj->Release();  piLinkObj = NULL;
	if( !pDoc ) 
	{
		cout << "==> Get CATDocument error !" << endl;
		return isProduct;
	}

	CATIDocId *pDocID;
	CATUnicodeString typeDoc="";
	rc = pDoc->GetDocId(&pDocID);
	if( !(FAILED(rc)) )
		rc = pDocID->GetType(typeDoc);
	//cout << " ==> The type of document is: " << typeDoc << endl;

	if( typeDoc == "CATProduct" )
		isProduct = TRUE;

	return isProduct;
}
//描述：判断是否是Part
//输入：CATIProduct_var product对象
//输出：无
//返回：CATBoolean
CATBoolean IsCATPart( CATPathElementAgent *pSelectPartAgent )
{
	HRESULT rc = S_OK;

	CATIProduct_var spiPrd = NULL_var;
	SelectTransfer(pSelectPartAgent,spiPrd);

	CATBoolean isCATPart=TRUE;

	CATIProduct *piPrd=NULL;
	rc = spiPrd->QueryInterface(IID_CATIProduct,(void **)&piPrd);

	CATIProduct_var spRefPrd=spiPrd->GetReferenceProduct();
	piPrd->Release();  piPrd = NULL;

	if (spRefPrd==NULL_var)
	{
		isCATPart = FALSE;
		cout<<"==>Get ReferenceProduct failed"<<endl;
		return isCATPart;
	}

	CATILinkableObject *piLinkObj=NULL;
	rc=spRefPrd->QueryInterface(IID_CATILinkableObject,(void **)&piLinkObj);
	if( FAILED(rc) || !piLinkObj ) 
	{
		cout << "==> Get CATILinkableObject error !" << endl;
		return isCATPart;
	}

	CATDocument *pDoc=piLinkObj->GetDocument();
	piLinkObj->Release();  piLinkObj = NULL;
	if( !pDoc ) 
	{
		cout << "==> Get CATDocument error !" << endl;
		return isCATPart;
	}

	CATIDocId *pDocID;
	CATUnicodeString typeDoc="";
	rc = pDoc->GetDocId(&pDocID);
	if( !(FAILED(rc)) )
		rc = pDocID->GetType(typeDoc);
	//cout << " ==> The type of document is: " << typeDoc << endl;

	if( typeDoc == "CATProduct" )
		isCATPart = FALSE;

	return isCATPart;
}
//描述：选择转换
//输入：CATPathElementAgent* PathElementAgent对象
//输出：CATIProduct_var 转换结果
//返回：void
void SelectTransfer( CATPathElementAgent *ipPathElemAgt, CATIProduct_var &ospiProduct )
{
	CATPathElement *pPath = ipPathElemAgt->GetValue();
	CATBaseUnknown *pSelection = ipPathElemAgt->GetElementValue();
	CATBaseUnknown *pProduct = pPath->FindElement(IID_CATIProduct);
	if (pProduct == NULL)
	{
		pProduct = pPath->FindElement(IID_CATIPrtPart);
		if (pProduct == NULL)
		{
			return;
		}
		CATIPrtPart_var spPart = pProduct;
		if (spPart == NULL_var)
		{
			return;
		}
		CATISpecObject_var spPartObject = spPart->GetProduct();
		if (spPartObject == NULL_var)
		{
			return;
		}
		ospiProduct = spPartObject;
	}
	else
	{
		ospiProduct = pProduct;
	}
}
//获得离曲线指定端点指定距离的一个点
//输入：CATIProduct_var 对应part,CATISpecObject_var曲线对象,CATMathPoint 指定端点,double 距离
//输出：CATBody_var 结果Body
//返回：HRESULT
HRESULT CreatePointBodyOnCurve( CATIProduct_var ispiProductCurve,CATISpecObject_var ispiSpecCurve,CATMathPoint imathPointStart,double idblDistance,CATBody_var& ispPointBody)
{
	HRESULT rc = S_OK;
	//准备工作
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATIPrtContainer_var spiContCurve=NULL_var;
	CATGeoFactory*piGeoFacCurve=GetProductGeoFactoryAndPrtCont(ispiProductCurve,spiContCurve);
	if (piGeoFacCurve==NULL)
	{
		cout<<"GetProductGeoFactoryAndPrtCont"<<endl;
		return E_FAIL;
	}
	//把输入的curve转成body
	CATBody_var spBodyCurve=GetBodyFromFeature(ispiSpecCurve);
	if (spBodyCurve==NULL_var)
	{
		cout<<"GetBodyFromFeature Failed"<<endl;
		return E_FAIL;
	}
	//把数学点转成topo点
	CATBody * pBodyStartPt =::CATCreateTopPointXYZ( piGeoFacCurve,&Topdata,imathPointStart.GetX(),imathPointStart.GetY(),imathPointStart.GetZ());
	if (pBodyStartPt==NULL)
	{
		cout<<"CATCreateTopPointXYZ Failed"<<endl;
		return E_FAIL;
	}

	CATBody * pBodyPtOnCurve = ::CATCreateTopPointOnWire(piGeoFacCurve,&Topdata,spBodyCurve,idblDistance,pBodyStartPt,CatTopPointLValue);
	if (pBodyPtOnCurve==NULL)
	{
		cout<<"CATCreateTopPointOnWire Failed"<<endl;
		return E_FAIL;
	}
	ispPointBody = pBodyPtOnCurve;
	return rc;
}



//描述：获取part的最高级唯一body
//输入：CATIPrtContainer_var part容器
//输出：CATBody_var part的body
//返回：HRESULT
HRESULT SelectBodyFromPartFunc( CATIPrtContainer_var ispiPartCont,CATBody_var& ospiBody )
{
	//获取最高级body
	if(NULL_var == ispiPartCont)
	{
		return E_FAIL;
	}
	CATIPrtPart_var spiPart = NULL_var;
	spiPart = ispiPartCont->GetPart();
	if(NULL_var == ispiPartCont)
	{
		return E_FAIL;
	}
	CATLISTP(CATBody) ListOfBodyLst;
	CATIPartRequest *piPartRequest = NULL;
	CATListValCATBaseUnknown_var lstBodies = NULL;
	if (FAILED(spiPart->QueryInterface(IID_CATIPartRequest,(void**) &piPartRequest)) || piPartRequest == NULL)
	{
		return E_FAIL;
	}
	piPartRequest->GetSolidBodies("",lstBodies);
	piPartRequest->Release();
	piPartRequest = NULL;

	if(lstBodies.Size()>0)
	{
		for (int i=1;i<=lstBodies.Size();i++)
		{
			CATISpecObject_var spCurrObj = lstBodies[i];
			if (NULL_var == spCurrObj) continue;

			//先判断当前的Body是否隐藏
			CATBoolean bShow = CheckShowState(spCurrObj);
			if (bShow == FALSE)
			{
				continue;
			}
			else	//当Body没有隐藏，再判断Body内的的solid是否隐藏
			{
				CATIDescendants *piDescendants = NULL;
				CATListValCATISpecObject_var  ListOfChildrenObjects;
				if( FAILED(spCurrObj->QueryInterface(IID_CATIDescendants,(void**) &piDescendants)) || piDescendants == NULL )
				{
					continue;
				}
				piDescendants->GetDirectChildren("CATIMfTriDimResult",ListOfChildrenObjects);
				piDescendants->Release();
				piDescendants = NULL;
				//判断该body下是否是空的，若空，直接返回
				if (ListOfChildrenObjects.Size() == 0)
				{
					continue;
				}
				//再检查子集是否隐藏
				bShow = CheckShowState(ListOfChildrenObjects[1]);
				if (bShow == FALSE)
				{
					continue;
				}
			}

			CATBody_var spBody = NULL_var;
			spBody = GetBodyFromFeature(spCurrObj);
			if(NULL_var == spBody)
			{
				continue;
			}
			ListOfBodyLst.Append(spBody);
		}
		if(ListOfBodyLst.Size() > 0)
		{
			ospiBody = ListOfBodyLst[1];
			if(ListOfBodyLst.Size() != 1)
			{
				MessageOutputWarning("Result May Error!","Warning");
			}
			return S_OK;
		}
	}
	return E_FAIL;
}

//描述：获取Part下特定参数的double值
//输入：CATISpecObject_var 要检测的Part,CATUnicodeString 参数集名,CATUnicodeString 参数名
//输出：double 参数值
//返回：HRESULT
HRESULT GetParameterDoubleValueFunc( CATISpecObject_var ispiMasterPart,CATUnicodeString istrCkeParameterSet,CATUnicodeString istrParameterName,double& odblValue )
{
	CATCkeListOfParm ListParameters;
	CATLISTV(CATISpecObject_var) ListParameterSet;
	CATIParmPublisher_var spiParmPub = ispiMasterPart;
	if(NULL_var != spiParmPub)
	{
		spiParmPub->GetAllChildren("CATICkeParameterSet",ListParameterSet);
	}

	for(int i = 1;i <= ListParameterSet.Size();i++)
	{
		CATBaseUnknown_var spiBaseUnknown = NULL_var;
		spiBaseUnknown = ListParameterSet[i];
		if(NULL_var == spiBaseUnknown)
		{
			continue;;
		}
		CATIAlias *piAlias = NULL;
		if(SUCCEEDED(spiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
		{
			CATUnicodeString Name = piAlias->GetAlias();
			piAlias->Release();
			piAlias = NULL;
			if(Name.SearchSubString(istrCkeParameterSet) >= 0 || istrCkeParameterSet == "")
			{
				CATICkeParameterSet_var spiParaSet = NULL_var;
				spiParaSet = ListParameterSet[i];
				if(NULL_var == spiParaSet)
				{
					break;
				}
				ListParameters = spiParaSet->Parameters();

				if (ListParameters != NULL &&ListParameters->Size()>0)
				{
					CATICkeParm_var spResultParm;
					for (int i=1; i <= ListParameters->Size(); i++)
					{
						CATICkeParm_var spCkeParm = (*ListParameters)[i];
						if (NULL_var !=spCkeParm)
						{
							CATUnicodeString strParmName=spCkeParm->Name();
							if (strParmName.SearchSubString(istrParameterName)>=0)
							{
								odblValue = (spCkeParm->Value())->AsReal();
								return S_OK;
							}
						}
					}
				}

			}
		}
	}

	return E_FAIL;
}
//描述：获取Part下特定参数的string值
//输入：CATISpecObject_var 要检测的Part,CATUnicodeString 参数集名,CATUnicodeString 参数名
//输出：CATUnicodeString 参数值
//返回：HRESULT
HRESULT GetParameterStringValueFunc( CATISpecObject_var ispiMasterPart,CATUnicodeString istrCkeParameterSet,CATUnicodeString istrParameterName,CATUnicodeString& ostrValue )
{
	ostrValue = "";
	CATCkeListOfParm ListParameters;
	CATLISTV(CATISpecObject_var) ListParameterSet;
	CATIParmPublisher_var spiParmPub = ispiMasterPart;
	if(NULL_var != spiParmPub)
	{
		spiParmPub->GetAllChildren("CATICkeParameterSet",ListParameterSet);
	}

	for(int i = 1;i <= ListParameterSet.Size();i++)
	{
		CATBaseUnknown_var spiBaseUnknown = NULL_var;
		spiBaseUnknown = ListParameterSet[i];
		if(NULL_var == spiBaseUnknown)
		{
			continue;;
		}
		CATIAlias *piAlias = NULL;
		if(SUCCEEDED(spiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
		{
			CATUnicodeString Name = piAlias->GetAlias();
			piAlias->Release();
			piAlias = NULL;
			if(Name.SearchSubString(istrCkeParameterSet) >= 0 || istrCkeParameterSet == "")
			{
				CATICkeParameterSet_var spiParaSet = NULL_var;
				spiParaSet = ListParameterSet[i];
				if(NULL_var == spiParaSet)
				{
					break;
				}
				ListParameters = spiParaSet->Parameters();

				if (ListParameters != NULL &&ListParameters->Size()>0)
				{
					CATICkeParm_var spResultParm;
					for (int i=1; i <= ListParameters->Size(); i++)
					{
						CATICkeParm_var spCkeParm = (*ListParameters)[i];
						if (NULL_var !=spCkeParm)
						{
							CATUnicodeString strParmName=spCkeParm->Name();
							if (strParmName.SearchSubString(istrParameterName)>=0)
							{
								ostrValue = (spCkeParm->Value())->AsString();
								return S_OK;
							}
						}
					}
				}

			}
		}
	}

	return E_FAIL;
}
//描述：设置Part下特定参数的double值
//输入：CATISpecObject_var 要检测的Part,CATUnicodeString 参数集名,CATUnicodeString 参数名
//输出：double 参数值
//返回：HRESULT
HRESULT SetParameterDoubleValueFunc(CATISpecObject_var ispiMasterPart,CATUnicodeString istrCkeParameterSet,CATUnicodeString istrParameterName,double idblValue)
{
	CATCkeListOfParm ListParameters;
	CATLISTV(CATISpecObject_var) ListParameterSet;
	CATIParmPublisher_var spiParmPub = ispiMasterPart;
	if(NULL_var != spiParmPub)
	{
		spiParmPub->GetAllChildren("CATICkeParameterSet",ListParameterSet);
	}
	for(int i = 1;i <= ListParameterSet.Size();i++)
	{
		CATBaseUnknown_var spiBaseUnknown = NULL_var;
		spiBaseUnknown = ListParameterSet[i];
		if(NULL_var == spiBaseUnknown)
		{
			continue;;
		}
		CATIAlias *piAlias = NULL;
		if(SUCCEEDED(spiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
		{
			CATUnicodeString Name = piAlias->GetAlias();
			piAlias->Release();
			piAlias = NULL;
			if(Name.SearchSubString(istrCkeParameterSet) >= 0 || istrCkeParameterSet == "")
			{
				CATICkeParameterSet_var spiParaSet = NULL_var;
				spiParaSet = ListParameterSet[i];
				if(NULL_var == spiParaSet)
				{
					break;
				}
				ListParameters = spiParaSet->Parameters();

				if (ListParameters != NULL &&ListParameters->Size()>0)
				{
					CATICkeParm_var spResultParm;
					for (int i=1; i <= ListParameters->Size(); i++)
					{
						CATICkeParm_var spCkeParm = (*ListParameters)[i];
						if (NULL_var !=spCkeParm)
						{
							CATUnicodeString strParmName=spCkeParm->Name();
							if (strParmName.SearchSubString(istrParameterName)>=0)
							{
								spCkeParm->Valuate(idblValue);
								return S_OK;
							}
						}
					}
				}
				CATICkeParmFactory_var spiCkeFactory = NULL_var;
				spiCkeFactory = spiParaSet;
				if(NULL_var == spiCkeFactory)
				{
					return E_FAIL;
				}
				spiCkeFactory->CreateReal(istrParameterName,idblValue);
			}
		}
	}

	return E_FAIL;
}

//描述：设置Part下特定参数的string值
//输入：CATISpecObject_var 要检测的Part,CATUnicodeString 参数集名,CATUnicodeString 参数名
//输出：CATUnicodeString 参数值
//返回：HRESULT
HRESULT SetParameterDoubleValueFunc(CATISpecObject_var ispiMasterPart,CATUnicodeString istrCkeParameterSet,CATUnicodeString istrParameterName,CATUnicodeString istrValue)
{
	CATCkeListOfParm ListParameters;
	CATLISTV(CATISpecObject_var) ListParameterSet;
	CATIParmPublisher_var spiParmPub = ispiMasterPart;
	if(NULL_var != spiParmPub)
	{
		spiParmPub->GetAllChildren("CATICkeParameterSet",ListParameterSet);
	}
	for(int i = 1;i <= ListParameterSet.Size();i++)
	{
		CATBaseUnknown_var spiBaseUnknown = NULL_var;
		spiBaseUnknown = ListParameterSet[i];
		if(NULL_var == spiBaseUnknown)
		{
			continue;;
		}
		CATIAlias *piAlias = NULL;
		if(SUCCEEDED(spiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
		{
			CATUnicodeString Name = piAlias->GetAlias();
			piAlias->Release();
			piAlias = NULL;
			if(Name.SearchSubString(istrCkeParameterSet) >= 0 || istrCkeParameterSet == "")
			{
				CATICkeParameterSet_var spiParaSet = NULL_var;
				spiParaSet = ListParameterSet[i];
				if(NULL_var == spiParaSet)
				{
					break;
				}
				ListParameters = spiParaSet->Parameters();

				if (ListParameters != NULL &&ListParameters->Size()>0)
				{
					CATICkeParm_var spResultParm;
					for (int i=1; i <= ListParameters->Size(); i++)
					{
						CATICkeParm_var spCkeParm = (*ListParameters)[i];
						if (NULL_var !=spCkeParm)
						{
							CATUnicodeString strParmName=spCkeParm->Name();
							if (strParmName.SearchSubString(istrParameterName)>=0)
							{
								spCkeParm->Valuate(istrValue);
								return S_OK;
							}
						}
					}
				}
				CATICkeParmFactory_var spiCkeFactory = NULL_var;
				spiCkeFactory = spiParaSet;
				if(NULL_var == spiCkeFactory)
				{
					return E_FAIL;
				}
				spiCkeFactory->CreateString(istrParameterName,istrValue);
			}
		}
	}

	return E_FAIL;
}

//描述：获取轴系
//输入：CATISpecObject_var Part的Product,CATUnicodeString轴系命令,CATUnicodeString几何图形集名
//输出：CATISpecObject_var 轴系元素
//返回：CATISpecObject_var
CATISpecObject_var GetAxisFromPartFunc( CATISpecObject_var ispPro,CATUnicodeString istrAxisName,CATUnicodeString istrGeometricSet )
{
	CATIProduct_var spiPro = NULL_var;
	spiPro = ispPro;
	if(NULL_var == spiPro)
	{
		return NULL_var;
	}
	CATIPrtContainer_var spiPrtContainer = NULL_var;
	//GetPrtContFromPrd(spiPro,spiPrtContainer);
	spiPrtContainer = GetPrtContainer(spiPro);
	if(NULL_var == spiPrtContainer)
	{
		return NULL_var;
	}

	CATIPrtPart_var spiPrt = NULL_var;
	spiPrt = spiPrtContainer->GetPart();
	if(NULL_var == spiPrt)
	{
		return NULL_var;
	}

	CATISpecObject_var spiGeometricSetFromPart = NULL_var;
	if(FAILED(GetGeometricalSet(spiPrt,istrGeometricSet,spiGeometricSetFromPart)) || NULL_var == spiGeometricSetFromPart)
	{
		return NULL_var;
	}
	CATISpecObject_var spiAxisBeFound = NULL_var;
	if(SUCCEEDED(GetFeatureOfGeometricalSet(spiGeometricSetFromPart,istrAxisName,spiAxisBeFound)) && NULL_var != spiAxisBeFound)
	{
		return spiAxisBeFound;
	}

	return NULL_var;
}
//描述：根据曲线Body求出计算中点-----算法更新
//输入：CATBaseUnknown_var曲线,CATIProduct_var曲线所在Part
//输出：CATMathPoint*3 曲线上三点
//返回：HRESULT
HRESULT GetThreePointsOnCurve( CATBody_var spResultBody,CATIProduct_var ispiBaseUnknownPro,CATMathPoint &oPoint1,CATMathPoint &oPoint2,CATMathPoint &oPoint3 )
{
	if(NULL_var == spResultBody|| NULL_var == ispiBaseUnknownPro)
	{
		return E_FAIL;
	}

	CATGeoFactory* ipGeoFactory = NULL;
	CATIPrtContainer_var spiPrtCont = NULL_var;
	ipGeoFactory = GetProductGeoFactoryAndPrtCont(ispiBaseUnknownPro,spiPrtCont);
	if(NULL == ipGeoFactory)
	{
		return E_FAIL;
	}
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData * itopdata =new CATTopData(pConfig, NULL);//topdata

	CATLISTV(CATMathPoint)  pPointList;
	CATCurve_var spCurveTemp1 = NULL_var;
	double d_CurveLength = 0;

	CATLISTP(CATCell) pLISTCurveCell; 
	CATLISTP(CATCell) LISTCell; 
	spResultBody->GetAllCells( LISTCell, 1 ); 
	for( int index1 = 1; index1 <= LISTCell.Size(); index1++ )
	{ 
		CATCell *pCurveCell1 = LISTCell[index1]; 
		if(pCurveCell1==NULL)
			continue;

		CATCell_var spCurveCell1 = pCurveCell1; 
		if(spCurveCell1==NULL_var)
			continue; 

		CATEdge_var spEdgeTemp1 = spCurveCell1; 
		if(spEdgeTemp1==NULL_var)
			continue; 

		CATVertex*  oStartVertex=NULL;
		CATVertex*  oEndVertex=NULL;
		spEdgeTemp1->GetVertices(&oStartVertex, &oEndVertex);
		if (oEndVertex==NULL||oStartVertex==NULL)
		{
			cout<<"GetVertices Failed"<<endl;
			continue; 
		}

		CATPoint * pStartPoint=oStartVertex->GetPoint( );
		CATPoint * pEndPoint=oEndVertex->GetPoint( );
		if (pStartPoint==NULL||pEndPoint==NULL)
		{
			cout<<"GetPoint Failed"<<endl;
			continue; 
		}

		CATMathPoint sStartPoint ;
		pStartPoint->GetMathPoint(sStartPoint);
		CATMathPoint sEndPoint ;
		pEndPoint->GetMathPoint(sEndPoint);

		CATDynMassProperties3D*  iMass = CATDynCreateMassProperties3D(itopdata,(CATEdge *)spEdgeTemp1);
		if (iMass==NULL)
			continue;

		CATPositiveLength iLength = iMass->GetLength();

		d_CurveLength+=iLength;

		pPointList.Append(sStartPoint);
		pPointList.Append(sEndPoint);

		pLISTCurveCell.Append(spCurveCell1);
		pLISTCurveCell.Append(spCurveCell1);
	}
	//----增加两个列表
	CATLISTV(CATMathPoint) lstAllPoints = NULL;
	CATLISTP(CATCell) lstAllCells = NULL;
	lstAllPoints = pPointList;
	lstAllCells = pLISTCurveCell;

	CATLISTV(CATMathPoint) PointList;
	CATLISTP(CATCell) LISTCurveCell; 
	for (int j=pPointList.Size();j>=1;j--)
	{
		//cout<<"X:"<<pPointList[j].GetX()<<endl;
		//cout<<"Y:"<<pPointList[j].GetY()<<endl;
		//cout<<"Z:"<<pPointList[j].GetZ()<<endl;

		bool b_found = false;
		for (int k=pPointList.Size();k>=1;k--)
		{
			if (j==k)
				continue;

			if (pPointList[j].DistanceTo(pPointList[k])<=0.0001)
			{
				b_found = true;
				break;
			}

		}

		if (b_found==false)
		{
			PointList.Append(pPointList[j]);
			LISTCurveCell.Append(pLISTCurveCell[j]);
		}
	}

	pPointList.RemoveAll();
	pPointList=PointList;

	pLISTCurveCell.RemoveAll();
	pLISTCurveCell=LISTCurveCell;

	if (pPointList.Size()==2)
	{
		cout<<"一整段线"<<endl;

		oPoint1 = pPointList[1];
		oPoint3 = pPointList[2];
		//分别用两个端点求出2个方向上的中点，比较距离求出最终的中点
		CATLISTV(CATMathPoint) lstMidPt = NULL;
		for (int i=1; i <= pPointList.Size(); i++)
		{
			CATBody * StartBody =::CATCreateTopPointXYZ( ipGeoFactory,itopdata,pPointList[i].GetX(),pPointList[i].GetY(),pPointList[i].GetZ());
			if (StartBody==NULL)
			{
				cout<<"CATCreateTopPointXYZ Failed"<<endl;
				return E_FAIL;
			}

			CATBody * spBodyOfMidPoint1 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,0.5*d_CurveLength,StartBody,CatTopPointLValue);
			if (spBodyOfMidPoint1==NULL)
			{
				cout<<"CATCreateTopPointOnWire Failed"<<endl;
				return E_FAIL;
			}

			CATLISTV(CATMathPoint)  MathPtList;
			GetMathPtsFromBody(spBodyOfMidPoint1,MathPtList);
			if (MathPtList.Size()==0)
			{
				cout<<"CATCreateTopPointOnWire Failed"<<endl;
				return E_FAIL;
			}
			lstMidPt.Append(MathPtList[1]);
		}
		//反向
		for (int i=1; i <= pPointList.Size(); i++)
		{
			CATBody * StartBody =::CATCreateTopPointXYZ( ipGeoFactory,itopdata,pPointList[i].GetX(),pPointList[i].GetY(),pPointList[i].GetZ());
			if (StartBody==NULL)
			{
				cout<<"CATCreateTopPointXYZ Failed"<<endl;
				return E_FAIL;
			}

			CATBody * spBodyOfMidPoint1 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,-0.5*d_CurveLength,StartBody,CatTopPointLValue);
			if (spBodyOfMidPoint1==NULL)
			{
				cout<<"CATCreateTopPointOnWire Failed"<<endl;
				return E_FAIL;
			}

			CATLISTV(CATMathPoint)  MathPtList;
			GetMathPtsFromBody(spBodyOfMidPoint1,MathPtList);
			if (MathPtList.Size()==0)
			{
				cout<<"CATCreateTopPointOnWire Failed"<<endl;
				return E_FAIL;
			}
			lstMidPt.Append(MathPtList[1]);
		}
		cout<<"-----------Middle Point List------------"<<endl;
		for (int i=1; i <= lstMidPt.Size(); i++)
		{
			lstMidPt[i].Dump();
		}
		//判断list中相同的点即为中点
		oPoint2 = lstMidPt[1]; //给个初值
		CATBoolean bFind = FALSE;
		for (int i = 1; i <= lstMidPt.Size(); i++)
		{
			for (int j = lstMidPt.Size(); j>i; j--)
			{
				if (lstMidPt[i].DistanceTo(lstMidPt[j]) <= 0.01)
				{
					oPoint2.SetCoord(lstMidPt[i].GetX(),lstMidPt[i].GetY(),lstMidPt[i].GetZ()); //更新，原来直接用的等于，不对的
					bFind = TRUE;
					break;
				}
			}
			if (bFind == TRUE)
			{
				break;
			}
		}

	}
	else if(pPointList.Size()==0)
	{
		cout<<"闭合的线"<<endl;

		CATLISTV(CATMathPoint)  MathPtList;
		//点1
		CATBody * StartBody =::CATCreateTopPointXYZ( ipGeoFactory,itopdata,lstAllPoints[1].GetX(),lstAllPoints[1].GetY(),lstAllPoints[1].GetZ());
		if (StartBody==NULL)
		{
			cout<<"CATCreateTopPointXYZ Failed"<<endl;
			return E_FAIL;
		}
		oPoint1=lstAllPoints[1];
		//点2
		CATBody * spBodyOfMidPoint1 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,0.5*d_CurveLength,StartBody,CatTopPointLValue);
		if (spBodyOfMidPoint1==NULL)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		MathPtList.RemoveAll();
		GetMathPtsFromBody(spBodyOfMidPoint1,MathPtList);
		if (MathPtList.Size()==0)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		oPoint2 = MathPtList[1];
		//点3
		CATBody * spBodyOfMidPoint2 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,0.8*d_CurveLength,StartBody,CatTopPointLValue);
		if (spBodyOfMidPoint2==NULL)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		MathPtList.RemoveAll();
		GetMathPtsFromBody(spBodyOfMidPoint2,MathPtList);
		if (MathPtList.Size()==0)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		oPoint3 = MathPtList[1];
	}

	return S_OK;
}

//描述：去除重复的Part
//输入：CATLISTV(CATISpecObject_var) 要去重的列表
//输出：CATLISTV(CATISpecObject_var)
//返回：HRESULT
HRESULT DeleteRepeatPart(CATLISTV(CATISpecObject_var)& ioListOfPartToDeleteRepeat)
{
	CATLISTP(CATIProduct) ListOfReferenceProLst;
	CATLISTP(CATIProduct) ListOfPartToDeleteComplete;
	for(int i = 1;i <= ioListOfPartToDeleteRepeat.Size();i++)
	{
		CATIProduct_var spiPro = ioListOfPartToDeleteRepeat[i];
		CATIProduct_var spiRefPro = spiPro->GetReferenceProduct();
		int intFlag = 0;
		for(int j = 1;j <= ListOfReferenceProLst.Size();j++)
		{
			CATIProduct_var spiProFromList = NULL_var;
			spiProFromList = ListOfReferenceProLst[j];
			if(NULL_var == spiProFromList)
			{
				continue;
			}
			if(spiRefPro == spiProFromList)
			{
				intFlag = 1;
				break;
			}
		}
		if(0 == intFlag)
		{
			ListOfReferenceProLst.Append(spiRefPro);
			ListOfPartToDeleteComplete.Append(spiPro);
		}
	}
	ioListOfPartToDeleteRepeat.RemoveAll();
	for(int i = 1;i <= ListOfPartToDeleteComplete.Size();i++)
	{
		ioListOfPartToDeleteRepeat.Append(ListOfPartToDeleteComplete[i]);
	}
	return S_OK;
}

//描述：获取Part下是否存在参数集，参数集下的参数值是否正确
//输入：CATISpecObject_var 要检测的Part,CATUnicodeString 参数集名,CATUnicodeString 参数名,CATUnicodeString 参数值
//输出：无
//返回：HRESULT
HRESULT IsParameterExitFunc( CATISpecObject_var ispiMasterPart,CATUnicodeString istrCkeParameterSet,CATUnicodeString istrParameterName,CATUnicodeString istrParameterValue )
{
	CATCkeListOfParm ListParameters;
	CATLISTV(CATISpecObject_var) ListParameterSet;
	CATIParmPublisher_var spiParmPub = ispiMasterPart;
	if(NULL_var != spiParmPub)
	{
		spiParmPub->GetAllChildren("CATICkeParameterSet",ListParameterSet);
	}

	for(int i = 1;i <= ListParameterSet.Size();i++)
	{
		CATBaseUnknown_var spiBaseUnknown = NULL_var;
		spiBaseUnknown = ListParameterSet[i];
		if(NULL_var == spiBaseUnknown)
		{
			continue;;
		}
		CATIAlias *piAlias = NULL;
		if(SUCCEEDED(spiBaseUnknown->QueryInterface (IID_CATIAlias, (void**) &piAlias)) && piAlias!=NULL)
		{
			CATUnicodeString Name = piAlias->GetAlias();
			piAlias->Release();
			piAlias = NULL;
			if(Name.SearchSubString(istrCkeParameterSet) >= 0)
			{
				CATICkeParameterSet_var spiParaSet = NULL_var;
				spiParaSet = ListParameterSet[i];
				if(NULL_var == spiParaSet)
				{
					break;
				}
				ListParameters = spiParaSet->Parameters();

				if (ListParameters != NULL &&ListParameters->Size()>0)
				{
					CATICkeParm_var spResultParm;
					for (int i=1; i <= ListParameters->Size(); i++)
					{
						CATICkeParm_var spCkeParm = (*ListParameters)[i];
						if (NULL_var !=spCkeParm)
						{
							CATUnicodeString strParmName=spCkeParm->Name();
							if (strParmName.SearchSubString(istrParameterName)>=0)
							{
								CATUnicodeString strParameterValue = "";
								strParameterValue = (spCkeParm->Value())->AsString();
								if(strParameterValue.SearchSubString(istrParameterValue)>=0 || istrParameterValue == "")
								{
									return S_OK;
								}
								break;
							}
						}
					}
				}

			}
		}
	}

	return E_FAIL;
}
//描述：获得相交对象
//输入：CATGeoFactory*geo工厂,CATTopData*对象,CATBody* body1,CATBody* body2
//输出：CATBody* 相交结果
//返回：CATBody*
CATBody* CreateTopIntersect( CATGeoFactory* ipGeoFactory, CATTopData* itopdata,CATBody*iBody1,CATBody*iBody2 )
{
	CATBody*pBody=NULL;
	CATHybIntersect * ipHybIntersect=NULL;
	CATTry 
	{
		ipHybIntersect=CATCreateTopIntersect( ipGeoFactory, itopdata, iBody1, iBody2);
	}
	CATCatch(CATError , pError)
	{
		return pBody;
	}
	CATEndTry

		if (ipHybIntersect==NULL)
			return pBody;

	ipHybIntersect->Run(); 
	pBody=ipHybIntersect->GetResult();

	delete ipHybIntersect; 
	ipHybIntersect = NULL;
	return pBody;
}
HRESULT CreateTopAssembleLine(CATGeoFactory*ipGeoFactory,CATMathPoint iMathPoint,CATMathVector iMathVector,double idistance,CATBody_var &ospLineBody)
{
	HRESULT rc=E_FAIL;

	double x=iMathVector.GetX();
	double y=iMathVector.GetY();
	double z=iMathVector.GetZ();
	x=1000*x;
	y=1000*y;
	z=1000*z;

	CATMathPoint origin(0,0,0);
	CATMathPoint tempPT(x,y,z);
	CATMathVector tempVector=origin-tempPT;
	tempVector.Normalize();

	//cout<<tempVector.GetAngleTo(iMathVector)<<endl;

	iMathVector=tempVector;

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATBody_var spBodyPoint=NULL_var;
	CreateTopPointByXYZ(ipGeoFactory,Topdata,iMathPoint,spBodyPoint);
	if (spBodyPoint==NULL_var)
		return E_FAIL;

	CATBody*pLineBody1= CATCreateTopLineFromDirection( ipGeoFactory, &Topdata,spBodyPoint,iMathVector, idistance); 
	if (pLineBody1==NULL)
		return E_FAIL;

	CATBody*pLineBody2= CATCreateTopLineFromDirection( ipGeoFactory, &Topdata,spBodyPoint,-1*iMathVector, idistance); 
	if (pLineBody2==NULL)
		return E_FAIL;

	CATLISTP(CATBody) ListBody;
	ListBody.Append(pLineBody1);
	ListBody.Append(pLineBody2);

	ospLineBody=NULL_var;
	ListPOfCATBody * HListOfLine=&ListBody;
	CATHybAssemble * HHybAssemble=CATCreateTopAssemble(ipGeoFactory, &Topdata, HListOfLine);
	if (HHybAssemble==NULL)
		return E_FAIL;

	HHybAssemble->Run();
	ospLineBody= HHybAssemble->GetResult();

	if (HHybAssemble!=NULL)
	{
		delete HHybAssemble;
		HHybAssemble = NULL;
	}

	if (pLineBody1!=NULL)
	{
		ipGeoFactory->Remove(pLineBody1);
		pLineBody1 = NULL;
	}

	if (pLineBody2!=NULL)
	{
		ipGeoFactory->Remove(pLineBody2);
		pLineBody2 = NULL;
	}

	return S_OK;
}
//描述：从CATBody获取数学点集合
//输入：CATBody_var目标body
//输出：CATLISTV(CATMathPoint) 数学点集合
//返回：HRESULT
HRESULT GetMathPtsFromBody(CATBody_var ispBody,CATLISTV(CATMathPoint) &oMathPtList )
{
	if (ispBody==NULL_var)
		return E_FAIL;

	CATLISTP(CATCell) LISTCell; 
	ispBody->GetAllCells( LISTCell, 0 ); 
	if (LISTCell.Size()==0)
		return E_FAIL;

	for( int index = 1; index <= LISTCell.Size(); index++ )
	{ 
		CATMathPoint oMathPoint;
		CATCell * pCell = LISTCell[index]; 
		if(pCell == NULL) 
		{
			cout<<"CATCell is NULL."<<endl;
			continue;
		}

		CATCell_var spCell = pCell;

		CATVertex_var spVertex = spCell;
		if(spVertex == NULL_var) 
		{
			cout<<"CATVertex is NULL_var."<<endl;
			continue;
		}

		CATPoint *pPoint = spVertex->GetPoint();
		if(pPoint == NULL)
		{
			cout<<"GetPoint failed."<<endl;
			continue;
		}

		pPoint->GetMathPoint(oMathPoint);

		oMathPtList.Append(oMathPoint);
	}
	if(oMathPtList.Size()<=0)
	{
		return E_FAIL;
	}
	return S_OK;
}

//描述：元素相合
//输入：CATGeoFactory Geo工厂,CATTopData*对象 CATLISTP(CATBody）Body集合
//输出：CATMathPoint 中点
//返回：HRESULT
CATBody*CreateTopAssembly(CATGeoFactory* ipGeoFactory,CATTopData* itopdata,CATLISTP(CATBody) ListOfBodyLst)
{
	if(NULL == ipGeoFactory || NULL == itopdata || ListOfBodyLst.Size()<=0)
	{
		return NULL;
	}

	ListPOfCATBody * HListOfSurface=&ListOfBodyLst;
	CATHybAssemble * pSurfaceHybAssemble=CATCreateTopAssemble(ipGeoFactory,itopdata,HListOfSurface);
	if (pSurfaceHybAssemble==NULL)
		return NULL;

	pSurfaceHybAssemble->Run();
	CATBody*pSurfaceBody= pSurfaceHybAssemble->GetResult();
	if (pSurfaceBody==NULL)
		return NULL;

	delete pSurfaceHybAssemble; 
	pSurfaceHybAssemble = NULL;

	return pSurfaceBody;
}

//描述：元素相合-----用于2维
//输入：CATGeoFactory Geo工厂,CATTopData*对象 CATLISTP(CATBody）Body集合
//输出：CATMathPoint 中点
//返回：HRESULT
CATBody*CreateNewTopAssembly(CATGeoFactory* ipGeoFactory,CATTopData* itopdata,CATLISTP(CATBody) ListOfBodyLst)
{
	if(NULL == ipGeoFactory || NULL == itopdata || ListOfBodyLst.Size()<=0)
	{
		return NULL;
	}

	ListPOfCATBody * HListOfSurface=&ListOfBodyLst;
	CATHybAssemble * pSurfaceHybAssemble=CATCreateNewTopAssemble(ipGeoFactory,itopdata,HListOfSurface);
	if (pSurfaceHybAssemble==NULL)
		return NULL;

	CATLISTP(CATCell) lstAllCells;
	for (int i=1;i<=ListOfBodyLst.Size();i++)
	{
		CATBody *pBody = ListOfBodyLst[i];
		if (pBody==NULL)
		{
			continue;
		}
		CATLISTP(CATCell) lstCells;
		pBody->GetAllCells(lstCells,2);
		if (lstCells.Size()>0)
		{
			lstAllCells.Append(lstCells);
		}

	}
	pSurfaceHybAssemble->SetCellsToMerge(lstAllCells);
	pSurfaceHybAssemble->Run();
	CATBody*pSurfaceBody= pSurfaceHybAssemble->GetResult();
	if (pSurfaceBody==NULL)
		return NULL;

	delete pSurfaceHybAssemble; 
	pSurfaceHybAssemble = NULL;

	return pSurfaceBody;
}

//描述：根据曲线Body求出计算中点
//输入：CATBody_var曲线body,CATGeoFactory* geo工厂,CATTopData*data对象
//输出：CATMathPoint 中点
//返回：HRESULT
HRESULT GetMiddlePoint( CATBody_var spResultBody,CATGeoFactory* ipGeoFactory, CATTopData* itopdata,CATMathPoint &omiddlePoint )
{
	CATLISTV(CATMathPoint)  pPointList;
	CATCurve_var spCurveTemp1 = NULL_var;
	double d_CurveLength = 0;

	CATLISTP(CATCell) pLISTCurveCell; 
	CATLISTP(CATCell) LISTCell; 
	spResultBody->GetAllCells( LISTCell, 1 ); 
	for( int index1 = 1; index1 <= LISTCell.Size(); index1++ )
	{ 
		CATCell *pCurveCell1 = LISTCell[index1]; 
		if(pCurveCell1==NULL)
			continue;

		CATCell_var spCurveCell1 = pCurveCell1; 
		if(spCurveCell1==NULL_var)
			continue; 

		CATEdge_var spEdgeTemp1 = spCurveCell1; 
		if(spEdgeTemp1==NULL_var)
			continue; 

		CATVertex*  oStartVertex=NULL;
		CATVertex*  oEndVertex=NULL;
		spEdgeTemp1->GetVertices(&oStartVertex, &oEndVertex);
		if (oEndVertex==NULL||oStartVertex==NULL)
		{
			cout<<"GetVertices Failed"<<endl;
			continue; 
		}

		CATPoint * pStartPoint=oStartVertex->GetPoint( );
		CATPoint * pEndPoint=oEndVertex->GetPoint( );
		if (pStartPoint==NULL||pEndPoint==NULL)
		{
			cout<<"GetPoint Failed"<<endl;
			continue; 
		}

		CATMathPoint sStartPoint ;
		pStartPoint->GetMathPoint(sStartPoint);
		CATMathPoint sEndPoint ;
		pEndPoint->GetMathPoint(sEndPoint);

		CATDynMassProperties3D*  iMass = CATDynCreateMassProperties3D(itopdata,(CATEdge *)spEdgeTemp1);
		if (iMass==NULL)
			continue;

		CATPositiveLength iLength = iMass->GetLength();

		d_CurveLength+=iLength;

		pPointList.Append(sStartPoint);
		pPointList.Append(sEndPoint);

		pLISTCurveCell.Append(spCurveCell1);
		pLISTCurveCell.Append(spCurveCell1);
	}
	//----增加两个列表
	CATLISTV(CATMathPoint) lstAllPoints = NULL;
	CATLISTP(CATCell) lstAllCells = NULL;
	lstAllPoints = pPointList;
	lstAllCells = pLISTCurveCell;

	CATLISTV(CATMathPoint) PointList;
	CATLISTP(CATCell) LISTCurveCell; 
	for (int j=pPointList.Size();j>=1;j--)
	{
		//cout<<"X:"<<pPointList[j].GetX()<<endl;
		//cout<<"Y:"<<pPointList[j].GetY()<<endl;
		//cout<<"Z:"<<pPointList[j].GetZ()<<endl;

		bool b_found = false;
		for (int k=pPointList.Size();k>=1;k--)
		{
			if (j==k)
				continue;

			if (pPointList[j].DistanceTo(pPointList[k])<=0.01)
			{
				b_found = true;
				break;
			}

		}

		if (b_found==false)
		{
			PointList.Append(pPointList[j]);
			LISTCurveCell.Append(pLISTCurveCell[j]);
		}
	}

	pPointList.RemoveAll();
	pPointList=PointList;

	pLISTCurveCell.RemoveAll();
	pLISTCurveCell=LISTCurveCell;

	if (pPointList.Size()==2)
	{
		cout<<"一整段线"<<endl;

		//cout<<"X:"<<pPointList[1].GetX()<<endl;
		//cout<<"Y:"<<pPointList[1].GetY()<<endl;
		//cout<<"Z:"<<pPointList[1].GetZ()<<endl;

		//cout<<"X:"<<pPointList[2].GetX()<<endl;
		//cout<<"Y:"<<pPointList[2].GetY()<<endl;
		//cout<<"Z:"<<pPointList[2].GetZ()<<endl;

	}
	else
	{
		cout<<"断开的线"<<endl;

		//先把总长清空
		d_CurveLength = 0;

		//获取Z值最大的点
		//
		CATMathPoint mathPointZmax;
		double zmax=-1000000;
		CATCell_var spMaxCurveCell1=NULL_var;
		for (int i=1;i<=pPointList.Size();i++)
		{
			if (pPointList[i].GetZ()>zmax)
			{
				zmax=pPointList[i].GetZ();
				mathPointZmax = pPointList[i];	//增加最大点的输出
				spMaxCurveCell1=pLISTCurveCell[i];
			}
		}

		if (spMaxCurveCell1==NULL_var)
		{
			cout<<"获取Z向最大的曲线失败"<<endl;
			return E_FAIL;
		}
		//在最初的列表中找到这个最大值
		int iIndex = 0;
		for (int i = 1; i <= lstAllPoints.Size();i++)
		{
			if (mathPointZmax.DistanceTo(lstAllPoints[i])<=0.01)
			{
				iIndex = i;
			}
		}
		if (iIndex == 0)
		{
			return E_FAIL;
		}
		//根据这个在列表中的序号的奇数偶数，找到这个z最大点所在cell的另一个端点
		int iIndexAnother = 0;
		if (iIndex % 2 == 0)
		{
			iIndexAnother = iIndex - 1;
		}
		else
		{
			iIndexAnother = iIndex + 1;
		}
		if (iIndexAnother == 0)
		{
			return E_FAIL;
		}
		//新建一个空的列表存放连在一起的空的cell，先把z最大值的那个点对应的cell放进去
		CATLISTP(CATCell) lstAllConnectCells = NULL;
		lstAllConnectCells.Append(lstAllCells[iIndex]);
		//开始从另一个端点比较，如果和某个端点重合，则把对方端点对应的cell存起来，同时把整段连接线的另一个端点找到
		//CATBoolean bEndPoint = TRUE;
		CATMathPoint mathPointEndPt;
		for (int i=1; i <= lstAllPoints.Size();i++)
		{
			if (iIndexAnother == i)
			{
				continue;
			}
			if (lstAllPoints[iIndexAnother].DistanceTo(lstAllPoints[i]) <= 0.01)
			{
				//bEndPoint = FALSE;
				lstAllConnectCells.Append(lstAllCells[i]);
				if (i % 2 == 0)
				{
					iIndexAnother = i - 1;
					i = 1;
					continue;
				}
				else
				{
					iIndexAnother = i + 1;
					i = 1;
					continue;
				}
			}
			mathPointEndPt = lstAllPoints[iIndexAnother];

		}
		//重新把pointlist生成一下
		pPointList.RemoveAll();
		pPointList.Append(mathPointZmax);
		pPointList.Append(mathPointEndPt);
		//然后把cell列表转成body列表，并求出总长
		CATLISTP(CATBody) lstBodyFromConnectCells = NULL;
		for (int i=1 ; i<=lstAllConnectCells.Size(); i++)
		{
			CATEdge_var spEdgeTemp1 = lstAllConnectCells[i]; 
			if(spEdgeTemp1==NULL_var)
				return E_FAIL;
			CATDynMassProperties3D*  iMass = CATDynCreateMassProperties3D(itopdata,(CATEdge *)spEdgeTemp1);
			if (iMass==NULL)
				return E_FAIL;

			CATPositiveLength iLength = iMass->GetLength();

			d_CurveLength+=iLength;

			//
			spResultBody=NULL_var;

			spResultBody=ipGeoFactory->CreateBody();
			if (spResultBody==NULL_var) return E_FAIL;

			CATWire *pWire=spResultBody->CreateWire();
			if (pWire==NULL)	
			{
				cout<<"CreateShell Failed"<<endl;
				return E_FAIL;
			}

			pWire->AddCell((CATCell*)spEdgeTemp1);
			spResultBody->AddDomain(pWire);
			spResultBody->Completed();

			lstBodyFromConnectCells.Append(spResultBody);
		}

		if (lstBodyFromConnectCells.Size() == 0)
		{
			return E_FAIL;
		}
		//把这些body组合起来
		ListPOfCATBody * HListOfCurve=&lstBodyFromConnectCells;
		CATHybAssemble * pCurveHybAssemble=CATCreateTopAssemble(ipGeoFactory, itopdata, HListOfCurve);
		if (pCurveHybAssemble==NULL)
			return E_FAIL;

		pCurveHybAssemble->Run();
		CATBody*pCurveBody= pCurveHybAssemble->GetResult();
		if (pCurveBody==NULL)
			return E_FAIL;
		//
		spResultBody = pCurveBody;

		delete pCurveHybAssemble; 
		pCurveHybAssemble = NULL;

		//CATEdge_var spEdgeTemp1 = spMaxCurveCell1; 
		//if(spEdgeTemp1==NULL_var)
		//	return E_FAIL;

		//CATVertex*  oStartVertex=NULL;
		//CATVertex*  oEndVertex=NULL;
		//spEdgeTemp1->GetVertices(&oStartVertex, &oEndVertex);
		//if (oEndVertex==NULL||oStartVertex==NULL)
		//{
		//	cout<<"GetVertices Failed"<<endl;
		//	return E_FAIL;
		//}

		//CATPoint * pStartPoint=oStartVertex->GetPoint( );
		//CATPoint * pEndPoint=oEndVertex->GetPoint( );
		//if (pStartPoint==NULL||pEndPoint==NULL)
		//{
		//	cout<<"GetPoint Failed"<<endl;
		//	return E_FAIL;
		//}

		//CATMathPoint sStartPoint ;
		//pStartPoint->GetMathPoint(sStartPoint);
		//CATMathPoint sEndPoint ;
		//pEndPoint->GetMathPoint(sEndPoint);

		//pPointList.RemoveAll();
		//pPointList.Append(sStartPoint);
		//pPointList.Append(sEndPoint);

		//CATDynMassProperties3D*  iMass = CATDynCreateMassProperties3D(itopdata,(CATEdge *)spEdgeTemp1);
		//if (iMass==NULL)
		//	return E_FAIL;

		//CATPositiveLength iLength = iMass->GetLength();

		//d_CurveLength=iLength;

		//spResultBody=NULL_var;

		//spResultBody=ipGeoFactory->CreateBody();
		//if (spResultBody==NULL_var) return E_FAIL;

		//CATWire *pWire=spResultBody->CreateWire();
		//if (pWire==NULL)	
		//{
		//	cout<<"CreateShell Failed"<<endl;
		//	return E_FAIL;
		//}

		//pWire->AddCell((CATCell*)spEdgeTemp1);
		//spResultBody->AddDomain(pWire);
		//spResultBody->Completed();

	}
	//分别用两个端点求出2个方向上的中点，比较距离求出最终的中点
	CATLISTV(CATMathPoint) lstMidPt = NULL;
	for (int i=1; i <= pPointList.Size(); i++)
	{
		CATBody * StartBody =::CATCreateTopPointXYZ( ipGeoFactory,itopdata,pPointList[i].GetX(),pPointList[i].GetY(),pPointList[i].GetZ());
		if (StartBody==NULL)
		{
			cout<<"CATCreateTopPointXYZ Failed"<<endl;
			return E_FAIL;
		}

		CATBody * spBodyOfMidPoint1 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,0.5*d_CurveLength,StartBody,CatTopPointLValue);
		if (spBodyOfMidPoint1==NULL)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}

		CATLISTV(CATMathPoint)  MathPtList;
		GetMathPtsFromBody(spBodyOfMidPoint1,MathPtList);
		if (MathPtList.Size()==0)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		lstMidPt.Append(MathPtList[1]);
	}
	//反向
	for (int i=1; i <= pPointList.Size(); i++)
	{
		CATBody * StartBody =::CATCreateTopPointXYZ( ipGeoFactory,itopdata,pPointList[i].GetX(),pPointList[i].GetY(),pPointList[i].GetZ());
		if (StartBody==NULL)
		{
			cout<<"CATCreateTopPointXYZ Failed"<<endl;
			return E_FAIL;
		}

		CATBody * spBodyOfMidPoint1 = ::CATCreateTopPointOnWire(ipGeoFactory,itopdata,spResultBody,-0.5*d_CurveLength,StartBody,CatTopPointLValue);
		if (spBodyOfMidPoint1==NULL)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}

		CATLISTV(CATMathPoint)  MathPtList;
		GetMathPtsFromBody(spBodyOfMidPoint1,MathPtList);
		if (MathPtList.Size()==0)
		{
			cout<<"CATCreateTopPointOnWire Failed"<<endl;
			return E_FAIL;
		}
		lstMidPt.Append(MathPtList[1]);
	}
	cout<<"-----------Middle Point List------------"<<endl;
	for (int i=1; i <= lstMidPt.Size(); i++)
	{
		lstMidPt[i].Dump();
	}
	//判断list中相同的点即为中点
	omiddlePoint = lstMidPt[1]; //给个初值
	CATBoolean bFind = FALSE;
	for (int i = 1; i <= lstMidPt.Size(); i++)
	{
		for (int j = lstMidPt.Size(); j>i; j--)
		{
			if (lstMidPt[i].DistanceTo(lstMidPt[j]) <= 0.01)
			{
				omiddlePoint.SetCoord(lstMidPt[i].GetX(),lstMidPt[i].GetY(),lstMidPt[i].GetZ()); //更新，原来直接用的等于，不对的
				bFind = TRUE;
				break;
			}
		}
		if (bFind == TRUE)
		{
			break;
		}
	}

	return S_OK;

}

//描述：从CATBody转到CATCell再获取每个Cell的包围盒
//输入：CATBody_var body对象
//输出：oMathBox 包围盒
//返回：HRESULT
HRESULT GetBodyBox( CATBody_var spBody, CATMathBox& oMathBox )
{
	HRESULT  HR_END  =  E_FAIL;
	CATVertex_var  spCell;
	CATPoint_var  spPoint;
	CATMathPoint  iMathPoint;
	CATLISTP(CATCell)  iCellList  =  NULL;
	spBody  ->  GetAllCells(iCellList,0);
	if  (iCellList  !=  NULL  &&  iCellList.Size()  >  0)
	{
		int  nums  =  iCellList.Size();
		for  (int  i  =  1  ;  i<=nums;  i++)
		{
			spCell  =  NULL_var;
			spCell  =  iCellList[i]; 
			spPoint  =  NULL_var;
			spPoint  =  spCell->GetPoint();
			iMathPoint  =  NULL;
			spPoint->GetMathPoint(iMathPoint);
			oMathBox.AddInside(iMathPoint);
		}
		HR_END  =  S_OK;
	}
	return  HR_END;
}

//描述：从直线中获取首尾端点坐标数组
//输入：CATISpecObject_var对象
//输出：double首尾坐标
//返回：void
void GetPointCoordFromLine( CATISpecObject_var spLine,double oStartPoint[3],double oEndPoint[3])
{
	CATBody_var spExpDirBody = GetBodyFromFeature(spLine);
	CATLISTP(CATCell) expDirCellList = NULL;
	spExpDirBody -> GetAllCells(expDirCellList,1);
	CATCell_var spCell = expDirCellList[1];
	CATEdge_var spEdge = spCell;
	CATVertex* piStartVertex = NULL; CATVertex* piEndVertex = NULL;
	spEdge->GetVertices( &piStartVertex,&piEndVertex);
	CATVertex_var spStartVertex = piStartVertex;
	CATVertex_var spEndVertex = piEndVertex;
	piStartVertex->Release(); piStartVertex = NULL; 
	piEndVertex->Release(); piEndVertex = NULL; 
	GetPointCoordFromVertex(spStartVertex,oStartPoint);
	GetPointCoordFromVertex(spEndVertex,oEndPoint);
}

//描述：从顶点中获取坐标数组
//输入：CATVertex对象
//输出：double
//返回：void
void GetPointCoordFromVertex( CATVertex_var spVertex,double oPointCoord [3])
{
	CATPoint_var spPoint = spVertex->GetPoint();
	oPointCoord[0] = spPoint->GetX();
	oPointCoord[1] = spPoint->GetY();
	oPointCoord[2] = spPoint->GetZ();
}

//描述：向量转换
//输入：CATMathVector，CATMathTransformation
//输出：CATMathVector
//返回：CATMathVector
CATMathPoint MathPointPositionTransformation(CATMathPoint  mathPoint,CATMathTransformation mathTransf)
{
	double  pAbsoluteCoeff[12] ;
	mathTransf.GetCoef(pAbsoluteCoeff);
	CATMathVector uVec(pAbsoluteCoeff[0],pAbsoluteCoeff[1],pAbsoluteCoeff[2]);
	CATMathVector vVec(pAbsoluteCoeff[3],pAbsoluteCoeff[4],pAbsoluteCoeff[5]);
	CATMathVector wVec(pAbsoluteCoeff[6],pAbsoluteCoeff[7],pAbsoluteCoeff[8]);
	CATMathVector moveVec(pAbsoluteCoeff[9],pAbsoluteCoeff[10],pAbsoluteCoeff[11]);
	CATMathVector  pointVec = (uVec * mathPoint.GetX()) + (vVec * mathPoint.GetY()) + (wVec * mathPoint.GetZ()) + moveVec;
	return CATMathPoint(pointVec.GetX(),pointVec.GetY(),pointVec.GetZ());
}

//描述：向量转换
//输入：CATMathVector，CATMathTransformation
//输出：CATMathVector
//返回：CATMathVector
CATMathVector MathVectorPositionTransformation(CATMathVector  mathVector,CATMathTransformation mathTransf)
{
	double  pAbsoluteCoeff[12] ;
	mathTransf.GetCoef(pAbsoluteCoeff);
	CATMathVector uVec(pAbsoluteCoeff[0],pAbsoluteCoeff[1],pAbsoluteCoeff[2]);
	CATMathVector vVec(pAbsoluteCoeff[3],pAbsoluteCoeff[4],pAbsoluteCoeff[5]);
	CATMathVector wVec(pAbsoluteCoeff[6],pAbsoluteCoeff[7],pAbsoluteCoeff[8]);
	CATMathVector moveVec(pAbsoluteCoeff[9],pAbsoluteCoeff[10],pAbsoluteCoeff[11]);
	CATMathVector  resultVec = (uVec * mathVector.GetX()) + (vVec * mathVector.GetY()) + (wVec * mathVector.GetZ());
	return CATMathVector(resultVec.GetX(),resultVec.GetY(),resultVec.GetZ());
}

//描述：获取单个零件Product的包围盒
//输入：CATIProduct对象
//输出：CATMathBox
//返回：HRESULT
HRESULT GetPartInstanceBoundingBox(CATIProduct_var spProduct,CATMathPoint oProductBox[8])
{
	HRESULT rc =E_FAIL ;
	CATUnicodeString strPartNumber =  spProduct->GetPartNumber();
	CATUnicodeString strPartName =""  ;
	spProduct->GetPrdInstanceName(strPartName);
	CATUnicodeString strDocName = "";
	int childCount = spProduct->GetChildrenCount(); 
	if (childCount == 0)
	{

		//获取文档
		CATIProduct_var spProductRef = spProduct->GetReferenceProduct();

		if(spProductRef != NULL_var)
		{
			CATMathBox PartBox ;
			double   ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax;
			rc = GetPartBoundingBox(spProductRef,PartBox);
			if (rc != E_FAIL)
			{
				CATIMovable_var piMovableOnInstance = NULL_var;
				spProduct -> QueryInterface (IID_CATIMovable,(void**) &piMovableOnInstance);

				PartBox.GetExtremities (ioXMin,ioXMax, ioYMin,  ioYMax,  ioZMin,  ioZMax);
				CATMathPoint  iLow1(ioXMin,ioYMin,ioZMin);
				CATMathPoint  iLow2(ioXMin,ioYMax,ioZMin);
				CATMathPoint  iLow3(ioXMax,ioYMax,ioZMin);
				CATMathPoint  iLow4(ioXMax,ioYMin,ioZMin);
				CATMathPoint  iHigh1(ioXMin,ioYMin,ioZMax);
				CATMathPoint  iHigh2(ioXMin,ioYMax,ioZMax);
				CATMathPoint  iHigh3(ioXMax,ioYMax,ioZMax);
				CATMathPoint  iHigh4(ioXMax,ioYMin,ioZMax);
				oProductBox[0] = iLow1;
				oProductBox[1] = iLow2;
				oProductBox[2] = iLow3;
				oProductBox[3] = iLow4;
				oProductBox[4] = iHigh1;
				oProductBox[5] = iHigh2;
				oProductBox[6] = iHigh3;
				oProductBox[7] = iHigh4;
				return   S_OK ;
			}
		}
	}
	return E_FAIL;

}
//描述：获取Part的包围盒
//输入：CATIProduct对象
//输出：CATMathBox
//返回：HRESULT
HRESULT GetPartBoundingBox(CATIProduct_var spPrtProduct,CATMathBox& oPartBoundingBox )
{
	HRESULT rc =E_FAIL ;

	if (spPrtProduct != NULL_var)
	{
		CATUnicodeString strPartNumber = spPrtProduct->GetPartNumber();
		CATIDescendants_var spDescPart=NULL_var;
		if (SUCCEEDED(spPrtProduct->QueryInterface(IID_CATIDescendants, (void**)&spDescPart))  && spDescPart != NULL_var)
		{
			CATListValCATISpecObject_var  spBodyList = NULL;
			spDescPart->GetAllChildren("CATIMechanicalFeature",spBodyList);

			if(spBodyList !=NULL && spBodyList.Size()>0)
			{
				CATIMechanicalFeature_var spMechPart=NULL_var;
				if (SUCCEEDED(spBodyList[1]->QueryInterface(IID_CATIMechanicalFeature , (void**)&spMechPart))  && spMechPart != NULL_var)
				{
					CATISpecObject_var spPart = spMechPart->GetPart();
					CATIPrtPart_var spPrtPart = spPart;
					if(spPrtPart != NULL_var)
					{
						rc = GetPartBoundingBox( spPrtPart,oPartBoundingBox );
					}
				}
			}
			else
			{
				CATIPrtContainer *piPartContainer = NULL ;
				CATIPrtPart_var spPrtPart = NULL_var; 

				CATILinkableObject_var spLink =NULL_var;
				if (SUCCEEDED(spPrtProduct->QueryInterface(IID_CATILinkableObject, (void**)&spLink))   && NULL_var != spLink ) 
				{
					CATDocument *piDoc = spLink->GetDocument(); 
					if ( NULL != piDoc )
					{ 
						CATInit *pDocAsInit = NULL;
						if (SUCCEEDED(piDoc->QueryInterface(IID_CATInit, (void**)&pDocAsInit))   && NULL != pDocAsInit ) 
						{
							piPartContainer = (CATIPrtContainer*)pDocAsInit->GetRootContainer("CATIPrtContainer");
							pDocAsInit->Release(); pDocAsInit = NULL ;   
							if( NULL != piPartContainer )      
							{
								CATISpecObject_var spPart = piPartContainer->GetPart() ; 
								spPrtPart = spPart ;
							}  				
						}
						piDoc-> Release(); piDoc = NULL; 
					}
				}
				if ( NULL !=piPartContainer ) 
				{ 
					piPartContainer -> Release(); piPartContainer = NULL; 
				}

				if(spPrtPart != NULL_var)
				{
					rc = GetPartBoundingBox( spPrtPart,oPartBoundingBox );
				}
			}
			spBodyList = NULL;
		}
	}

	return rc;
}
//描述：获取单3D Geometrical Element
//输入：CATISpecObject_var对象
//输出：vector
//返回：void
void GetGeomElmFromGSetAndBody(CATISpecObject_var ispiGSet,vector<CATISpecObject_var>& ospiGeomElmList ,vector<CATISpecObject_var>& ospiGSMElmList ,vector<CATISpecObject_var>& ospiSolidElmList )
{
	bool blShowValue = FALSE;
	blShowValue = CheckShowState(ispiGSet);
	CATUnicodeString strGSName = ispiGSet->GetName();

	CATUnicodeString strTemp = GetSpecBasicName(ispiGSet);

	if(!blShowValue)//显示
	{
		/*
		Surfacic features sets: 
		Geometrical Set (or GS) (startup: GSMTool, CATIMmiNonOrderedGeometricalSet) 
		Ordered Geometrical Set (or OGS) (startup: GSMTool,  CATIMmiOrderedGeometricalSet) 

		Bodies: 
		Solid features set (user name: Body) (startup: MechanicalTool,CATIMechanicalTool) 
		Solid and Surfacic features sets (user name: Body) (startup: HybridBody) 
		*/
		//GeometricObjects.CATGeometry//PartInterfaces.CATIShape//GSMInterfaces.CATIGSMLinePtDir
		//CATI3DGeometricalElement//CATISpecObject//CATICGMObject
		CATIDescendants_var spDesc=NULL_var;
		if (SUCCEEDED(ispiGSet->QueryInterface(IID_CATIDescendants, (void**)&spDesc)) && spDesc != NULL_var)
		{
			CATIMechanicalTool_var spMechanicalTool = NULL_var;
			if (SUCCEEDED(ispiGSet->QueryInterface(IID_CATIMechanicalTool, (void**)&spMechanicalTool)) && spMechanicalTool != NULL_var)
			{
				CATISpecObject_var  spLastShape = spMechanicalTool->GetLastShapeFeatureSuccessfullyUpdated();
				if(spLastShape != NULL_var)
				{
					bool blShowValueSub = FALSE;
					blShowValueSub = CheckShowState(spLastShape);
					if(!blShowValueSub)//显示
					{
						ospiSolidElmList.push_back(spLastShape);
					}		
				}
			}
			else
			{
				CATListValCATISpecObject_var sp3DGeomElmList = NULL;
				spDesc->GetDirectChildren( "CATI3DGeometricalElement" ,sp3DGeomElmList );
				if ( sp3DGeomElmList != NULL  && sp3DGeomElmList.Size()>0)
				{
					for(int f = 1;f<=sp3DGeomElmList.Size();f++ )
					{
						bool blShowValueSub = FALSE;
						blShowValueSub = CheckShowState(sp3DGeomElmList[f]);
						if(!blShowValueSub)//显示
						{
							CATIShape_var spShape=NULL_var;
							CATGeometry_var spGeometry=NULL_var;
							if (SUCCEEDED(sp3DGeomElmList[f]->QueryInterface(IID_CATIShape, (void**)&spShape)) && spShape != NULL_var)
							{
								ospiSolidElmList.push_back(sp3DGeomElmList[f]);
							}
							if (SUCCEEDED(sp3DGeomElmList[f]->QueryInterface(IID_CATGeometry, (void**)&spGeometry)) && spGeometry != NULL_var)
							{
								ospiGeomElmList.push_back(sp3DGeomElmList[f]);
							}
							else
							{
								ospiGSMElmList.push_back(sp3DGeomElmList[f]);
							}
						}
					}
				}
				sp3DGeomElmList = NULL;
			}


			CATListValCATISpecObject_var NonOrderedGSList = NULL;
			spDesc->GetDirectChildren( "CATIMmiNonOrderedGeometricalSet" ,NonOrderedGSList );
			if (  NonOrderedGSList != NULL && NonOrderedGSList.Size()>0)
			{
				for(int f = 1;f<=NonOrderedGSList.Size();f++ )
				{
					GetGeomElmFromGSetAndBody( NonOrderedGSList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
				}
			}
			NonOrderedGSList = NULL;

			CATListValCATISpecObject_var OrderedGSList = NULL;
			spDesc->GetDirectChildren( "CATIMmiOrderedGeometricalSet" ,OrderedGSList );
			if ( OrderedGSList != NULL  && OrderedGSList.Size()>0)
			{
				for(int f = 1;f<=OrderedGSList.Size();f++ )
				{
					GetGeomElmFromGSetAndBody( OrderedGSList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
				}
			}
			OrderedGSList = NULL;

			CATListValCATISpecObject_var MechToolList = NULL;
			spDesc->GetDirectChildren( "CATIMechanicalTool" ,MechToolList );
			if (   MechToolList  != NULL && MechToolList.Size()>0)
			{
				for(int f = 1;f<=MechToolList.Size();f++ )
				{
					GetGeomElmFromGSetAndBody( MechToolList[f],ospiGeomElmList ,ospiGSMElmList , ospiSolidElmList );
				}
			}
			MechToolList = NULL;
		}
	}
}

//
//描述：获取文档类型
//输入：CATUnicodeString窗口名称
//输出：CATDocument
//返回：void
CATUnicodeString  GetDocumentType( CATFrmWindow * pWind,CATDocument ** pDoc  )
{
	CATUnicodeString oType = "";
	if (pWind!= NULL)
	{
		CATDocument * pCurDoc = NULL;
		CATFrmEditor * pEditor = pWind -> GetEditor();
		if (pEditor!= NULL)
		{
			pCurDoc = pEditor -> GetDocument();
			if(pDoc!= NULL)
			{
				CATIDocId* oDocId = NULL;
				pCurDoc -> GetDocId(&oDocId);
				oDocId -> GetType(oType); 
				oDocId->Release();oDocId = NULL;
				*pDoc = pCurDoc;
				return oType;
			}
			pEditor = NULL;
		}
	}
	return "";
}

//描述：获取文档窗口，通过名称
//输入：CATUnicodeString窗口名称
//输出：CATFrmWindow
//返回：void
void GetFrmWindowByName(CATUnicodeString WindName , CATFrmWindow** owindow)
{
	CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
	CATLISTP(CATFrmWindow) pWindowList = pLayout->GetWindowList( 0,0)  ;
	if (pWindowList.Size() != 0)
	{
		for (int i =1;i<=pWindowList.Size();i++)
		{
			if(NULL != pWindowList[i])
			{
				CATUnicodeString pWindName = pWindowList[i]->GetBaseName();
				if(WindName == pWindName)
				{
					*owindow = (pWindowList[i]);
					return;
				}
			}
		}
	}
}

//描述：从BaseUnknown中获取特征
//输入：CATBaseUnknown_var对象
//输出：CATISpecObject
//返回：CATISpecObject
CATISpecObject_var  TransferBUtoSpecObj(CATBaseUnknown_var ispBaseUnkn)
{
	if(NULL_var == ispBaseUnkn)
	{
		return NULL_var;
	}
	CATISpecObject_var spSelObj = NULL_var;
	HRESULT rc = ispBaseUnkn->QueryInterface(IID_CATISpecObject, (void**)&spSelObj);
	if ( !SUCCEEDED(rc) )
	{
		CATIBRepAccess_var spBRep = ispBaseUnkn;
		if (spBRep == NULL_var)
		{
			return NULL_var;
		}
		CATISpecObject_var spSpecObj = spBRep;
		if (spSpecObj != NULL_var)
		{	
			return spSpecObj;
		}	
		CATIFeaturize * pFeaturize = NULL;
		HRESULT rc = spBRep->QueryInterface(IID_CATIFeaturize,(void**)&pFeaturize);	
		if(FAILED(rc)||(NULL_var == pFeaturize))
		{
			return spSpecObj; 
		}	
		spSpecObj = pFeaturize->FeaturizeR(MfTemporaryBody|MfSelectingFeatureSupport|MfNoDuplicateFeature);
		return spSpecObj;
	}
	return spSelObj ;
}
//在零件根目录下下创建PrtTool
HRESULT CreateNewPrtTool(CATIProduct_var ispiProd,CATUnicodeString istrName,CATISpecObject_var &ospiSpecPrtTool)
{
	HRESULT rc = S_OK;
	if (ispiProd == NULL_var)
	{
		return E_FAIL;
	}
	CATIProduct_var spiProdRef = ispiProd->GetReferenceProduct();
	if (spiProdRef == NULL_var)
	{
		return E_FAIL;
	}
	CATILinkableObject *piLinkableObjOnChild = NULL;
	rc = spiProdRef->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObjOnChild);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATDocument *pDocOnChild = NULL;
	pDocOnChild = piLinkableObjOnChild->GetDocument();
	if (NULL == pDocOnChild)
	{
		return E_FAIL;
	}
	CATIContainerOfDocument_var spContOfDocOnChild = pDocOnChild;
	CATIContainer *piSpecContainerOnChild = NULL;
	rc = spContOfDocOnChild->GetSpecContainer(piSpecContainerOnChild);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATIPrtContainer *piPrtContainerOnChild = NULL;
	rc = piSpecContainerOnChild->QueryInterface(IID_CATIPrtContainer,(void**)&piPrtContainerOnChild);
	piSpecContainerOnChild->Release();
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATIPrtPart_var spPartOnChild = piPrtContainerOnChild->GetPart();
	piPrtContainerOnChild->Release();
	if (NULL_var == spPartOnChild)
	{
		return E_FAIL;
	}
	//
	CATIMechanicalRootFactory_var spMechRootFactory = piSpecContainerOnChild;
	if (spMechRootFactory == NULL_var)
	{
		return E_FAIL;
	}
	//
	CATISpecObject_var spiSpecPrtTool = spMechRootFactory->CreatePRTTool(istrName,spPartOnChild);
	if (spiSpecPrtTool == NULL_var)
	{
		return E_FAIL;
	}
	//
	spPartOnChild->SetCurrentFeature(spiSpecPrtTool);
	ospiSpecPrtTool = spiSpecPrtTool;
	return rc;
}

//在零件根目录下创建GeoSet，创建前先判断是否已经存在
HRESULT CreateNewGeoSet(CATIProduct_var ispiProd,CATUnicodeString istrName,CATISpecObject_var &ospiSpecGeoSet)
{
	HRESULT rc = S_OK;
	if (ispiProd == NULL_var)
	{
		return E_FAIL;
	}
	CATIProduct_var ispiProdRef = ispiProd->GetReferenceProduct();
	if (ispiProdRef==NULL_var)
	{
		return E_FAIL;
	}
	CATILinkableObject *piLinkableObjOnChild = NULL;
	rc = ispiProdRef->QueryInterface(IID_CATILinkableObject,(void**)&piLinkableObjOnChild);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATDocument *pDocOnChild = NULL;
	pDocOnChild = piLinkableObjOnChild->GetDocument();
	if (NULL == pDocOnChild)
	{
		return E_FAIL;
	}
	CATIContainerOfDocument_var spContOfDocOnChild = pDocOnChild;
	CATIContainer *piSpecContainerOnChild = NULL;
	rc = spContOfDocOnChild->GetSpecContainer(piSpecContainerOnChild);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATIPrtContainer *piPrtContainerOnChild = NULL;
	rc = piSpecContainerOnChild->QueryInterface(IID_CATIPrtContainer,(void**)&piPrtContainerOnChild);
	piSpecContainerOnChild->Release();
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	CATIPrtPart_var spPartOnChild = piPrtContainerOnChild->GetPart();
	piPrtContainerOnChild->Release();
	if (NULL_var == spPartOnChild)
	{
		return E_FAIL;
	}
	//先判断有没有RPS几何图形集
	CATIPartRequest *pPartAsRequest = NULL;
	rc = spPartOnChild->QueryInterface(IID_CATIPartRequest, (void**)&pPartAsRequest);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	//遍历所有GS
	CATLISTV(CATBaseUnknown_var) lstGeomSet = NULL;
	pPartAsRequest->GetSurfBodies("", lstGeomSet);
	//如果没有GS或者没有给名字，则直接建立
	CATISpecObject_var spChildTool = NULL_var;
	if (lstGeomSet == NULL || istrName == "")
	{
		//获得几何图形集创建的父级，该处为最外层根下
		CATISpecObject_var spParentTool = spPartOnChild;
		//
		CATIMechanicalRootFactory_var spMechRootFactory = piSpecContainerOnChild;
		//
		//CATISpecObject_var spChildTool = NULL_var;
		rc = spMechRootFactory->CreateGeometricalSet(istrName,spParentTool,spChildTool,-1);
		if (FAILED(rc))
		{
			return E_FAIL;
		}
		//定义到新建的几何图形集下
		spPartOnChild->SetCurrentFeature(spChildTool);
	}
	//有GS，则遍历GS，并判断是否已经含有该名字的几何图形集
	else
	{
		CATBoolean boolExistGS = FALSE;
		for (int i=1; i <= lstGeomSet.Size(); i++)
		{
			CATBaseUnknown_var spCurrentSet = lstGeomSet[i];
			if (spCurrentSet == NULL_var)
			{
				continue;
			}
			CATIAlias_var spAliasOnCurrentSet = spCurrentSet;
			CATUnicodeString strAliasOnCurrentSet = spAliasOnCurrentSet->GetAlias();
			//如果存在，则直接定义到该图形集
			if (strAliasOnCurrentSet == istrName)
			{
				spChildTool = spCurrentSet;
				spPartOnChild->SetCurrentFeature(spChildTool);
				boolExistGS = TRUE;
				break;
			}
		}
		//不存在，则新建图形集
		if (boolExistGS == FALSE)
		{
			//获得几何图形集创建的父级，该处为最外层根下
			CATISpecObject_var spParentTool = spPartOnChild;
			//
			CATIMechanicalRootFactory_var spMechRootFactory = piSpecContainerOnChild;
			//
			//CATISpecObject_var spChildTool = NULL_var;
			rc = spMechRootFactory->CreateGeometricalSet(istrName,spParentTool,spChildTool,-1);
			if (FAILED(rc))
			{
				return E_FAIL;
			}
			//定义到新建的几何图形集下
			spPartOnChild->SetCurrentFeature(spChildTool);
		}
	}
	ospiSpecGeoSet = spChildTool;
	return rc;
}

//描述：从文档获取根产品
//输入：CATDocument文档指针
//输出：CATProduct_var根产品指针
//返回：CATIProduct_var
CATIProduct_var GetRootProductFromDoc( CATDocument * ipDocument )
{
	HRESULT rc = E_FAIL;
	CATIProduct_var spRootProduct = NULL_var;
	if ( NULL != ipDocument)
	{
		//获取根元素集合的第一个，就是根product,最终要转到CATIProduct
		CATIDocRoots *piDocRootsOnDoc = NULL;
		HRESULT rc = ipDocument->QueryInterface(IID_CATIDocRoots,(void**)&piDocRootsOnDoc);
		if (FAILED(rc))
		{
			return NULL_var;
		}
		CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();
		CATIProduct_var spRootProduct = NULL_var;
		if (pRootProducts->Size())
		{
			spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
		}

		piDocRootsOnDoc->Release();

		return spRootProduct;
	}
	return NULL_var;
}
//描述：查找某对象
//输入：CATListValCATISpecObject_var集合对象，CATUnicodeString对象名称
//输出：CATListValCATISpecObject_var集合对象
//返回：HRESULT
HRESULT  SortProjectionElements( CATListValCATISpecObject_var LstElem, CATListValCATISpecObject_var &LstRound2DH, CATUnicodeString strProdName )
{
	HRESULT rc=S_OK;
	int i=0;
	int j=0;
	for(i=1;i<=LstElem.Size();i++)
	{
		CATIDftGenGeom *piGenGeom=NULL;
		rc=LstElem[i]->QueryInterface(IID_CATIDftGenGeom, (void**)&piGenGeom);
		if(SUCCEEDED(rc)&&piGenGeom!=NULL)
		{
			IUnknown* oProduct;
			rc = piGenGeom->GetProduct(IID_CATIProduct,&oProduct);
			if(FAILED(rc) ||oProduct == NULL) 
			{
				cout<<"Failed to Get CATIProduct."<<endl;
				break;
			}

			CATIProduct *pPrd =NULL;
			rc = oProduct->QueryInterface(IID_CATIProduct,(void **)&pPrd);
			if(FAILED(rc) || pPrd == NULL) 
			{
				cout<<"Failed to QI to CATIProduct."<<endl;
				break;
			}
			oProduct->Release();oProduct=NULL;

			CATIProduct_var spProd = pPrd;
			CATUnicodeString partname = spProd->GetPartNumber();
			//pPrd->GetPrdInstanceName(partname);
			//cout<<"partname : "<<partname<<endl;
			if (partname == strProdName)
			{
				//找到
				LstRound2DH.Append(LstElem[i]);
			}
			if(pPrd!=NULL) 
			{
				pPrd->Release();pPrd=NULL;
			}
			piGenGeom->Release();
			piGenGeom=NULL;
		}
	}
	return TRUE;
}

//描述：查找某对象
//输入：CATUnicodeString对象名称，CATListValCATISpecObject_var集合对象
//输出：CATListValCATISpecObject_var集合对象，CATListValCATISpecObject_var非集合对象，
//返回：HRESULT
HRESULT  SortProjectionElements( CATUnicodeString strProdName, CATListValCATISpecObject_var LstElem, CATListValCATISpecObject_var &oLstPrdCurve, CATListValCATISpecObject_var &oLstNoPrdCurve )
{
	HRESULT rc=S_OK;
	int i=0;
	int j=0;
	for(i=1;i<=LstElem.Size();i++)
	{
		CATIDftGenGeom *piGenGeom=NULL;
		rc=LstElem[i]->QueryInterface(IID_CATIDftGenGeom, (void**)&piGenGeom);
		if(SUCCEEDED(rc)&&piGenGeom!=NULL)
		{
			IUnknown* oProduct;
			rc = piGenGeom->GetProduct(IID_CATIProduct,&oProduct);
			if(FAILED(rc) ||oProduct == NULL) 
			{
				cout<<"Failed to Get CATIProduct."<<endl;
				break;
			}

			CATIProduct *pPrd =NULL;
			rc = oProduct->QueryInterface(IID_CATIProduct,(void **)&pPrd);
			if(FAILED(rc) || pPrd == NULL) 
			{
				cout<<"Failed to QI to CATIProduct."<<endl;
				break;
			}
			oProduct->Release();oProduct=NULL;

			CATIProduct_var spProd = pPrd;
			CATUnicodeString partname = spProd->GetPartNumber();
			//pPrd->GetPrdInstanceName(partname);
			//cout<<"partname : "<<partname<<endl;
			if (partname == strProdName)
			{
				//找到
				oLstPrdCurve.Append(LstElem[i]);
			}
			else
			{
				oLstNoPrdCurve.Append(LstElem[i]);
			}
			if(pPrd!=NULL) 
			{
				pPrd->Release();pPrd=NULL;
			}
			piGenGeom->Release();
			piGenGeom=NULL;
		}
	}
	return TRUE;
}

//描述：获取对象的包围盒-------CATBody转成CATCell，再去获取
//输入：CATISpecObject对象
//输出：CATMathBox
//返回：CATMathBox
HRESULT Get3DBoundingBoxOfSinglePart(CATISpecObject_var ispiSpecProd, 
									 CATMathVector imathVecX,
									 CATMathVector imathVecY,
									 CATMathVector imathVecZ,
									 vector<CATMathPoint> &olstBoundingPts)
{
	HRESULT rc=S_OK;
	CATMathBox oMathBox;

	if (ispiSpecProd == NULL_var)
	{
		cout<<"Get3DBoundingBox Failed"<<endl;
		return E_FAIL;
	}
	CATIPrtContainer_var  spRootContainer = GetPrtContainer((CATIProduct_var)ispiSpecProd);
	if( spRootContainer == NULL_var )
	{
		cout <<"# Get Container error !" << endl;
		return E_FAIL;
	}

	CATISpecObject_var spiSpecOnPart = spRootContainer -> GetPart();
	if (spiSpecOnPart == NULL_var)
	{
		cout<<"Get Part Failed!"<<endl;
		return E_FAIL;
	}
	//cout<<"Part Name: "<<CATIAlias_var(spiSpecOnPart)->GetAlias()<<endl;

	//*******************************************************************************************
	//**********CATIDescendants会获取body下包含的布尔运算操作的别的body，从而影响最终的包围盒计算
	CATIDescendants *spDescendants = NULL;
	CATListValCATISpecObject_var  ListOfTriDimObjects;
	rc = spiSpecOnPart->QueryInterface(IID_CATIDescendants,(void**) &spDescendants);
	if( FAILED(rc) || spDescendants == NULL )
	{
		cout << "# Get CATIDescendants error !" << endl;
		return E_FAIL;
	}

	spDescendants -> GetDirectChildren("CATIMechanicalTool",ListOfTriDimObjects);	//CATIMfTriDimResult , CATIMechanicalTool
	//用CATIMfTriDimResult，会获取到实体下的每一步带参操作，如果是类似pocket的去料操作，算包围盒会出错，在CATCreateDirBodyExtremum方法下会出错
	spDescendants->Release();
	spDescendants = NULL;
	//******************************************************************************************

	//***************改用CATIPartRequest，可以只获取所有最高一级的body，直接计算布尔运算以后的结果。
	CATIPartRequest *piPartRequest = NULL;
	CATListValCATBaseUnknown_var lstBodies = NULL;
	rc = spiSpecOnPart->QueryInterface(IID_CATIPartRequest,(void**) &piPartRequest);
	if (FAILED(rc) || piPartRequest == NULL)
	{
		return E_FAIL;
	}
	piPartRequest->GetSolidBodies("",lstBodies);
	piPartRequest->Release();
	piPartRequest = NULL;

	//定义包络面方向
	//CATMathVector mathVectorX(1,0,0);
	//CATMathVector mathVectorY(0,1,0);
	//CATMathVector mathVectorZ(0,0,1);

	if(lstBodies.Size()>0)
	{
		for (int i=1;i<=lstBodies.Size();i++)
		{
			CATISpecObject_var spCurrObj = lstBodies[i];
			if (NULL_var == spCurrObj) continue;

			//先判断当前的Body是否隐藏
			CATBoolean bShow = CheckShowState(spCurrObj);
			if (bShow == FALSE)
			{
				continue;
			}
			else	//当Body没有隐藏，再判断Body内的的solid是否隐藏
			{
				CATIDescendants *piDescendants = NULL;
				CATListValCATISpecObject_var  ListOfChildrenObjects;
				rc = spCurrObj->QueryInterface(IID_CATIDescendants,(void**) &piDescendants);
				if( FAILED(rc) || piDescendants == NULL )
				{
					cout << "# Get CATIDescendants error !" << endl;
					continue;
				}
				piDescendants->GetDirectChildren("CATIMfTriDimResult",ListOfChildrenObjects);
				piDescendants->Release();
				piDescendants = NULL;
				//判断该body下是否是空的，若空，直接返回
				if (ListOfChildrenObjects.Size() == 0)
				{
					continue;
				}
				//再检查子集是否隐藏
				bShow = CheckShowState(ListOfChildrenObjects[1]);
				if (bShow == FALSE)
				{
					continue;
				}
			}

			cout<<i<<" element "<<CATIAlias_var(spCurrObj)->GetAlias()<<endl;

			CATBody_var spBody = GetBodyFromFeature(spCurrObj);
			if(spBody != NULL_var)
			{
				vector<CATMathPoint> lstExtremePts;
				rc = GetBodyBoxFromExtremePt(spBody, (CATIProduct_var)ispiSpecProd, imathVecX,imathVecY,imathVecZ,lstExtremePts);
				if (SUCCEEDED(rc))
				{
					//oMathBox.AddInside(tempBox);
					for (int j=0; j < lstExtremePts.size(); j++)
					{
						olstBoundingPts.push_back(lstExtremePts[j]);
					}
				}
				//tempBox.Dump();
			}
		}
	}
	return rc;
}
HRESULT CenterGraphObject(CATISpecObject_var ispiSpecObject,int iMode,bool IfCenterTreeOnly)
{
	HRESULT rc=E_FAIL;

	//Check the input parameter
	if( !ispiSpecObject || (iMode != 1 && iMode != 2 && iMode != 3) )
		return rc;

	////////////////////////////////////////////////////////////
	// Center graph the special tree
	////////////////////////////////////////////////////////////

	// Retrieves the current window 
	CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
	if ( NULL == pLayout ) return rc;

	CATFrmWindow * pCurrentWindow = pLayout->GetCurrentWindow();
	if ( NULL == pCurrentWindow ) return rc;

	// If it is a CATFrmNavigGraphicWindow, it is possible to
	// retrieve a CATNavigBox pointer
	//
	if ( 1 != pCurrentWindow->IsAKindOf("CATFrmNavigGraphicWindow") ) return rc;

	CATFrmNavigGraphicWindow * pFrmNavigGraphicWindow = 
		(CATFrmNavigGraphicWindow*) pCurrentWindow ;

	CATNavigBox * pNavigBox = NULL ;
	pNavigBox = pFrmNavigGraphicWindow->GetNavigBox();

	if ( NULL == pNavigBox ) return TRUE;

	// Perform center graph action according to the iMode parameter
	CATCafCenterGraph CenterGraphObj;
	switch(iMode) 
	{
	case 1:
		CenterGraphObj.CenterGraph("OnCSO",pNavigBox);
		break;
	case 2:
		CenterGraphObj.CenterGraph("OnHSO",pNavigBox);
		break;
	case 3:
		CenterGraphObj.CenterGraph("OnCtxMenu",pNavigBox);
		break;
	default:
		break;
	}

	////////////////////////////////////////////////////////////
	// Center graph the 3D mode
	////////////////////////////////////////////////////////////
	if (!IfCenterTreeOnly)
	{
		CATI3DGeoVisu_var spi3DGeoVis=ispiSpecObject;
		CATRep *pRep=NULL;
		if( !!spi3DGeoVis )
			pRep = spi3DGeoVis->GiveRep();

		CAT3DRep *pRep3D=NULL;
		if( !!pRep && 1 == pRep->IsAKindOf("CAT3DRep") )
			pRep3D = (CAT3DRep *)pRep;

		CATViewer *pViewer=pFrmNavigGraphicWindow->GetGraphicViewer();

		CAT3DViewer *pViewer3D=NULL;
		if( !!pViewer && 1==pViewer->IsAKindOf("CAT3DViewer") )
			pViewer3D = (CAT3DViewer *)pViewer;

		if( !!pViewer3D && !!pRep3D )
			pViewer3D->ReframeOn(pRep3D->GetBoundingElement());
	}

	return S_OK;
}
HRESULT CenterGraphObject(CATISpecObject_var ispiSpecObject,int iMode,bool IfCenterTreeOnly,float ifRadius)
{
	HRESULT rc=E_FAIL;

	//Check the input parameter
	if( !ispiSpecObject || (iMode != 1 && iMode != 2 && iMode != 3) )
		return rc;

	////////////////////////////////////////////////////////////
	// Center graph the special tree
	////////////////////////////////////////////////////////////

	// Retrieves the current window 
	CATFrmLayout * pLayout = CATFrmLayout::GetCurrentLayout();
	if ( NULL == pLayout ) return rc;

	CATFrmWindow * pCurrentWindow = pLayout->GetCurrentWindow();
	if ( NULL == pCurrentWindow ) return rc;

	// If it is a CATFrmNavigGraphicWindow, it is possible to
	// retrieve a CATNavigBox pointer
	//
	if ( 1 != pCurrentWindow->IsAKindOf("CATFrmNavigGraphicWindow") ) return rc;

	CATFrmNavigGraphicWindow * pFrmNavigGraphicWindow = 
		(CATFrmNavigGraphicWindow*) pCurrentWindow ;

	CATNavigBox * pNavigBox = NULL ;
	pNavigBox = pFrmNavigGraphicWindow->GetNavigBox();

	if ( NULL == pNavigBox ) return TRUE;

	// Perform center graph action according to the iMode parameter
	CATCafCenterGraph CenterGraphObj;
	switch(iMode) 
	{
	case 1:
		CenterGraphObj.CenterGraph("OnCSO",pNavigBox);
		break;
	case 2:
		CenterGraphObj.CenterGraph("OnHSO",pNavigBox);
		break;
	case 3:
		CenterGraphObj.CenterGraph("OnCtxMenu",pNavigBox);
		break;
	default:
		break;
	}

	////////////////////////////////////////////////////////////
	// Center graph the 3D mode
	////////////////////////////////////////////////////////////
	if (!IfCenterTreeOnly)
	{
		CATI3DGeoVisu_var spi3DGeoVis=ispiSpecObject;
		CATRep *pRep=NULL;
		if( !!spi3DGeoVis )
			pRep = spi3DGeoVis->GiveRep();

		CAT3DRep *pRep3D=NULL;
		if( !!pRep && 1 == pRep->IsAKindOf("CAT3DRep") )
			pRep3D = (CAT3DRep *)pRep;

		CATViewer *pViewer=pFrmNavigGraphicWindow->GetGraphicViewer();

		CAT3DViewer *pViewer3D=NULL;
		if( !!pViewer && 1==pViewer->IsAKindOf("CAT3DViewer") )
			pViewer3D = (CAT3DViewer *)pViewer;

		if( !!pViewer3D && !!pRep3D )
		{
			CAT3DBoundingSphere BoundingSphere3D = pRep3D->GetBoundingElement();
			CATMathPointf ptCenter = BoundingSphere3D.GetCenter();
			CAT3DBoundingSphere BoundingSphere3DNew(ptCenter,ifRadius);
			pViewer3D->ReframeOn(BoundingSphere3DNew);
		}

	}

	return S_OK;
}

HRESULT SetColorOnObject(CATISpecObject_var ispiSpecOnObject,unsigned int iRed,unsigned int iGreen,unsigned int iBlue,CATVisGeomType iGeoType)
{
	HRESULT rc=E_FAIL;

	if( !ispiSpecOnObject ) return rc;

	CATVisPropertiesValues AttributeValue;
	AttributeValue.SetColor(iRed,iGreen,iBlue);

	CATIVisProperties *piGraphProp=NULL;
	rc = ispiSpecOnObject->QueryInterface(IID_CATIVisProperties,(void **)&piGraphProp);
	if( FAILED(rc) || !piGraphProp ) return rc;

	// With this type of geometry you can define : show/pick and layer property
	rc = piGraphProp->SetPropertiesAtt(AttributeValue,CATVPColor,iGeoType);

	piGraphProp->Release();  piGraphProp = NULL;

	//Refresh view 3D
	RefreshView3D(ispiSpecOnObject);

	return rc;
}
HRESULT GetColorOnObject(CATISpecObject_var ispiSpecOnObject,unsigned int &oRed,unsigned int &oGreen,unsigned int &oBlue)
{
	HRESULT rc=E_FAIL;

	if( !ispiSpecOnObject ) return rc;

	CATVisPropertiesValues AttributeValue;
	CATIVisProperties *piGraphProp=NULL;
	rc = ispiSpecOnObject->QueryInterface(IID_CATIVisProperties,(void **)&piGraphProp);
	if( FAILED(rc) || !piGraphProp ) return rc;

	rc = piGraphProp->GetPropertiesAtt(AttributeValue,CATVPColor);
	piGraphProp->Release();  piGraphProp = NULL;
	if( FAILED(rc)) return rc;

	rc = AttributeValue.GetColor(oRed,oGreen,oBlue);

	return rc;
}
void RefreshView3D(CATISpecObject_var ispSpec)
{
	if (ispSpec==NULL_var)
		return;

	CATIModelEvents_var spModel = ispSpec;
	CATModify notif(ispSpec);
	if ( !!spModel ) 
	{
		spModel->Dispatch(notif);
	}

	CATIRedrawEvent_var spRedraw = ispSpec;
	if(spRedraw != NULL_var)
	{
		spRedraw->Redraw();
	}

}
//-----------------------------------------------------------------------------------------
//创建拓扑点
//-----------------------------------------------------------------------------------------
HRESULT CreateTopPointByXYZ(CATGeoFactory_var ispiGeoFactory,CATTopData iTopdata,CATMathPoint iMathPoint,CATBody_var &ospBodyPoint)
{
	CATBody*pBodyPoint=NULL;
	pBodyPoint=CATCreateTopPointXYZ(ispiGeoFactory, &iTopdata,iMathPoint.GetX(),iMathPoint.GetY(), iMathPoint.GetZ()) ; 
	if (pBodyPoint==NULL)
		return E_FAIL;

	ospBodyPoint=pBodyPoint;
	return S_OK;

}
//-----------------------------------------------------------------------------------------
//获得最小距离
//-----------------------------------------------------------------------------------------
HRESULT MinDistanceBody(CATGeoFactory_var ispiGeoFactory,
						CATTopData iTopdata,
						CATBody_var ispSoildBody,
						CATBody_var ispPointBody,
						double &olength,
						CATMathPoint &oMathPoint1,
						CATMathPoint &oMathPoint2,
						CATCell_var& ospSupportCell1,
						CATCell_var& ospSupportCell2,
						CATBoolean &oissucess)							
{
	CATTry 
	{
		CATDistanceMinBodyBody*piMinDistanceBody=NULL;
		piMinDistanceBody= CATCreateDistanceMinTopo(ispiGeoFactory, &iTopdata, ispSoildBody,ispPointBody,ADVANCED) ;
		if (piMinDistanceBody==NULL)
		{
			cout<<"CATCGMCreateDistanceBodyBodyOp Failed"<<endl;
			return E_FAIL;
		}

		piMinDistanceBody->SetPointComputationMode(TRUE);
		piMinDistanceBody->Run();

		CATPoint* oPoint1=NULL;
		CATPoint* oPoint2=NULL;
		piMinDistanceBody->GetPoints(oPoint1, oPoint2); 
		if (oPoint1!=NULL&&oPoint2!=NULL)
		{
			olength=piMinDistanceBody->GetDistance();

			CATCell*  opSupportCell1=NULL; 
			CATCell*  opSupportCell2=NULL;
			piMinDistanceBody->GetSupportCells(opSupportCell1, opSupportCell2); 

			ospSupportCell1=opSupportCell1;
			ospSupportCell2=opSupportCell2;

			if (ospSupportCell1!=NULL_var&&ospSupportCell2!=NULL_var)
			{
				int iDimension1=ospSupportCell1->GetDimension( );
				int iDimension2=ospSupportCell2->GetDimension( );
			}

			oPoint1->GetMathPoint(oMathPoint1);
			oPoint2->GetMathPoint(oMathPoint2);
			oissucess=TRUE;
			//cout<<"MinDistance Length:"<<olength<<endl;
		}

		if (piMinDistanceBody!=NULL)
		{
			delete piMinDistanceBody;
			piMinDistanceBody = NULL;
		}

	}
	CATCatch(CATError , pError)
	{
		return E_FAIL;
	}
	CATEndTry

		return S_OK;
}
//-----------------------------------------------------------------------------------------
//获得最小距离
//-----------------------------------------------------------------------------------------
HRESULT MinDistanceCell(CATGeoFactory_var ispiGeoFactory,
						CATTopData iTopdata,
						CATCell_var ispCell1,
						CATCell_var ispCell2,
						double &olength,
						CATMathPoint &oMathPoint1,
						CATMathPoint &oMathPoint2,
						CATBoolean &oissucess)							
{
	CATTry 
	{
		CATDistanceMinBodyBody*piMinDistanceBody=NULL;
		piMinDistanceBody= CATCreateDistanceMinTopo(ispiGeoFactory, &iTopdata, ispCell1,ispCell2,ADVANCED) ;
		if (piMinDistanceBody==NULL)
		{
			cout<<"CATCGMCreateDistanceBodyBodyOp Failed"<<endl;
			return E_FAIL;
		}

		piMinDistanceBody->SetPointComputationMode(TRUE);
		piMinDistanceBody->Run();

		CATPoint* oPoint1=NULL;
		CATPoint* oPoint2=NULL;
		piMinDistanceBody->GetPoints(oPoint1, oPoint2); 
		if (oPoint1!=NULL&&oPoint2!=NULL)
		{
			oPoint1->GetMathPoint(oMathPoint1);
			oPoint2->GetMathPoint(oMathPoint2);
			olength=piMinDistanceBody->GetDistance();
			oissucess=TRUE;
			//cout<<"MinDistance Length:"<<olength<<endl;

			if (piMinDistanceBody!=NULL)
			{
				delete piMinDistanceBody;
				piMinDistanceBody = NULL;
			}

			//if (oPoint1!=NULL)
			//{
			//	oPoint1->Release();
			//	oPoint1 = NULL ;
			//}

			//if (oPoint2!=NULL)
			//{
			//	oPoint2->Release();
			//	oPoint2 = NULL ;
			//}
		}
		else
		{
			return E_FAIL;
		}

	}
	CATCatch(CATError , pError)
	{
		return E_FAIL;
	}
	CATEndTry

		return S_OK;
}
HRESULT GetLstWeldPart(CATIProduct_var ispiProdNode,CATLISTV(CATISpecObject_var) &lstSpecWPParts)
{
	if(ispiProdNode==NULL_var)
	{
		return E_FAIL;
	}

	//先获取节点下所有part
	CATLISTV(CATISpecObject_var) lstSpecParts;
	GetAllPartsOfPrd(ispiProdNode,lstSpecParts);
	if (lstSpecParts.Size()==0)
	{
		if (CheckWPFile(ispiProdNode))
		{
			lstSpecWPParts.Append(ispiProdNode);
		}
	}

	//取零件号末尾为关键字"WP"的part
	//CATLISTV(CATISpecObject_var) lstSpecWPParts;
	for (int i=1;i<=lstSpecParts.Size();i++)
	{
		CATIProduct_var spiProd = lstSpecParts[i];
		if (spiProd==NULL_var)
			continue;

		if (CheckWPFile(spiProd))
		{
			lstSpecWPParts.Append(lstSpecParts[i]);
		}
	}

	if (lstSpecWPParts.Size()==0)
	{
		return E_FAIL;
	}

	return S_OK;
}
CATBoolean GetPartList(CATIProduct_var spFatherProduct,
					   CATLISTV(CATISpecObject_var) &ListOfObject,
					   CATListValCATUnicodeString &LstPartNumber,
					   CATListValCATUnicodeString &LstInstanceName)
{
	if (spFatherProduct==NULL_var)
		return FALSE;

	ListOfObject.RemoveAll();
	LstPartNumber.RemoveAll();
	LstInstanceName.RemoveAll();

	//获取焊点零件父级节点下的part
	//CATLISTV(CATISpecObject_var) ListOfObject;
	//CATListValCATUnicodeString LstPartNumber;
	//CATListValCATUnicodeString LstInstanceName;

	CATLISTV(CATISpecObject_var) tempListOfObject;
	GetAllPartsOfPrd( spFatherProduct,tempListOfObject );
	if(tempListOfObject.Size()==0)
	{
		cout<<"获取连接件失败"<<endl;
		return FALSE;
	}

	//获取part的名称
	CATUnicodeString strPartNumber;
	CATUnicodeString strInstanceName;
	for(int i=1;i<=tempListOfObject.Size();i++)
	{
		CATIProduct_var spProduct=tempListOfObject[i];
		if (spProduct==NULL_var)
			continue;

		if (CheckWPFile(spProduct))
			continue;

		strPartNumber=spProduct->GetPartNumber( );
		spProduct->GetPrdInstanceName( strInstanceName);

		LstPartNumber.Append(strPartNumber);
		LstInstanceName.Append(strInstanceName);
		ListOfObject.Append(spProduct);
	}

	return TRUE;
}
//*****************************
//*****检查是否是焊点文件********
//*****************************
CATBoolean CheckWPFile(CATIProduct_var ispiPrd)
{
	if (ispiPrd==NULL_var)
		return FALSE;

	//判断零件号是否含WP
	CATUnicodeString strDefinition = ispiPrd->GetPartNumber();
	strDefinition.ToUpper();
	if (strDefinition.SearchSubString("WP")!=-1)
		return TRUE;

	//先判断Part_Type
	CATICkeParm_var spCkePara=NULL_var;
	CATUnicodeString strProperty;
	spCkePara=GetPrdParameter(false,ispiPrd,"Part_Type");
	if (spCkePara==NULL_var)
	{
		spCkePara=GetPrdParameter(false,ispiPrd,"PART_TYPE");
		if (spCkePara==NULL_var)
		{
			if (strDefinition.SearchSubString("WP")==-1)
				return FALSE;
		}
		else
		{
			strProperty = spCkePara->Value()->AsString();
			strProperty.ToUpper();
			if (strProperty!="JOINING")
				return FALSE;
		}
	}
	else
	{
		strProperty = spCkePara->Value()->AsString();
		strProperty.ToUpper();
		if (strProperty!="JOINING")
			return FALSE;
	}

	return TRUE;
}
CATICkeParm_var GetPrdParameter(bool isCreate,CATIProduct_var spPrd,CATUnicodeString strPropertiesName)
{
	//cout<<"GetPrdParameter"<<endl;

	CATIAlias_var spAlias=NULL_var;

	if (spPrd==NULL_var)
	{
		cout<<"GetProduct Failed"<<endl;
		return NULL_var;
	}

	CATIPrdProperties_var spProperties = spPrd;
	if (spProperties==NULL_var)
	{
		cout<<"GetProduct CATIPrdProperties Failed"<<endl;
		return NULL_var;
	}

	CATIParmPublisher *pPublisher = NULL;
	spProperties->GetUserProperties(pPublisher,true);
	if (pPublisher==NULL)
	{
		//cout<<"GetUserProperties Failed"<<endl;
		return NULL_var;
	}

	CATListValCATISpecObject_var lstChildren;
	pPublisher->GetAllChildren("CATICkeParm",lstChildren);

	//CATUnicodeString strName = "SharePointProjectID";
	for(int ii=1;ii<=lstChildren.Size();ii++)
	{
		spAlias = lstChildren[ii];
		if (spAlias==NULL_var)
			continue;

		CATUnicodeString strChildName = spAlias->GetAlias();
		//cout<<"CATICkeParm Name==="<<strChildName<<endl;

		int iIndex =  strChildName.SearchSubString("\\",0,CATUnicodeString::CATSearchModeBackward);
		if(iIndex>=0)
			strChildName = strChildName.SubString(iIndex+1,strChildName.GetLengthInChar()-iIndex-1);

		if(strChildName==strPropertiesName)
		{
			return lstChildren[ii];
		}
	}

	if(isCreate)
	{
		CATICkeParmFactory_var spFac = pPublisher->GetContainer();
		CATICkeParm_var spPar = spFac->CreateString(strPropertiesName,"");
		pPublisher->Append(spPar);
		return spPar;
	}

	return NULL_var;
}
CATVolume_var GetBodyVolume(CATBody_var spBody)
{
	CATLISTP(CATCell) spLstVolume;
	spBody->GetAllCells(spLstVolume,3);
	int nSize = spLstVolume.Size();

	CATVolume_var spVolume = NULL_var;
	if (nSize)
	{
		spVolume = spLstVolume[1];
	}

	return spVolume;
}
int TestPtInVol(CATGeoFactory* piGeoFactory, CATTopData* pTopdata, CATBody_var spiBody, CATMathPoint ptIn)
{
	int iRet = -1;
	CATVolume_var spBodyVolume = GetBodyVolume(spiBody);
	CATTry
	{
		CATPositionPtVolOperator* pPosPtVolOpe = CATCreatePositionPtVolOperator(piGeoFactory, pTopdata, ptIn, spBodyVolume);
		if (pPosPtVolOpe == NULL) return iRet;
		pPosPtVolOpe->Run();
		if ( CATLocationOuter == pPosPtVolOpe->GetLocationResult()) 
		{
			iRet = 0;//out
			//cout<<"point out volume"<<endl;
		}
		if ( CATLocationInner == pPosPtVolOpe->GetLocationResult()) 
		{
			iRet = 1;//in
			//cout<<"point in volume"<<endl;
		}
		if ( CATLocationFull == pPosPtVolOpe->GetLocationResult()) 
		{
			iRet = 2;//on
			//cout<<"point on volume"<<endl;
		}

		delete pPosPtVolOpe;  
		pPosPtVolOpe = NULL;
	}
	CATCatch(CATError,perror)
	{
		iRet=-1;
	}
	CATEndTry;
	return iRet;
}
HRESULT GetProjectPoint(CATGeoFactory_var ispiGeoFactory,
						CATTopData iTopdata,
						CATBody_var ispBodySupport,
						CATBody_var ispBodyToProject,
						double &olength,
						CATMathPoint &oMathPoint1,
						CATMathPoint &oMathPoint2,
						CATBoolean &oissucess)							
{
	CATTry 
	{
		CATMathDirection*  iDirection =(CATMathDirection *) 0  ;
		CATHybProject*piTopProjectBody= CATCreateTopProject(ispiGeoFactory, &iTopdata, ispBodyToProject,ispBodySupport,iDirection) ;
		if (piTopProjectBody==NULL)
		{
			cout<<"CATCreateTopProject Failed"<<endl;
			return E_FAIL;
		}

		piTopProjectBody->Run();

		CATBody*ipBody=NULL;
		ipBody=piTopProjectBody->GetResult();
		if (ipBody==NULL)
		{
			cout<<"CATCreateTopProject Failed"<<endl;
			return E_FAIL;
		}

		CATLISTV(CATMathPoint) LstMathPoint1;
		GetMathPointFromBody(ipBody,LstMathPoint1);
		if (LstMathPoint1.Size()==0)
		{
			cout<<"GetMathPointFromBody Failed"<<endl;
			return E_FAIL;
		}

		cout<<"project point size:"<<LstMathPoint1.Size()<<endl;

		CATLISTV(CATMathPoint) LstMathPoint2;
		GetMathPointFromBody(ispBodyToProject,LstMathPoint2);
		if (LstMathPoint2.Size()==0)
		{
			cout<<"GetMathPointFromBody Failed"<<endl;
			return E_FAIL;
		}

		oMathPoint2=LstMathPoint2[1];

		//获取最近的一个投影点
		double mindis=100000;
		for (int i=1;i<=LstMathPoint1.Size();i++)
		{
			double dis=LstMathPoint1[i].DistanceTo(oMathPoint2);
			if (dis<mindis)
			{
				oMathPoint1=LstMathPoint1[i];
				mindis=dis;
			}
		}

		olength=oMathPoint1.DistanceTo(oMathPoint2);

		oissucess=TRUE;

		if (piTopProjectBody!=NULL)
		{
			delete piTopProjectBody;
			piTopProjectBody = NULL;
		}
	}
	CATCatch(CATError , pError)
	{
		return E_FAIL;
	}
	CATEndTry

		return S_OK;
}
HRESULT GetConnectionPartSurfaceNormal(CATISpecObject_var spWeldPoint,
									   CATISpecObject_var spWeldPart,
									   CATISpecObject_var spConnectionPart,
									   CATBaseUnknown_var &ospMainObject,
									   CATFace_var &ospMainFace,
									   CATMathPoint &iMathPointOnSurface,
									   CATMathVector  &iMathVectorSurface)
{
	if (spWeldPoint==NULL_var||spWeldPart==NULL_var||spConnectionPart==NULL_var)
	{
		return E_FAIL;
	}

	HRESULT rc=E_FAIL;

	CATIAlias_var spAlias=spConnectionPart;
	//cout<<"Calculate Connection Part:"<<spAlias->GetAlias()<<endl;

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATIMeasurablePoint_var spMeaPoint=spWeldPoint;

	CATMathPoint  iMathWeldPoint;
	spMeaPoint->GetPoint( iMathWeldPoint);
	//cout<<"point in weld part:"<<endl;
	//iMathWeldPoint.Dump();

	CATMathTransformation transMatrix=GetMatrixTransformation(spWeldPart, spConnectionPart);

	//CATMathTransformation transAbs=GetAbsTransformation(spConnectionPart);

	CATMathPoint iMathConnectionPoint;
	iMathConnectionPoint=transMatrix*iMathWeldPoint;
	//cout<<"point in conncetion part:"<<endl;
	//iMathConnectionPoint.Dump();

	CATIPrtContainer_var spiCont=NULL_var;
	CATISpecObject_var spPrtPart=NULL_var;
	GetPrtContFromPrd(spConnectionPart, spiCont,spPrtPart);
	if (spiCont==NULL_var||spPrtPart==NULL_var)
	{
		cout<<"GetPrtContFromPrd Failed"<<endl;
		return E_FAIL;
	}

	//获取所有实体
	CATIPartRequest_var spPartRequest = spPrtPart ;
	if ( !spPartRequest )  
		return E_FAIL;

	//获得所有实体
	CATListValCATBaseUnknown_var listSolidyBodies;
	spPartRequest->GetSolidBodies("",listSolidyBodies);
	if (listSolidyBodies.Size()==0)
		return E_FAIL;

	CATICGMContainer_var  spiGeoCont = NULL_var;
	spiGeoCont = spiCont->GetGeometricContainer();
	if (spiGeoCont == NULL_var) 
	{
		cout<<"Get Connector GeometricalContainer Failed"<<endl;
		return E_FAIL;
	}

	CATGeoFactory_var spiGeoFactory=spiGeoCont;
	if (spiGeoFactory==NULL_var)
	{
		cout<<"Get CATGeoFactory Failed"<<endl;
		return E_FAIL;
	}

	CATBody_var spPointBody=NULL_var;
	CreateTopPointByXYZ(spiGeoFactory,Topdata,iMathConnectionPoint,spPointBody);
	if (spPointBody==NULL_var)
	{
		cout<<"CreateTopPointByXYZ Failed"<<endl;
		return E_FAIL;
	}

	//获取有效实体
	double omindistance= 10000;//
	ospMainObject=NULL_var;
	CATBody_var spMainBody=NULL_var;
	CATCell_var spSupportCell1=NULL_var;
	CATCell_var spSupportCell2=NULL_var;
	for(int j=1;j<=listSolidyBodies.Size();j++)
	{
		//判断是否显示隐藏
		if (CheckShowState(listSolidyBodies[j])==FALSE)//隐藏
			continue;

		CATBody_var spBody  = GetBodyFromFeature(listSolidyBodies[j]);
		if (spBody==NULL_var)
			continue;

		//获取实体是否隐藏
		CATIBodyRequest_var spBodyRequest=listSolidyBodies[j];
		if (spBodyRequest==NULL_var)
			continue;

		CATListValCATBaseUnknown_var  oResults;
		spBodyRequest->GetResults( "", oResults);
		if (oResults.Size()==0)
			continue;

		for (int k=1;k<=oResults.Size();k++)
		{
			if (CheckShowState(oResults[k])==FALSE)//隐藏
				continue;

			CATBody_var spBody  = GetBodyFromFeature(oResults[k]);
			if (spBody==NULL_var)
				continue;

			int iRet=TestPtInVol(spiGeoFactory,&Topdata, spBody, iMathConnectionPoint);//判断点的位置
			if(iRet==1)
			{
				//点在体内，先投影获得点
				double length=0;
				CATMathPoint MathPoint1;
				CATMathPoint MathPoint2;
				CATBoolean issucess=FALSE;
				GetProjectPoint(spiGeoFactory,Topdata, spBody, spPointBody, length, MathPoint1,  MathPoint2, issucess);
				cout<<"point distance:"<<iMathConnectionPoint.DistanceTo(MathPoint1)<<endl;
				iMathConnectionPoint=MathPoint1;

				CreateTopPointByXYZ(spiGeoFactory,Topdata,iMathConnectionPoint,spPointBody);
			}

			CATBoolean issucess=FALSE;
			double dbdistance=10000;
			CATMathPoint oMathPoint1;
			CATMathPoint oMathPoint2;
			CATCell_var spCell1=NULL_var;
			CATCell_var spCell2=NULL_var;
			MinDistanceBody(spiGeoFactory,Topdata,spBody,spPointBody,dbdistance,oMathPoint1,oMathPoint2,spCell1,spCell2,issucess);
			if (issucess==FALSE)
			{
				//点在体内，先投影获得点
				double length=0;
				CATMathPoint MathPoint1;
				CATMathPoint MathPoint2;
				CATBoolean issucess=FALSE;
				GetProjectPoint(spiGeoFactory,Topdata, spBody, spPointBody, length, MathPoint1,  MathPoint2, issucess);
				cout<<"point distance:"<<iMathConnectionPoint.DistanceTo(MathPoint1)<<endl;
				iMathConnectionPoint=MathPoint1;

				CreateTopPointByXYZ(spiGeoFactory,Topdata,iMathConnectionPoint,spPointBody);

				MinDistanceBody(spiGeoFactory,Topdata,spBody,spPointBody,dbdistance,oMathPoint1,oMathPoint2,spCell1,spCell2,issucess);

				//GetMinDistance( spWeldPoint, oResults[k], oMathPoint1, oMathPoint2, dbdistance, issucess );

				//GetDistance(spWeldPoint,spWeldPart,oResults[k],spConnectionPart,oMathPoint1,oMathPoint2,dbdistance);
			}

			if (dbdistance<omindistance)
			{
				//cout<<"distance:"<<idistance<<endl;
				omindistance=dbdistance;
				ospMainObject=oResults[k];
				spMainBody=spBody;
				spSupportCell1=spCell1;
				spSupportCell2=spCell2;
			}
		}

	}

	if (ospMainObject==NULL_var)
	{
		cout<<"get nearest solid failed"<<endl;
		return E_FAIL;
	}

	CATLISTP(CATCell) LISTPointCell; 
	spPointBody->GetAllCells(LISTPointCell, 0 ); 
	if (LISTPointCell.Size()==0) return E_FAIL;

	CATCell_var spPointCell=LISTPointCell[1];

	//获取离实体最近的面
	CATLISTP(CATCell) ListFaceCells; 
	spMainBody->GetAllCells(ListFaceCells, 2 ); 
	if (ListFaceCells.Size()==0) return E_FAIL;

	ospMainFace=NULL_var;

	if (spSupportCell1!=NULL_var)
	{
		int iDimension=spSupportCell1->GetDimension( );
		//cout<<"iDimension:"<<iDimension<<endl;
		if (iDimension==2)
		{
			ospMainFace = spSupportCell1;
			if(ospMainFace == NULL_var) 
			{
				cout<<"CATFace_var is NULL_var."<<endl;
				return E_FAIL;
			}

			CATSurface_var spSurface = ospMainFace->GetSurface();
			if(spSurface == NULL_var)
				return E_FAIL;

			CATBody_var spBodySurf=NULL_var;
			ConvertFaceToBody(spiGeoFactory,ospMainFace,spBodySurf);
			if(spBodySurf==NULL_var)
			{
				cout<<"ConvertFaceToBody failed"<<endl;
				return E_FAIL;
			}

			GetNormalOnFace(spiGeoFactory, spBodySurf, spPointBody, spSurface, iMathPointOnSurface, iMathVectorSurface);

			//GetNormaleOnSurf ( spiGeoFactory, spBodySurf,iMathConnectionPoint , iMathPointOnSurface,iMathVectorSurface);
			
			if (spBodySurf!=NULL_var)
			{
				spiGeoFactory->Remove(spBodySurf);
				spBodySurf=NULL_var;
			}
		}
		else if (iDimension==1)
		{
			//通过线找到面
			CATEdge_var spEdge = spSupportCell1;
			if (spEdge!=NULL_var)
			{
				CATLISTP(CATCell) ListFaceCells;
				CATListOfLong lstNumberOfDomains;
				rc = spEdge->GetBorderedFaces(spMainBody,ListFaceCells,lstNumberOfDomains);
				if (ListFaceCells.Size()<=0)
				{
					spMainBody->GetAllCells(ListFaceCells, 2 ); 
					if (ListFaceCells.Size()==0) return E_FAIL;

					//获取离实体最近的面
					GetNormalInFaceList(spiGeoFactory, ListFaceCells,  spPointCell, spPointBody, ospMainObject,  iMathConnectionPoint,  TRUE,ospMainFace,  iMathPointOnSurface,  iMathVectorSurface);

				}
				else
				{
					//获取离实体最近的面
					GetNormalInFaceList(spiGeoFactory, ListFaceCells,  spPointCell, spPointBody, ospMainObject,  iMathConnectionPoint,  FALSE,ospMainFace,  iMathPointOnSurface,  iMathVectorSurface);

				}


			}

		}
		else
		{
			//获取离实体最近的面
			CATLISTP(CATCell) ListFaceCells; 
			spMainBody->GetAllCells(ListFaceCells, 2 ); 
			if (ListFaceCells.Size()==0) return E_FAIL;

			GetNormalInFaceList(spiGeoFactory, ListFaceCells,  spPointCell, spPointBody, ospMainObject,  iMathConnectionPoint,  TRUE, ospMainFace,  iMathPointOnSurface,  iMathVectorSurface);

		}

	}
	else
	{
		//获取离实体最近的面
		CATLISTP(CATCell) ListFaceCells; 
		spMainBody->GetAllCells(ListFaceCells, 2 ); 
		if (ListFaceCells.Size()==0) return E_FAIL;

		GetNormalInFaceList(spiGeoFactory, ListFaceCells,  spPointCell, spPointBody, ospMainObject,  iMathConnectionPoint, TRUE, ospMainFace,  iMathPointOnSurface,  iMathVectorSurface);

	}

	if (spPointBody!=NULL_var)
	{
		spiGeoFactory->Remove(spPointBody);
		spPointBody=NULL_var;
	}

	return S_OK;
}
HRESULT GetNormalInFaceList(CATGeoFactory *piGeoFactory,
							CATLISTP(CATCell) ListFaceCells,
							CATCell_var spPointCell,
							CATBody_var spPointBody,
							CATBaseUnknown_var spObject,
							CATMathPoint iMathConnectionPoint,
							CATBoolean isNeed,
							CATFace_var &ospFace,
							CATMathPoint &oMathPointOnSurface,
							CATMathVector  &oMathVectorSurface)
{
	//cout<<"GetNormalInFaceList"<<endl;

	double dbmindistance=DBL_MAX;

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATLISTP(CATCell) ListResultFaceCells;

	if (isNeed==TRUE)
	{
		CATCell_var spResultCell=NULL_var;
		CATFace_var spResultFace=NULL_var;

		for (int i=1;i<=ListFaceCells.Size();i++)
		{
			CATCell_var spCell = ListFaceCells[i]; 
			if (spCell==NULL_var)
				continue;

			CATFace_var spFace = ListFaceCells[i];
			if (spFace==NULL_var)
				continue;

			CATBoolean issucess=FALSE;
			double distanceValue=0;
			CATMathPoint iMathPointOnSurafce;
			CATMathPoint iMathPointOnPoint;
			MinDistanceCell(piGeoFactory,Topdata,spCell,spPointCell,distanceValue,iMathPointOnSurafce,iMathPointOnPoint,issucess);
			if (issucess==FALSE)
			{
				continue;
			}

			if (distanceValue<0.001)
			{
				ListResultFaceCells.Append(spCell);
			}

			if (distanceValue<dbmindistance)
			{
				dbmindistance=distanceValue;
				spResultFace = spFace;
				spResultCell=spCell;
			}
		}

		if (spResultFace==NULL_var||spResultCell==NULL_var)
		{
			return E_FAIL;
		}

		if (ListResultFaceCells.Size()==0)
			ListResultFaceCells.Append(spResultCell);

	}
	else
	{
		ListResultFaceCells=ListFaceCells;
	}

	double dbminThickness=DBL_MAX;

	for (int i=1;i<=ListResultFaceCells.Size();i++)
	{
		CATFace_var spFace = ListResultFaceCells[i];
		if (spFace==NULL_var)
			continue;

		CATSurface_var spSurface = spFace->GetSurface();
		if(spSurface == NULL_var)
			continue;

		CATBody_var spBodySurf=NULL_var;
		ConvertFaceToBody(piGeoFactory,spFace,spBodySurf);
		if(spBodySurf == NULL_var) 
			continue;

		//获取面的法向
		CATMathPoint iMathPoint;
		CATMathVector  iMathVector;
		GetNormalOnFace(piGeoFactory, spBodySurf, spPointBody, spSurface, iMathPoint, iMathVector);

		//GetNormaleOnSurf ( piGeoFactory, spBodySurf,iMathConnectionPoint , iMathPoint,iMathVector);

		double dbThickness=DBL_MAX;
		GetConnectionPartThickness( spObject,iMathPoint,iMathVector,dbThickness);
		if (dbThickness<dbminThickness)
		{
			dbminThickness=dbThickness;
			ospFace=spFace;
			oMathPointOnSurface=iMathPoint;
			oMathVectorSurface=iMathVector;
		}
	}

	return S_OK;
}
HRESULT GetConnectionPartThickness(CATBaseUnknown_var spObject,
								   CATMathPoint iMathPointOnSurface,
								   CATMathVector iMathVectorSurface,
								   double &odbThickness)
{
	if (spObject==NULL_var)
	{
		return E_FAIL;
	}

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATBody_var spBody=GetBodyFromFeature(spObject);
	if (spObject==NULL_var)
	{
		cout<<"GetBodyFromFeature failed"<<endl;
		return E_FAIL;
	}

	CATGeoFactory_var spiGeoFactory=spBody->GetContainer(TRUE, CatCGMExplicit);
	if (spiGeoFactory==NULL_var)
	{
		cout<<"GetContainer Failed"<<endl;
		return E_FAIL;
	}

	//实体与面的法向相交
	CATMathPoint oThicknessMathPoint1;
	CATMathPoint oThicknessMathPoint2;
	GetConnectorThickness( spiGeoFactory,Topdata,iMathPointOnSurface,iMathVectorSurface,spBody,odbThickness, oThicknessMathPoint1,oThicknessMathPoint2);

	return S_OK;

}
void ConvertFaceToBody(CATGeoFactory *iFactory,CATFace *ipFace,CATBody_var &ospBody)
{
	ospBody=NULL_var;

	if(iFactory==NULL) return;

	CATBody*piBody=iFactory->CreateBody();
	if (piBody==NULL) return;

	CATShell *pShell=piBody->CreateShell(CATLocationOuter);
	if (pShell==NULL)	
	{
		cout<<"CreateShell Failed"<<endl;
		return;
	}

	pShell->AddCell((CATCell*)ipFace);
	piBody->AddDomain(pShell);
	piBody->Completed();

	ospBody=piBody;
}

// ---------------------------------------------------------------------------
// GetNormalOnSurf  : Gets the normale on a surface on the nearest point to Input Pt 
// ---------------------------------------------------------------------------
HRESULT GetNearestSurf(CATGeoFactory_var spiGeoFactory,
					   CATTopData Topdata,
					   CATBody_var spSolidBody,
					   CATCell_var spPointCell,
					   CATFace_var &ospFace,
					   CATSurface_var &ospSurface)
{
	if (spSolidBody==NULL_var||spPointCell==NULL_var||spiGeoFactory==NULL_var)
	{
		return E_FAIL;
	}

	HRESULT rc=E_FAIL;

	//获取离实体最近的面
	CATLISTP(CATCell) ListFaceCells; 
	spSolidBody->GetAllCells(ListFaceCells, 2 ); 
	if (ListFaceCells.Size()==0) return E_FAIL;

	double omindistance=1000000;
	//CATFace_var spResultFace=NULL_var;
	//CATSurface_var spResultSurface = NULL_var;

	for( int i = 1; i <= ListFaceCells.Size(); i++ )
	{ 
		CATCell_var spCell = ListFaceCells[i]; 
		if (spCell==NULL_var)
		{
			cout<<"CATCell is NULL_var"<<endl;
			continue;
		}

		CATFace_var spFace = spCell;
		if(spFace == NULL_var) 
		{
			cout<<"CATFace_var is NULL_var."<<endl;
			continue;
		}

		CATSurface_var spSurface = spFace->GetSurface();
		if(spSurface == NULL_var)
			continue;

		CATBoolean issucess=FALSE;
		double distanceValue=0;
		CATMathPoint iMathPointOnSurafce;
		CATMathPoint iMathPointOnPoint;
		MinDistanceCell(spiGeoFactory,Topdata,spCell,spPointCell,distanceValue,iMathPointOnSurafce,iMathPointOnPoint,issucess);
		if (issucess==FALSE)
		{
			continue;
		}

		if (distanceValue<omindistance)
		{
			omindistance=distanceValue;
			ospFace = spFace;
			ospSurface=spSurface;
		}

	}

	return S_OK;
}
HRESULT GetNormalOnFace(CATGeoFactory_var ispiGeoFactory,
						CATBody_var spFaceBody,
						CATBody_var spPointBody,
						CATSurface_var spSurface,
						CATMathPoint &oMathPointOnSurafce,
						CATMathVector  &oMathVectorOnSurafce)
{
	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	//获取起点距离面的最小距离
	CATBoolean issucess=FALSE;
	double distanceValue=0;
	CATCell_var spSupportCell1=NULL_var;
	CATCell_var spSupportCell2=NULL_var;
	CATMathPoint iMinDisMathPointOnPoint;
	MinDistanceBody(ispiGeoFactory,Topdata,spFaceBody,spPointBody,distanceValue,oMathPointOnSurafce,iMinDisMathPointOnPoint,spSupportCell1,spSupportCell2,issucess);
	if (issucess==FALSE)
	{
		cout<<"GetSurfaceInforFromSolid MinDistance Failed"<<endl;
		return E_FAIL;
	}

	//获取起点在面的方向
	CATDistanceMinPtSur * pDistMinPtSurOpe =CATCreateDistanceMin(ispiGeoFactory,pConfig,oMathPointOnSurafce, spSurface, TRUE,ADVANCED ); 
	if (pDistMinPtSurOpe==NULL)
	{
		cout<<"CATCreateDistanceMin Failed:"<<endl;
		return E_FAIL;
	}

	pDistMinPtSurOpe->Run();

	CATSurParam Param;
	Param=pDistMinPtSurOpe->GetSurParam( );

	CATMathDirection ioNormalVect;
	spSurface->EvalNormal(Param,  ioNormalVect);

	oMathVectorOnSurafce=ioNormalVect;

	if (pDistMinPtSurOpe!=NULL)
	{
		delete pDistMinPtSurOpe;
		pDistMinPtSurOpe=NULL;
	}

	return S_OK;
}
HRESULT GetNormaleOnSurf ( CATGeoFactory * piGeomFactory, CATBody * pBodySurf,CATMathPoint& pRefSurfacePnt , CATMathPoint& oPt,CATMathVector& oNormalVector)
{
	HRESULT rc = CATReturnFailure; 
	double MinDist                  = 1.0e35;
	CATBoolean    iSearchOnBoundary = TRUE;
	CATSkillValue iProjectMode  = ADVANCED;
	CATOrientation       OrientationBody;
	CATOrientation       OrientationSur;

	if (!pBodySurf) return CATReturnFailure;

	CATLISTP(CATCell)	SurfList;
	pBodySurf->GetAllCells(SurfList, 2);

	int Dimension   = 2 ; 
	CATOrientation Ori;

	CATSoftwareConfiguration * pLocalConfig = new CATSoftwareConfiguration();

	CATDomain_var Domain=NULL_var;
	Domain = pBodySurf -> GetDomain(1);
	if (!!Domain )
	{
		CATLISTP(CATCell)	SurfList;
		pBodySurf->GetAllCells(SurfList, Dimension);
		// cout << "(GetNormaleOnSurf)- Surf Liste =   " << SurfList.Size() << endl;
		for(int ii=1; ii<=SurfList.Size(); ii++)
		{
			CATLONG32 iRank = Domain -> GetCellRank(SurfList[ii], &Ori);

#ifdef DEBUG_TOPOLOGY 
			cout << "(GetNormaleOnSurf)- Surf [" << ii << " ] " << endl;
			cout << "(GetNormaleOnSurf)- Rank  " << iRank << " / Orientation = " << Ori << endl;
#endif 
			CATFace *pSurfFace = (CATFace*)(SurfList[ii]);
			if (pSurfFace)
			{
				CATSurface *pSurface  = pSurfFace->GetSurface(&OrientationSur);
				if (pSurface)
				{
					OrientationBody = OrientationSur * Ori ; 
#ifdef DEBUG_TOPOLOGY 
					cout << "(GetNormaleOnSurf)- Ori          " << Ori             << endl;    
					cout << "(GetNormaleOnSurf)- Orientation  " << OrientationSur  << endl;    
					cout << "(GetNormaleOnSurf)- Orient Body  " << OrientationBody  << endl;
#endif 
					CATSurParam SurfParm;
					CATDistanceMinPtSur *pProjectionOpe = CATCreateDistanceMin(piGeomFactory,pLocalConfig ,
						(const CATMathPoint)pRefSurfacePnt,
						(const CATSurface*)pSurface,
						iSearchOnBoundary,
						iProjectMode);

					if(pProjectionOpe)
					{
						pProjectionOpe->Run();

						SurfParm    = pProjectionOpe->GetSurParam();
						double SurfDist = pProjectionOpe->GetDistance();

						CATMathPoint iTempMathPoint;
						CATBoolean issucess=TRUE;
						CATTry 
						{
							iTempMathPoint=pSurface->EvalPoint(SurfParm);
						}
						CATCatch(CATError , pError)
						{
							issucess=FALSE;
						}
						CATEndTry

						CATPointOnSurface *pOnSurfacePnt = pProjectionOpe->GetPointOnSurface();
						CATPoint *pOnSurfPnt = (CATPoint*)pOnSurfacePnt;
						if (pOnSurfPnt)
						{
							CATMathPoint pMathPntOnSurface = pOnSurfPnt->GetMathPoint();

							cout<<iTempMathPoint.DistanceTo(pMathPntOnSurface)<<endl;

							if (issucess)
							{
								pMathPntOnSurface=iTempMathPoint;
							}

							CATMathDirection SurfNorDir;
							pSurface ->EvalNormal(SurfParm, SurfNorDir);
							CATMathVector FaceNorVec = 
								(OrientationBody==CATOrientationPositive)?SurfNorDir:-SurfNorDir;;
							// (CATMathVector)SurfNorDir * OrientationSur
							if(SurfDist  < MinDist) 
							{
#ifdef DEBUG_TOPOLOGY 
								cout << "(GetNormaleOnSurf) dist["<<ii<<"]  =  " << SurfDist << endl;
#endif 
								MinDist       = SurfDist ;
								oPt           = pMathPntOnSurface; 
								oNormalVector = FaceNorVec;
								rc = CATReturnSuccess; 
							}
						} // Point Ok = Pt Proj 
						// Modif 1 
						delete pProjectionOpe ; pProjectionOpe =NULL;
						if (pLocalConfig) pLocalConfig -> Release() ; pLocalConfig = NULL; 

					} // Proj Ope 
				}
			} // Surface 
		} // Loop on Surface Liste 
	} // Domain 
	return rc ;

}
CATBoolean GetDistanceFormDirection(CATMathPoint iMathPoint1,
									CATMathLine iMathLine1,
									CATISpecObject_var specPoint1,
									CATISpecObject_var spSpecWeldPart1,
									CATMathPoint iMathPoint2,
									CATMathLine iMathLine2,
									CATISpecObject_var specPoint2,
									CATISpecObject_var spSpecWeldPart2,
									double &odbdistance,
									CATMathPoint &oMathPoint1G,
									CATMathPoint &oMathPoint2G)
{
	if (spSpecWeldPart1==NULL_var||spSpecWeldPart2==NULL_var||specPoint1==NULL_var||specPoint2==NULL_var)
		return FALSE;

	//转换到焊点零件2
	CATMathTransformation transMatrix=GetMatrixTransformation(spSpecWeldPart1, spSpecWeldPart2);
	CATMathTransformation transAbs=GetAbsTransformation(spSpecWeldPart2);

	iMathPoint1=transMatrix*iMathPoint1;
	iMathLine1=transMatrix*iMathLine1;

	//获取点的body
	CATBody_var spPointBody1=GetBodyFromFeature(specPoint1);
	if (spPointBody1==NULL_var)
	{
		return FALSE;
	}

	CATBody_var spPointBody2=GetBodyFromFeature(specPoint2);
	if (spPointBody2==NULL_var)
	{
		return FALSE;
	}

	CATGeoFactory_var spiGeoFactory=spPointBody2->GetContainer(TRUE, CatCGMExplicit);
	if (spiGeoFactory==NULL_var)
	{
		cout<<"GetContainer Failed"<<endl;
		return FALSE;
	}

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATMathVector iMathVector1;
	CATMathVector iMathVector2;
	iMathLine1.GetDirection(iMathVector1);
	iMathLine2.GetDirection(iMathVector2);

	CATBody_var spLineBody1=NULL_var;
	CATBody_var spLineBody2=NULL_var;
	double dbdistance=10;
	CreateTopAssembleLine(spiGeoFactory,iMathPoint1, iMathVector1,dbdistance,spLineBody1);
	CreateTopAssembleLine(spiGeoFactory,iMathPoint2, iMathVector2,dbdistance,spLineBody2);
	if (spLineBody1==NULL_var||spLineBody2==NULL_var)
	{
		return FALSE;
	}

	////挂结构树
	//CATIPrtContainer_var spiCont=NULL_var;
	//CATISpecObject_var spPrtPart=NULL_var;
	//GetPrtContFromPrd(spSpecWeldPart2, spiCont,spPrtPart);
	//if (spiCont==NULL_var||spPrtPart==NULL_var)
	//{
	//	cout<<"GetPrtContFromPrd Failed"<<endl;
	//	return FALSE;
	//}

	//CATIDatumFactory*pDatumFactory =NULL;
	//spiCont->QueryInterface(IID_CATIDatumFactory,(void**) &pDatumFactory);
	//if (pDatumFactory!=NULL)
	//{
	//	CATIAlias_var spAlias=NULL_var;
	//	CATUnicodeString strName1;
	//	CATUnicodeString strName2;

	//	spAlias=specPoint1;
	//	strName1=spAlias->GetAlias();

	//	spAlias=specPoint2;
	//	strName2=spAlias->GetAlias();

	//	CATISpecObject_var spTempSpec1=NULL_var;
	//	CATISpecObject_var spTempSpec2=NULL_var;
	//	InsertInGeoSet(spLineBody1,pDatumFactory ,spTempSpec1);
	//	InsertInGeoSet(spLineBody2,pDatumFactory ,spTempSpec2);

	//	spAlias=spTempSpec1;
	//	if (spAlias!=NULL_var)
	//	{
	//		spAlias->SetAlias(strName1);
	//	}

	//	spAlias=spTempSpec2;
	//	if (spAlias!=NULL_var)
	//	{
	//		spAlias->SetAlias(strName2);
	//	}
	//}

	CATMathPoint itempMathPoint1;
	CATMathPoint itempMathPoint2;
	CATCell_var spSupportCell1=NULL_var;
	CATCell_var ispSupportCell2=NULL_var;
	CATBoolean issucess=FALSE;
	MinDistanceBody(spiGeoFactory,Topdata,spPointBody1,spLineBody2,odbdistance,itempMathPoint1,itempMathPoint2,spSupportCell1,ispSupportCell2,issucess)	;

	oMathPoint1G=transAbs*itempMathPoint1;
	oMathPoint2G=transAbs*itempMathPoint2;

	return TRUE;
}
HRESULT InsertInGeoSet(CATBody_var iBody,CATIDatumFactory * ipDatumFactory , CATISpecObject_var &spTempSpec)
{
	HRESULT rc = E_FAIL;

	if (ipDatumFactory==NULL||iBody==NULL_var)
		return rc;

	//特征化
	CATISpecObject * pTempSpec = NULL;
	rc=ipDatumFactory->InstanciateDatum(iBody,pTempSpec);
	if (pTempSpec==NULL_var)
		return rc;

	spTempSpec = pTempSpec;
	spTempSpec ->Update();

	CATIGSMProceduralView_var spProceduralView = spTempSpec;
	if (NULL_var != spProceduralView )
		rc = spProceduralView->InsertInProceduralView();

	spProceduralView = NULL_var;

	return rc ;
}
CATBoolean GetConnectorThickness(CATGeoFactory_var spiGeoFactory,
								 CATTopData Topdata,
								 CATMathPoint iMathPointOnSurface,
								 CATMathVector iMathVectorSurface,
								 CATBody_var spBody,
								 double &odbThickness,
								 CATMathPoint &oThicknessMathPoint1,
								 CATMathPoint &oThicknessMathPoint2)
{
	//cout<<"GetConnectorThickness satrt"<<endl;

	HRESULT rc =E_FAIL;

	CATIAlias_var spAlias=NULL_var;

	if (spBody==NULL_var)
	{
		cout<<"GetConnectorThickness Failed"<<endl;
		return FALSE;
	}

	//过该点坐垂直平面的直线
	CATBody_var spLineBody=NULL_var;
	double Linelength=iMathVectorSurface.Norm( ) ;
	Linelength=10*Linelength;
	CreateTopAssembleLine(spiGeoFactory,iMathPointOnSurface,iMathVectorSurface,Linelength,spLineBody);
	if (spLineBody==NULL_var)
	{
		cout<<"CreateTopAssembleLine failed"<<endl;
		return FALSE;
	}

	//InsertInGeoSet(spLineBody,pDatumFactory ,NULL_var);

	CATBody_var spInsectBody=NULL_var;
	spInsectBody=CreateTopIntersect(spiGeoFactory, &Topdata,spLineBody,spBody);
	if (spInsectBody==NULL_var)
	{
		cout<<"CreateTopIntersect failed"<<endl;
		return FALSE;
	}

	//InsertInGeoSet(spInsectBody,pDatumFactory ,NULL_var);

	CATLISTP(CATBody) ListLineBody;//所有的交线
	ListLineBody.RemoveAll();
	ListLineBody.Append(spInsectBody);
	if (ListLineBody.Size()==0)
	{
		cout<<"get insect line failed"<<endl;
		return FALSE;
	}

	//CATBody_var spPointBodyOnSur=NULL_var;
	//CreateTopPointByXYZ(spiGeoFactory,Topdata,iMathPointOnSurface,spPointBodyOnSur);
	//if (spPointBodyOnSur==NULL_var)
	//{
	//	cout<<"CreateTopPointByXYZ Failed"<<endl;
	//	return FALSE;
	//}

	CATLISTV(CATMathPoint) oLstMathPoint;
	rc=GetInsectLength(spBody,ListLineBody,oLstMathPoint,iMathPointOnSurface,odbThickness,oThicknessMathPoint1,oThicknessMathPoint2);
	if (FAILED(rc))
	{
		cout<<"GetInsectLength failed"<<endl;
		return FALSE;
	}

	//cout<<"GetConnectorThickness end"<<endl;

	return TRUE;
}
//-----------------------------------------------------------------------------------------
//获得交线的长度
//-----------------------------------------------------------------------------------------
HRESULT GetInsectLength(CATBody_var spBody,
						CATLISTP(CATBody) iListLineBody,
						CATLISTV(CATMathPoint) &iLstMathPoint,
						CATMathPoint iRefMathPoint,
						double &odbength,
						CATMathPoint &oMathPoint1,
						CATMathPoint &oMathPoint2)
{
	//cout<<"GetInsectLength"<<endl;

	if(iListLineBody.Size()==0)
		return E_FAIL;

	CATSoftwareConfiguration * pConfig = new CATSoftwareConfiguration();//配置指针
	CATTopData Topdata(pConfig);

	CATGeoFactory_var spiGeoFactory=spBody->GetContainer(TRUE, CatCGMExplicit);
	if (spiGeoFactory==NULL_var)
	{
		cout<<"GetContainer Failed"<<endl;
		return E_FAIL;
	}

	for (int i=1;i<=iListLineBody.Size();i++)
	{
		CATBody_var ispiBody=iListLineBody[i];
		if(ispiBody == NULL_var)  continue;

		CATLISTP(CATCell) LISTCell; 
		LISTCell.RemoveAll();
		ispiBody->GetAllCells( LISTCell, 0 ); 
		if (LISTCell.Size()==0) 
			continue;

		//cout<<"交点的数量=="<<LISTCell.Size()<<endl;

		for( int index = 1; index <= LISTCell.Size(); index++ )
		{ 
			CATCell_var spCell = LISTCell[index]; 
			if(spCell == NULL_var) 
			{
				cout<<"CATCell_var is NULL_var."<<endl;
				continue;
			}

			CATVertex_var spVertex = spCell;
			if(spVertex == NULL_var) 
			{
				cout<<"CATVertex is NULL_var."<<endl;
				continue;
			}

			CATPoint *pPoint = spVertex->GetPoint();
			if(pPoint == NULL) 
			{
				cout<<"GetPoint failed."<<endl;
				continue;
			}

			CATMathPoint oMathPoint;
			pPoint->GetMathPoint(oMathPoint);

			iLstMathPoint.Append(oMathPoint);

		}
	}

	if (iLstMathPoint.Size()<2)
	{
		return E_FAIL;
	}

	//获得距离最小的两个点
	odbength=10000;
	for (int i=1;i<=iLstMathPoint.Size();i++)
	{
		CATMathPoint iMathPoint;
		iMathPoint=iLstMathPoint[i];

		double length=0;
		length=iRefMathPoint.DistanceTo(iMathPoint);
		//cout<<"length=="<<length<<endl;

		if (length<=0.01)
		{
			//cout<<"length<=0.01"<<endl;
			continue;
		}

		if (length<odbength)
		{
			oMathPoint1=iRefMathPoint;
			oMathPoint2=iMathPoint;
			odbength=length;
		}
	}

	iLstMathPoint.RemoveAll();
	iLstMathPoint.Append(oMathPoint1);
	iLstMathPoint.Append(oMathPoint2);

	return S_OK;
}
CATBoolean GetListConnector(CATListValCATUnicodeString LstPartNumber,
							CATListValCATUnicodeString LstInstanceName,
							CATLISTV(CATISpecObject_var) ListOfObject,
							CATListValCATUnicodeString ListConnectionPartNumbers,
							CATISpecObject_var spWeldPoint,
							CATISpecObject_var  spWeldPart,
							CATLISTV(CATISpecObject_var) &LstConnectionPart,
							CATListOfDouble &LstConnectionDistance)
{
	LstConnectionPart.RemoveAll();
	LstConnectionDistance.RemoveAll();

	for(int qq=1;qq<=ListConnectionPartNumbers.Size();qq++)
	{
		CATISpecObject_var  spTempPart=NULL_var;
		double dbMinDistance=1000000;
		for (int ww=1;ww<=LstPartNumber.Size();ww++)
		{
			if (ListConnectionPartNumbers[qq]==LstPartNumber[ww])
			{
				//cout<<"instance name:"<<LstInstanceName[ww]<<endl;

				//计算距离
				CATMathPoint omathPt1;
				CATMathPoint omathPt2;
				double dbDistance=1000000;
				CATBoolean issucess=FALSE;
				GetMinDistance( spWeldPoint, ListOfObject[ww], omathPt1, omathPt2, dbDistance, issucess );

				//double dbDistance2=1000000;
				//GetDistance(spWeldPoint,spWeldPart,ListOfObject[ww],ListOfObject[ww],omathPt1,omathPt2,dbDistance2);

				if (dbDistance<dbMinDistance)
				{
					spTempPart=ListOfObject[ww];
					dbMinDistance=dbDistance;
				}
			}
		}

		if (spTempPart!=NULL_var)
		{
			LstConnectionPart.Append(spTempPart);
			LstConnectionDistance.Append(dbMinDistance);
		}

	}

	return TRUE;
}
CATBoolean GetWeldPartDirectGset(CATISpecObject_var ispSpecPart,
								 CATListValCATUnicodeString LstGsetName,
								 CATListValCATISpecObject_var &oLstSurfBodies)
{
	if (ispSpecPart==NULL_var)
		return FALSE;

	CATIPrtContainer_var spPrtContainer=GetPrtContainer(ispSpecPart);
	if (spPrtContainer==NULL_var)
	{
		cout<<"GetPrtContainer Failed"<<endl;
		return FALSE;
	}

	CATISpecObject_var spPartObject=spPrtContainer->GetPart( );
	if (spPartObject==NULL_var)
	{
		cout<<"GetPart Failed"<<endl;
		return FALSE;
	}

	CATIPartRequest_var spDescendants = spPartObject;
	if (spDescendants==NULL_var)
	{
		cout<<"Get CATIDescendants Failed"<<endl;
		return FALSE;

	}

	CATListValCATBaseUnknown_var LstSurfBodies;
	spDescendants->GetSurfBodies( "",LstSurfBodies);
	if (LstSurfBodies.Size()==0)
	{
		cout<<"Get SurfBodies Failed"<<endl;
		return FALSE;
	}

	CATIAlias_var spAlias=NULL_var;
	CATUnicodeString strName;
	CATListValCATUnicodeString LstSurfBodyNames;
	for (int i=1;i<=LstSurfBodies.Size();i++)
	{
		spAlias=LstSurfBodies[i];
		if (spAlias==NULL_var)
			continue;

		strName=spAlias->GetAlias();
		LstSurfBodyNames.Append(strName);
	}

	if (LstSurfBodyNames.Size()!=LstSurfBodies.Size())
	{
		return FALSE;
	}

	for (int i=1;i<=LstGsetName.Size();i++)
	{
		CATUnicodeString strGsetName=LstGsetName[i];
		int pos=LstSurfBodyNames.Locate(strGsetName);
		if (pos>0)
		{
			oLstSurfBodies.Append(LstSurfBodies[pos]);
		}
	}

	return TRUE;

}
CATBoolean GetConnectorInfor(CATListValCATISpecObject_var LstConnectionPart,
							 CATListOfDouble LstConnectionDistance,
							 CATISpecObject_var specPoint,
							 CATISpecObject_var spSpecWeldPart,
							 CATMathPoint &oMathPointOnSurface,
							 CATMathLine &oMathLineOnSurface,
							 CATListOfDouble &oLstdbConnectionThickness,
							 CATLISTV(CATMathPoint) &oLstMathPointOnSurface,
							 CATLISTV(CATMathLine) &oLstMathLineOnSurface)
{
	CATIAlias_var spAlias=NULL_var;

	CATUnicodeString  strConnectorName;
	double dbmindistance=DBL_MAX;

	oLstdbConnectionThickness.RemoveAll();
	oLstMathPointOnSurface.RemoveAll();
	oLstMathLineOnSurface.RemoveAll();

	//获取厚度，以及法向
	for (int tt=1;tt<=LstConnectionPart.Size();tt++)
	{
		spAlias=LstConnectionPart[tt];
		double tempdistance=LstConnectionDistance[tt];

		strConnectorName=spAlias->GetAlias();

		//计算法向
		CATBaseUnknown_var spObject=NULL_var;
		CATFace_var spFace=NULL_var;
		CATMathPoint iTempMathPointOnSurface;
		CATMathVector  iTempMathVectorSurface;
		GetConnectionPartSurfaceNormal( specPoint,spSpecWeldPart,LstConnectionPart[tt], spObject, spFace, iTempMathPointOnSurface, iTempMathVectorSurface);
		if(spObject==NULL_var)
		{
			cout<<"GetConnectionPartSurfaceNormal failed"<<endl;
			continue;
		}

		double dbThickness=0;
		GetConnectionPartThickness( spObject, iTempMathPointOnSurface,iTempMathVectorSurface,dbThickness);
		if (dbThickness<0.01)
		{
			continue;
		}
		//cout<<strConnectorName<<"厚度: "<<dbThickness<<endl;

		CATMathTransformation transMatrix=GetMatrixTransformation(LstConnectionPart[tt], spSpecWeldPart);

		//位置换算到焊点文件中
		CATMathPoint iMathPointOnSurface = transMatrix * iTempMathPointOnSurface;
		CATMathVector iMathVectorSurface = transMatrix * iTempMathVectorSurface;

		CATMathLine iMathLineSurface(iMathPointOnSurface,iMathVectorSurface);

		oLstMathPointOnSurface.Append(iMathPointOnSurface);
		oLstMathLineOnSurface.Append(iMathLineSurface);
		oLstdbConnectionThickness.Append(dbThickness);

		if (tempdistance<dbmindistance)
		{
			dbmindistance=tempdistance;
			oMathPointOnSurface=iMathPointOnSurface;
			oMathLineOnSurface=iMathLineSurface;
		}
	}

	return TRUE;
}
//从几何图形集下找到ipoint
CATBoolean GetWeldSpotFromGset(CATISpecObject_var ispSpec,
							   CATListValCATISpecObject_var	&spSpecPointList,
							   CATListValCATISpecObject_var	&spSpecBallList)
{
	if (ispSpec==NULL_var)
		return FALSE;

	CATIDescendants_var spDescendants = ispSpec;
	if (spDescendants==NULL_var)
	{
		cout<<"Get CATIDescendants Failed"<<endl;
		return FALSE;
	}

	spDescendants -> GetAllChildren("CATIMfZeroDimResult",spSpecPointList);	
	spDescendants -> GetAllChildren("CATIMfBiDimResult",spSpecBallList);	

	CATIAlias_var spAlias=NULL_var;

	CATListValCATISpecObject_var tempBallList;
	CATListValCATISpecObject_var tempPointList;

	CATListValCATUnicodeString LstPointName;
	for (int i=1;i<=spSpecPointList.Size();i++)
	{
		spAlias=spSpecPointList[i];
		LstPointName.Append(spAlias->GetAlias());
	}

	CATListValCATUnicodeString LstBallName;
	for (int i=1;i<=spSpecBallList.Size();i++)
	{
		spAlias=spSpecBallList[i];
		LstBallName.Append(spAlias->GetAlias());
	}

	for (int i=1;i<=spSpecPointList.Size();i++)
	{
		int pos=LstBallName.Locate(LstPointName[i]);
		if (pos>0&&spSpecBallList.Size()>=pos)
		{
			tempBallList.Append(spSpecBallList[pos]);
			tempPointList.Append(spSpecPointList[i]);
		}
	}

	spSpecBallList=tempBallList;
	spSpecPointList=tempPointList;

	return FALSE;

}
CATBoolean GetWeldSpotFromPart(CATISpecObject_var ispSpecPart,
							   CATListValCATISpecObject_var	&spSpecPointList,
							   CATListValCATISpecObject_var	&spSpecBallList)
{
	if (ispSpecPart==NULL_var)
		return FALSE;

	CATIPrtContainer_var spPrtContainer=GetPrtContainer(ispSpecPart);
	if (spPrtContainer==NULL_var)
	{
		cout<<"GetPrtContainer Failed"<<endl;
		return FALSE;
	}

	CATISpecObject_var spPartObject=spPrtContainer->GetPart( );
	if (spPartObject==NULL_var)
	{
		cout<<"GetPart Failed"<<endl;
		return FALSE;
	}

	CATIDescendants_var spDescendants = spPartObject;
	if (spDescendants==NULL_var)
	{
		cout<<"Get CATIDescendants Failed"<<endl;
		return FALSE;
	}

	spDescendants -> GetAllChildren("CATIMfZeroDimResult",spSpecPointList);	
	spDescendants -> GetAllChildren("CATIMfBiDimResult",spSpecBallList);	

	CATIAlias_var spAlias=NULL_var;

	CATListValCATISpecObject_var tempBallList;
	CATListValCATISpecObject_var tempPointList;

	CATListValCATUnicodeString LstPointName;
	for (int i=1;i<=spSpecPointList.Size();i++)
	{
		spAlias=spSpecPointList[i];
		LstPointName.Append(spAlias->GetAlias());
	}

	CATListValCATUnicodeString LstBallName;
	for (int i=1;i<=spSpecBallList.Size();i++)
	{
		spAlias=spSpecBallList[i];
		LstBallName.Append(spAlias->GetAlias());
	}

	for (int i=1;i<=spSpecPointList.Size();i++)
	{
		int pos=LstBallName.Locate(LstPointName[i]);
		if (pos>0&&spSpecBallList.Size()>=pos)
		{
			tempBallList.Append(spSpecBallList[pos]);
			tempPointList.Append(spSpecPointList[i]);
		}
	}

	spSpecBallList=tempBallList;
	spSpecPointList=tempPointList;

	return FALSE;
}
HRESULT GetDistance(CATISpecObject_var ispiSpec1,
					CATIProduct_var ispiProd1,
					CATISpecObject_var ispiSpec2,
					CATIProduct_var ispiProd2,
					CATMathPoint &omathPt1,
					CATMathPoint &omathPt2,
					double &oDistance)
{
	CATIMeasurableInContext_var spMeasurableInContext1 = ispiSpec1;
	CATIMeasurableInContext_var spMeasurableInContext2 = ispiSpec2;
	CATIMeasurable_var spMeasurable2 = ispiSpec2;
	if (spMeasurableInContext1 == NULL_var) return E_FAIL;
	if (spMeasurableInContext2 == NULL_var) return E_FAIL;
	if (spMeasurable2 == NULL_var) return E_FAIL;

	CATMathAxis ioAxis;
	double oMinDis = 9999.0;
	spMeasurableInContext2->GetAxisSystemFromMeasurable(ioAxis);
	//
	CATMathTransformation transAxis = GetMatrixTransformation(ispiProd2,ispiProd1);		//注意，该处坐标需要从2变换到1内
	ioAxis = transAxis * ioAxis;
	//
	spMeasurableInContext1->MinimumDistance(spMeasurable2,ioAxis,oMinDis,omathPt1,omathPt2);	//这里输出的两个点坐标都是在1内的坐标，后续可以按需变换到全局或变换到2
	oDistance = oMinDis;

	return S_OK;
}

//比较2个CATCell是不是一样
//规则：
//2维cell：取cell1的中心点，和cell2作距离，小于0.005则认为是同一个面；如果大于0.005，反过来再算一次，小于0.005则是同一个面
//1维cell：去cell1的中点，和cell2作距离，后同上
int IsSameCell(CATGeoFactory *ipGeoFactory, CATTopData *ipTopData, CATCell_var ispCell1,CATCell_var ispCell2,int iDimension)
{
	if (ipGeoFactory == NULL || ipTopData == NULL || ispCell1 == NULL_var || ispCell2 == NULL_var)
	{
		return -1;
	}
	//
	double dblDistance = DBL_MAX;
	HRESULT rc = MinDistanceBetweenTwoCells(ipGeoFactory,ipTopData,ispCell1,ispCell2,iDimension,dblDistance);
	//if (FAILED(rc))
	//{
	//	return -1;
	//}
	if (dblDistance <= TOLMINDISTANCE)
	{
		return 1;
	} 
	else
	{
		rc = MinDistanceBetweenTwoCells(ipGeoFactory,ipTopData,ispCell2,ispCell1,iDimension,dblDistance);
		if (FAILED(rc))
		{
			return -1;
		}
		if (dblDistance <= TOLMINDISTANCE)
		{
			return 1;
		}
		return 0;
	}
}

//计算cell1的中心点到cell2的最小距离，两个cell均为2维cell
HRESULT MinDistanceBetweenTwoCells(CATGeoFactory *ipGeoFactory, CATTopData *ipTopData, CATCell_var ispCell1,CATCell_var ispCell2,int iDimension,double &odblDistance)
{
	HRESULT rc = S_OK;
	//先获取cell1上的中点
	CATBody *pBodyCenterPt1 = NULL;
	switch (iDimension)
	{
	case 2:
		{
			CATFace_var spFace = ispCell1;
			if(spFace == NULL_var) 
			{
				return E_FAIL;
			}
			CATSurParam oCenterParam;
			spFace->EstimateCenterParam(oCenterParam);

			CATSurface_var spSurface = spFace->GetSurface();
			if(spSurface == NULL_var) 
			{
				return E_FAIL;
			}
			CATMathPoint centerPt1 = spSurface->EvalPoint(oCenterParam);
			//
			pBodyCenterPt1 = CATCreateTopPointXYZ(ipGeoFactory,ipTopData,centerPt1.GetX(),centerPt1.GetY(),centerPt1.GetZ());
			if (pBodyCenterPt1 == NULL)
			{
				return E_FAIL;
			}
			break;
		}
	case 1:
		{
			rc = GetMiddlePointFromCurveCell(ipGeoFactory,ipTopData,ispCell1,pBodyCenterPt1);
			if (FAILED(rc) || pBodyCenterPt1 == NULL)
			{
				return E_FAIL;
			}
			break;
		}
	default:
		return E_FAIL;
	}

	//再把cell2转成body
	CATBody *pBodyCell2 = CreateBodyFromCell(ipGeoFactory,ispCell2,iDimension);
	if (pBodyCell2 == NULL)
	{
		return E_FAIL;
	}
	//求出最小距离
	rc = MinDistance(ipGeoFactory,ipTopData,pBodyCenterPt1,pBodyCell2,odblDistance);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	return rc;
}

//计算2个body的最小距离
HRESULT MinDistance(CATGeoFactory *ipGeoFactory,
								  CATTopData *iTopdata,
								  CATBody_var ispSoildBody,
								  CATBody_var ispPointBody,
								  double &olength)
{
	CATTry 
	{
		CATDistanceMinBodyBody*piMinDistanceBody=NULL;
		piMinDistanceBody= CATCreateDistanceMinTopo(ipGeoFactory, iTopdata, ispSoildBody,ispPointBody,ADVANCED) ;
		if (piMinDistanceBody==NULL)
		{
			cout<<"CATCGMCreateDistanceBodyBodyOp Failed"<<endl;
			return E_FAIL;
		}

		piMinDistanceBody->Run();

		olength=piMinDistanceBody->GetDistance();

		//cout<<"MinDistance Length:"<<olength<<endl;

	}
	CATCatch(CATError , pError)
	{
		return E_FAIL;
	}
	CATEndTry

		return S_OK;
}

//用投影的方式计算点到另一个body的距离（面或者线）
HRESULT MinDistanceFromProject(CATGeoFactory *ipGeoFactory,CATTopData *ipTopData,CATBody_var ispBodyPoint,CATBody_var ispBodySupport,double &odblLength)
{
	HRESULT rc = S_OK;
	//做投影
	CATHybProject *pHybProject=CATCreateTopProject( ipGeoFactory, ipTopData, ispBodyPoint, ispBodySupport) ;
	if (pHybProject==NULL)
	{
		return E_FAIL;
	}
	pHybProject->Run();

	CATBody_var spResultBody= pHybProject->GetResult();
	if (spResultBody==NULL_var)
	{
		return E_FAIL;
	}
	//输入点和投影点算距离
	CATMathPoint pt1,pt2;
	rc = GetMathPtFromBody(ispBodyPoint,pt1);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	rc = GetMathPtFromBody(spResultBody,pt2);
	if (FAILED(rc))
	{
		return E_FAIL;
	}
	odblLength = pt1.DistanceTo(pt2);
	return rc;
}

//获取1维cell的中点的body
HRESULT GetMiddlePointFromCurveCell(CATGeoFactory *ipGeoFactory,CATTopData *ipTopData,CATCell_var ispCellCurve,CATBody *&opBodyPtMiddle)
{
	HRESULT rc = S_OK;
	if (ipGeoFactory == NULL || ipTopData == NULL || ispCellCurve == NULL_var)
	{
		return E_FAIL;
	}
	//先获取curve cell的body
	CATBody *pBodyCurve = CreateBodyFromCell(ipGeoFactory,ispCellCurve,1);
	if (pBodyCurve == NULL)
	{
		return E_FAIL;
	}
	//获取cell的两个端点和长度
	CATEdge_var spEdgeTemp1 = ispCellCurve; 
	if(spEdgeTemp1==NULL_var)
	{
		return E_FAIL;
	}
	CATVertex*  oStartVertex=NULL;
	CATVertex*  oEndVertex=NULL;
	spEdgeTemp1->GetVertices(&oStartVertex, &oEndVertex);
	if (oEndVertex==NULL||oStartVertex==NULL)
	{
		cout<<"GetVertices Failed"<<endl;
		return E_FAIL;
	}
	CATPoint * pStartPoint=oStartVertex->GetPoint( );
	CATPoint * pEndPoint=oEndVertex->GetPoint( );
	if (pStartPoint==NULL||pEndPoint==NULL)
	{
		cout<<"GetPoint Failed"<<endl;
		return E_FAIL;
	}
	CATMathPoint sStartPoint ;
	pStartPoint->GetMathPoint(sStartPoint);
	CATMathPoint sEndPoint ;
	pEndPoint->GetMathPoint(sEndPoint);

	CATDynMassProperties3D*  iMass = CATDynCreateMassProperties3D(ipTopData,(CATEdge *)spEdgeTemp1);
	if (iMass==NULL)
	{
		return E_FAIL;
	}
	CATPositiveLength iLength = iMass->GetLength();
	//
	double dblCellLength = iLength;
	CATBody *pBodyStartPt = CATCreateTopPointXYZ(ipGeoFactory,ipTopData,sStartPoint.GetX(),sStartPoint.GetY(),sStartPoint.GetZ());
	CATBody *pBodyEndPt = CATCreateTopPointXYZ(ipGeoFactory,ipTopData,sEndPoint.GetX(),sEndPoint.GetY(),sEndPoint.GetZ());
	if (pBodyStartPt == NULL || pBodyEndPt == NULL)
	{
		return E_FAIL;
	}
	//求出中点
	CATBody *pBodyMidPt1 = CATCreateTopPointOnWire(ipGeoFactory,ipTopData,pBodyCurve,0.5,pBodyStartPt,CatTopPointLRatio);
	CATBody *pBodyMidPt2 = CATCreateTopPointOnWire(ipGeoFactory,ipTopData,pBodyCurve,0.5,pBodyEndPt,CatTopPointLRatio);
	CATBody *pBodyMidPt3 = CATCreateTopPointOnWire(ipGeoFactory,ipTopData,pBodyCurve,-0.5,pBodyStartPt,CatTopPointLRatio);
	CATBody *pBodyMidPt4 = CATCreateTopPointOnWire(ipGeoFactory,ipTopData,pBodyCurve,-0.5,pBodyEndPt,CatTopPointLRatio);
	if (pBodyMidPt1 == NULL || pBodyMidPt2 == NULL || pBodyMidPt3 == NULL || pBodyMidPt4 == NULL)
	{
		return E_FAIL;
	}
	CATLISTP(CATBody) lstBody;
	lstBody.Append(pBodyMidPt1);
	lstBody.Append(pBodyMidPt2);
	lstBody.Append(pBodyMidPt3);
	lstBody.Append(pBodyMidPt4);

	CATMathPoint midPt1,midPt2,midPt3,midPt4;
	HRESULT rc1 = GetMathPtFromBody(pBodyMidPt1,midPt1);
	HRESULT rc2 = GetMathPtFromBody(pBodyMidPt2,midPt2);
	HRESULT rc3 = GetMathPtFromBody(pBodyMidPt3,midPt3);
	HRESULT rc4 = GetMathPtFromBody(pBodyMidPt4,midPt4);
	if (FAILED(rc1)||FAILED(rc2)||FAILED(rc3)||FAILED(rc4))
	{
		return E_FAIL;
	}
	CATLISTV(CATMathPoint) lstPt;
	lstPt.Append(midPt1);
	lstPt.Append(midPt2);
	lstPt.Append(midPt3);
	lstPt.Append(midPt4);
	//判断list中相同的点即为中点
	CATBoolean bFind = FALSE;
	for (int i = 1; i <= lstPt.Size(); i++)
	{
		for (int j = lstPt.Size(); j>i; j--)
		{
			if (lstPt[i].DistanceTo(lstPt[j]) <= 0.01)
			{
				opBodyPtMiddle = lstBody[i];
				bFind = TRUE;
				break;
			}
		}
		if (bFind == TRUE)
		{
			break;
		}
	}
	return rc;
}